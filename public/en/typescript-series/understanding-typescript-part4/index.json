{
    "title": "Understanding TypeScript - Part 4: Interfaces",
    "permalink": "/blog/en/typescript-series/understanding-typescript-part4/",
    "summary": "In this article, we will examine interfaces, one of the important features of TypeScript, in detail. We will understand their differences from Type Aliases and learn practical use cases.",
    "content": "Hello! In this part of our TypeScript series, we will examine interfaces in detail, one of the most powerful features of the type system. We will learn what interfaces are, why we should use them, and how they provide benefits in real-world applications.\nWhat is an Interface and Why Should We Use It? Interfaces are a feature in TypeScript that allows us to define the structure of objects. To explain it in simple terms:\n\u0026ldquo;Think of it like drawing a construction plan. In this plan, you have details like how many floors the building will have, room dimensions, window locations, etc. An interface is just like that - it draws a \u0026lsquo;plan\u0026rsquo; for an object. We determine in advance what properties it will have and what types these properties will be.\u0026rdquo;\nHere\u0026rsquo;s a simple example:\n// Simple interface definition interface User { // Required properties id: number; // Unique number of the user name: string; // Name of the user email: string; // Email address // Optional properties (marked with ?) phone?: string; // Phone number (optional) age?: number; // Age information (optional) } // Using the interface const newUser: User = { id: 1, name: \u0026#39;John Smith\u0026#39;, email: \u0026#39;john@example.com\u0026#39;, // phone and age are optional, so we don\u0026#39;t have to write them }; // TypeScript protects us here const invalidUser: User = { id: \u0026#39;1\u0026#39;, // Error! string value cannot be assigned to number type name: \u0026#39;Michael\u0026#39;, email: true, // Error! boolean value cannot be assigned to string type }; Advantages of Using Interfaces Code Safety: // Function defined with interface function updateUser(id: number, user: User) { // Thanks to TypeScript, we\u0026#39;re sure about the structure of the user object console.log(`Updating ${user.name}...`); // ... update operations } // This works updateUser(1, { id: 1, name: \u0026#39;John\u0026#39;, email: \u0026#39;john@example.com\u0026#39;, }); // This gives an error - missing and incorrect properties updateUser(1, { id: 1, firstName: \u0026#39;John\u0026#39;, // Error! should be \u0026#39;name\u0026#39; instead of \u0026#39;firstName\u0026#39; }); Code Completion: Interfaces enhance your IDE\u0026rsquo;s code completion feature. When accessing an object\u0026rsquo;s properties, the IDE shows you all available properties.\nDocumentation: Interfaces also serve as documentation. Other developers reading your code can quickly understand the structure of an object.\nInterface vs Type: Understanding the Differences Let\u0026rsquo;s examine the differences between Interface and Type with real examples:\n1. Declaration Merging // Declaration merging is possible with interfaces interface Car { brand: string; } interface Car { // We can add new properties with the same name model: string; } const tesla: Car = { brand: \u0026#39;Tesla\u0026#39;, // Properties from both model: \u0026#39;Model 3\u0026#39;, // interfaces are required }; // This is not possible with Type type Bicycle = { brand: string; }; // Error! Identifier \u0026#39;Bicycle\u0026#39; has already been declared type Bicycle = { model: string; }; This feature is especially useful when developing libraries. Users can add new properties to existing interfaces.\n2. Extends and Implements Interfaces are very useful in object-oriented programming:\n// Base interface interface Animal { name: string; species: string; makeSound(): void; } // Deriving from interface interface Cat extends Animal { hasPaws: boolean; canClimb: boolean; } // Usage in classes class TabbyCat implements Cat { // We must implement all properties and methods name: string; species: string = \u0026#39;Cat\u0026#39;; hasPaws: boolean = true; canClimb: boolean = true; constructor(name: string) { this.name = name; } makeSound() { console.log(\u0026#39;Meow!\u0026#39;); } } Interface Methods and Properties Interfaces can define not only data structure but also object behaviors. Let\u0026rsquo;s proceed with a real example:\n// Interface for product management in an e-commerce system interface ProductManagement { // Basic CRUD operations addProduct(product: Product): Promise\u0026lt;boolean\u0026gt;; updateProduct(id: string, product: Product): Promise\u0026lt;boolean\u0026gt;; deleteProduct(id: string): Promise\u0026lt;boolean\u0026gt;; getProduct(id: string): Promise\u0026lt;Product | null\u0026gt;; // Stock management methods updateStock(productId: string, quantity: number): Promise\u0026lt;void\u0026gt;; checkStock(productId: string): Promise\u0026lt;number\u0026gt;; // Statistics methods generateSalesReport(start: Date, end: Date): Promise\u0026lt;SalesReport\u0026gt;; } // A class using this interface class PostgreSQLProductManagement implements ProductManagement { constructor(private db: Database) {} async addProduct(product: Product): Promise\u0026lt;boolean\u0026gt; { try { await this.db.query(\u0026#39;INSERT INTO products (id, name, price, stock) VALUES ($1, $2, $3, $4)\u0026#39;, [ product.id, product.name, product.price, product.stock, ]); return true; } catch (error) { console.error(\u0026#39;Error adding product:\u0026#39;, error); return false; } } // Implementation of other methods... } Readonly and Optional Properties We can make some properties in interfaces readonly or optional. Here\u0026rsquo;s a real scenario:\n// Interface for user profile interface UserProfile { // Readonly properties (cannot be changed) readonly id: string; // User ID never changes readonly registrationDate: Date; // Registration date cannot be changed // Required properties email: string; // Email address name: string; // Username // Optional properties phone?: string; // Phone number address?: { // Address information city: string; district: string; postalCode?: string; }; profilePicture?: string; // Profile picture URL // Social media information (all optional) socialMedia?: { twitter?: string; linkedin?: string; github?: string; }; } // Usage example const newProfile: UserProfile = { id: \u0026#39;usr_123\u0026#39;, // readonly, can only be assigned during initialization registrationDate: new Date(), // readonly, can only be assigned during initialization email: \u0026#39;john@example.com\u0026#39;, name: \u0026#39;John Smith\u0026#39;, // We don\u0026#39;t have to add optional fields }; // INCORRECT USAGE - cannot modify readonly properties newProfile.id = \u0026#39;usr_456\u0026#39;; // Error! readonly property cannot be modified newProfile.registrationDate = new Date(); // Error! readonly property cannot be modified // We can add optional properties later newProfile.phone = \u0026#39;555-0123\u0026#39;; newProfile.address = { city: \u0026#39;New York\u0026#39;, district: \u0026#39;Manhattan\u0026#39;, }; Generic Interfaces Generics make interfaces more flexible and reusable. For example, a generic interface for API responses:\n// Generic API response interface interface APIResponse\u0026lt;T\u0026gt; { success: boolean; // Is the operation successful? data: T; // Generic data type timestamp: number; // Operation time statusCode: number; // HTTP status code message?: string; // Optional message errors?: string[]; // Error messages if any } // Usage with different data types interface User { id: number; name: string; email: string; } interface Product { id: number; name: string; price: number; } // API response for user list const usersResponse: APIResponse\u0026lt;User[]\u0026gt; = { success: true, data: [ { id: 1, name: \u0026#39;John\u0026#39;, email: \u0026#39;john@example.com\u0026#39; }, { id: 2, name: \u0026#39;Michael\u0026#39;, email: \u0026#39;michael@example.com\u0026#39; }, ], timestamp: Date.now(), statusCode: 200, }; // API response for a single product const productResponse: APIResponse\u0026lt;Product\u0026gt; = { success: false, data: { id: 0, name: \u0026#39;\u0026#39;, price: 0 }, // Empty product timestamp: Date.now(), statusCode: 404, message: \u0026#39;Product not found\u0026#39;, errors: [\u0026#39;Product with specified ID does not exist\u0026#39;], }; Interface Inheritance Interfaces can inherit from each other. This feature prevents code repetition and helps us create a modular structure:\n// Basic entity properties interface Entity { id: string; // Unique identifier createdAt: Date; // Creation date updatedAt: Date; // Last update date deleted: boolean; // Deletion status } // Basic person information interface Person extends Entity { firstName: string; lastName: string; email: string; phone?: string; } // Student information interface Student extends Person { studentId: string; department: string; year: number; courses: string[]; gpa?: number; } // Teacher information interface Teacher extends Person { employeeId: string; subject: string; coursesTaught: string[]; salary: number; } // Usage example const newStudent: Student = { // Properties from Entity id: \u0026#39;std_123\u0026#39;, createdAt: new Date(), updatedAt: new Date(), deleted: false, // Properties from Person firstName: \u0026#39;John\u0026#39;, lastName: \u0026#39;Smith\u0026#39;, email: \u0026#39;john@school.edu\u0026#39;, // Student-specific properties studentId: \u0026#39;2024001\u0026#39;, department: \u0026#39;Computer Engineering\u0026#39;, year: 2, courses: [\u0026#39;Algorithms\u0026#39;, \u0026#39;Data Structures\u0026#39;, \u0026#39;TypeScript 101\u0026#39;], }; Common Use Cases for Interfaces Interfaces appear in many areas of software development. Here are the most common use cases:\n1. API Communication We use interfaces to define incoming and outgoing data structures when working with APIs:\n// Structure of user data coming from API interface UserResponse { id: number; name: string; email: string; role: \u0026#39;admin\u0026#39; | \u0026#39;user\u0026#39;; lastLogin?: Date; } // Login information to be sent to API interface LoginCredentials { email: string; password: string; remember?: boolean; } 2. Database Operations We use interfaces to model table structures and query results in database operations:\ninterface Product { id: number; // Product unique number name: string; // Product name price: number; // Product price stock: number; // Stock quantity category: string; // Product category } 3. Form Management Interfaces help us when defining form data structure and validation rules:\ninterface RegistrationForm { email: string; // User email password: string; // Password passwordConfirm: string; // Password confirmation username: string; // Username } 4. Configuration Management We use interfaces when defining application settings and configurations:\ninterface AppSettings { apiUrl: string; // API server address maxAttempts: number; // Maximum number of attempts timeout: number; // Timeout duration debug: boolean; // Debug mode on/off } 5. Data Models We use interfaces when defining basic data structures in our application:\ninterface Order { id: string; // Order number customerId: string; // Customer number products: string[]; // Products in order totalAmount: number; // Total amount status: \u0026#39;pending\u0026#39; | \u0026#39;confirmed\u0026#39; | \u0026#39;cancelled\u0026#39;; // Order status } These use cases show how important interfaces are in terms of type safety and code organization. In each area, interfaces help make our code safer and easier to maintain.\nBest Practices and Tips There are some important points to consider when using TypeScript interfaces. By applying these practices, we can write more readable and maintainable code.\n1. Naming Conventions Interface names should clearly indicate what they do and follow certain standards:\n// ✅ Good Naming Examples interface UserService { getUser(id: string): Promise\u0026lt;User\u0026gt;; } interface ProductRepository { updateStock(productId: string, quantity: number): void; } // ❌ Naming Conventions to Avoid interface IUser { // Don\u0026#39;t use \u0026#39;I\u0026#39; prefix // ... } interface dataManager { // Use PascalCase // ... } interface DATA_SERVICE { // Don\u0026#39;t use UPPERCASE // ... } 2. Single Responsibility Principle Each interface should focus on a single task and do it well:\n// ✅ Well-Designed Interfaces interface IdentityInformation { id: string; ssn: string; passportNo?: string; } interface ContactInformation { email: string; phone?: string; address?: { state: string; city: string; }; } // Combine when needed interface User extends IdentityInformation, ContactInformation { firstName: string; lastName: string; } // ❌ Situation to Avoid: Putting everything in one interface interface HugeInterface { // Identity information id: string; ssn: string; // Contact information email: string; phone: string; // Address information state: string; city: string; // User information firstName: string; lastName: string; // Other information... // ... and many more properties } 3. Adding Descriptive Comments Add comments that clearly indicate how interfaces should be used:\n/** * Card information to be used during payment process. * This interface should only be used during payment processing and * sensitive information should be cleared from memory after the transaction. */ interface PaymentInformation { /** Amount to be paid (in USD, with cent precision) */ amount: number; /** 16-digit card number */ cardNumber: string; /** Expiration date in MM/YY format (example: 12/25) */ expirationDate: string; /** 3-digit security code on the back of the card */ securityCode: string; } 4. Using Optional Properties Correctly Be careful when using optional properties and document them:\ninterface UserProfile { // Required fields id: string; name: string; email: string; // Optional fields - explain why they\u0026#39;re optional /** User may choose not to provide a phone number */ phone?: string; /** Default will be used if no profile photo is uploaded */ profilePhotoUrl?: string; /** User may not have given location permission yet */ location?: { lat: number; lng: number; }; } Conclusion Interfaces are one of the most powerful features of TypeScript, and when used correctly, they:\nMake your code more readable Provide type safety Make maintenance easier Improve team collaboration Serve as documentation The examples and best practices we\u0026rsquo;ve seen in this article will guide you in your daily TypeScript development. See you in the next article.\nFeel free to leave comments if you have any questions. Happy coding! 🚀\n",
    "tags": ["typescript","interfaces","type-system"],
    "categories": ["TypeScript"],
    "lang": "en"
} 