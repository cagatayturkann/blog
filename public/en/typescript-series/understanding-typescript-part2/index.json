{
    "title": "Understanding TypeScript - Part 2: Functions",
    "permalink": "/blog/en/typescript-series/understanding-typescript-part2/",
    "summary": "In this article, we\u0026rsquo;ll explore TypeScript functions in detail, covering parameter types, return types, and special function types that make TypeScript unique and powerful.",
    "content": "Hello everyone! In our previous article, we covered the basic types in TypeScript. Today, we\u0026rsquo;ll dive into functions and how TypeScript makes them more powerful and safer to use. We\u0026rsquo;ll start with the basics and gradually move to more advanced concepts.\nFunction Parameter Types In TypeScript, we can specify the type of function parameters, which helps prevent errors by catching them before runtime. Let\u0026rsquo;s look at a simple example:\n// Creating a function with typed arguments const encourageStudent = (name: string) =\u0026gt; { return `Hey, ${name}, you\u0026#39;re doing GREAT!`; }; // This works fine encourageStudent(\u0026#39;you\u0026#39;); // Output: \u0026#34;Hey, you, you\u0026#39;re doing GREAT!\u0026#34; // This will cause a TypeScript error encourageStudent(85); // Error: Argument of type \u0026#39;number\u0026#39; is not assignable to parameter of type \u0026#39;string\u0026#39; The type annotation after each parameter (: string in the example) tells TypeScript what type of values the function expects. This helps us catch errors during development rather than at runtime.\nMultiple Parameters Functions can have multiple parameters, and each parameter can have its own type:\nfunction createUser(name: string, age: number, isActive: boolean) { return { name, age, isActive, }; } // Correct usage createUser(\u0026#39;John\u0026#39;, 25, true); // TypeScript will catch these errors createUser(\u0026#39;John\u0026#39;, \u0026#39;25\u0026#39;, true); // Error: age should be a number createUser(\u0026#39;John\u0026#39;); // Error: missing parameters createUser(\u0026#39;John\u0026#39;, 25, \u0026#39;yes\u0026#39;); // Error: isActive should be boolean In this example, TypeScript ensures that:\nAll required parameters are provided Each parameter is of the correct type Parameters are passed in the correct order Function Return Types TypeScript can also specify what type of value a function returns. While TypeScript can often infer the return type (called type inference), explicitly declaring it can make your code more maintainable and self-documenting:\nconst addNums = (x: number, y: number): number =\u0026gt; { return x + y; }; const concatenateStrings = (a: string, b: string): string =\u0026gt; { return a + \u0026#39; \u0026#39; + b; }; addNums(5, 5); // Returns: 10 concatenateStrings(\u0026#39;Hello\u0026#39;, \u0026#39;World\u0026#39;); // Returns: \u0026#34;Hello World\u0026#34; The : number and : string after the parameter lists indicate what type the functions must return. This helps in:\nProviding documentation about what the function returns Catching errors if you try to return the wrong type Letting other developers know what to expect from the function The void Return Type Sometimes functions don\u0026rsquo;t return any value, they just perform an action. In TypeScript, we use the void type to indicate this:\nconst warnUser = (message: string): void =\u0026gt; { alert(message); // No return statement needed }; const logData = (data: any): void =\u0026gt; { console.log(data); // We didn\u0026#39;t even write \u0026#39;return\u0026#39; }; // TypeScript will error if you try to use the return value const result = logData(\u0026#39;test\u0026#39;); // Error: Type \u0026#39;void\u0026#39; is not assignable... Using void is important because:\nIt tells other developers not to expect a return value TypeScript will error if you try to return a value It makes your APIs clearer and more predictable Optional Parameters and Default Values TypeScript provides two ways to make parameters flexible: optional parameters and default values.\nOptional Parameters Add a ? after the parameter name to make it optional:\nfunction greetPerson(name: string, title?: string) { if (title) { return `Hello ${title} ${name}`; } return `Hello ${name}`; } greetPerson(\u0026#39;John\u0026#39;); // Output: \u0026#34;Hello John\u0026#34; greetPerson(\u0026#39;John\u0026#39;, \u0026#39;Dr.\u0026#39;); // Output: \u0026#34;Hello Dr. John\u0026#34; Default Values Assign a value in the parameter declaration to set a default:\nfunction orderCoffee(type: string = \u0026#39;Americano\u0026#39;, size: string = \u0026#39;medium\u0026#39;, milk: boolean = false) { let order = `${size} ${type}`; if (milk) order += \u0026#39; with milk\u0026#39;; return order; } orderCoffee(); // \u0026#34;medium Americano\u0026#34; orderCoffee(\u0026#39;Latte\u0026#39;); // \u0026#34;medium Latte\u0026#34; orderCoffee(\u0026#39;Espresso\u0026#39;, \u0026#39;small\u0026#39;); // \u0026#34;small Espresso\u0026#34; orderCoffee(\u0026#39;Mocha\u0026#39;, \u0026#39;large\u0026#39;, true); // \u0026#34;large Mocha with milk\u0026#34; Key differences between optional parameters and default values:\nOptional Parameters (?)\nParameter becomes undefined if not provided Requires checks in the function body More flexible but requires more handling Default Values (= value)\nUses specified value if parameter is omitted No extra checks needed Less flexible but easier to use Important: Parameter Order When using both required and optional parameters, required parameters must come first:\n// CORRECT function correct(required: string, optional?: string) {} // WRONG - TypeScript will error function wrong(optional?: string, required: string) {} // Error! Anonymous Functions and Type Inference TypeScript is particularly good at inferring types in anonymous functions, especially in callbacks:\nconst numbers = [1, 2, 3, 4, 5]; // TypeScript automatically infers \u0026#39;number\u0026#39; type for \u0026#39;num\u0026#39; numbers.forEach((num) =\u0026gt; { console.log(num.toFixed(2)); // Works because TypeScript knows num is a number }); // Type inference in array methods const squares = numbers.map((num) =\u0026gt; num * num); // squares is inferred as number[] The never Type The never type is special in TypeScript and represents values that never occur. It has two main use cases:\nFunctions that never complete: function infiniteLoop(): never { while (true) { console.log(\u0026#34;I\u0026#39;m still going!\u0026#34;); } } function infiniteRecursion(): never { return infiniteRecursion(); } Functions that always throw errors: function throwError(message: string): never { throw new Error(message); } function validateUser(user: never): never { throw new Error(\u0026#39;Should never be called with a value\u0026#39;); } Don\u0026rsquo;t confuse never with void:\nvoid returns undefined or null (technically still a value) never means the function never completes execution Function Overloads TypeScript allows you to define multiple function signatures for different parameter types:\n// Overload signatures function combine(a: string, b: string): string; function combine(a: number, b: number): number; // Implementation function combine(a: string | number, b: string | number): string | number { if (typeof a === \u0026#39;string\u0026#39; \u0026amp;\u0026amp; typeof b === \u0026#39;string\u0026#39;) { return a.concat(b); } if (typeof a === \u0026#39;number\u0026#39; \u0026amp;\u0026amp; typeof b === \u0026#39;number\u0026#39;) { return a + b; } throw new Error(\u0026#39;Parameters must be of the same type!\u0026#39;); } console.log(combine(\u0026#39;Hello, \u0026#39;, \u0026#39;World\u0026#39;)); // \u0026#34;Hello, World\u0026#34; console.log(combine(5, 10)); // 15 // combine(\u0026#34;5\u0026#34;, 10); // Error! This combination isn\u0026#39;t defined Best Practices Always Type Parameters\n// BAD function bad(name) { return `Hello ${name}`; } // GOOD function good(name: string): string { return `Hello ${name}`; } Consider Return Types\n// Type inference is sometimes enough const add = (a: number, b: number) =\u0026gt; a + b; // But explicit return types are better for complex functions function processData(data: any[]): ProcessedData { // Complex operations... return processedResult; } Use Optional Parameters Wisely\nPut required parameters before optional ones Consider using default values instead of optional parameters when appropriate Document the behavior of optional parameters Avoid any Type\n// BAD function processAny(data: any) { return data.someMethod(); // Dangerous! } // GOOD function processTyped\u0026lt;T\u0026gt;(data: T) { // Type-safe operations } Quick Reference Here\u0026rsquo;s a quick reference of function types in TypeScript:\n// Basic function with parameter and return types function basic(param: string): number {} // Arrow function with type annotations const arrow = (x: number): string =\u0026gt; {}; // Optional parameter function optional(name: string, age?: number) {} // Default value function defaultValue(name: string = \u0026#39;Anonymous\u0026#39;) {} // Void return type function noReturn(): void {} // Never return type function neverReturns(): never {} // Function overloads function overloaded(x: string): string; function overloaded(x: number): number; Conclusion TypeScript\u0026rsquo;s function features provide powerful tools for writing safer and more maintainable code. Through type checking, we can catch errors early and make our code more self-documenting. While it might seem like extra work at first, the benefits become clear as your projects grow in size and complexity.\n",
    "tags": ["typescript","javascript","functions"],
    "categories": ["TypeScript"],
    "lang": "en"
} 