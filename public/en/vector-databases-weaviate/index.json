{
    "title": "Vector Databases and Weaviate: Building Semantic Search Applications",
    "permalink": "/blog/en/vector-databases-weaviate/",
    "summary": "This article explores vector databases with a focus on Weaviate, covering fundamental concepts, architecture, and implementation strategies. Learn how vector databases enable semantic search capabilities, their advantages over traditional databases, and how to build powerful search applications with Weaviate.",
    "content": "Vector Databases and Weaviate: Building Semantic Search Applications Introduction In the ever-evolving landscape of data storage and retrieval systems, vector databases have emerged as a revolutionary technology that bridges the gap between traditional databases and modern AI applications. Unlike conventional databases that excel at exact matches and structured queries, vector databases are designed to understand the meaning and context behind data, enabling similarity-based search capabilities that power next-generation applications.\nIn this article, we\u0026rsquo;ll explore:\nThe fundamental concepts behind vector databases and how they differ from traditional systems The architecture and key components of vector databases An in-depth look at Weaviate, one of the leading open-source vector database platforms How to implement powerful semantic search applications with Weaviate Best practices, optimization strategies, and real-world use cases Whether you\u0026rsquo;re new to vector databases or looking to enhance your existing knowledge, this guide will provide the theoretical foundation you need to understand and leverage this powerful technology.\n1. Understanding Vector Databases: The Fundamentals What Are Vector Databases? A vector database is a specialized database system designed to store, manage, and query high-dimensional vector representations of data. These vectors (also called embeddings) capture the semantic meaning of items such as text, images, audio, or any other data that can be represented in a numerical format.\nThe core idea behind vector databases is simple yet powerful: by converting data into vectors that preserve semantic relationships, we can perform similarity searches based on meaning rather than exact matches. This enables a wide range of applications that were previously difficult or impossible with traditional database systems.\nVector Embeddings: The Building Blocks At the heart of vector databases are embeddings—numerical representations of data in a high-dimensional space. Here\u0026rsquo;s how they work:\nEmbedding Generation: Data (such as text, images, or audio) is processed through an embedding model that converts it into a vector of floating-point numbers. Dimensional Representation: These vectors typically have hundreds or thousands of dimensions, with each dimension capturing some aspect of the data\u0026rsquo;s semantic properties. Semantic Proximity: Items with similar meanings or characteristics are positioned close to each other in this high-dimensional space. For example, in a text embedding space, the words \u0026ldquo;happy\u0026rdquo; and \u0026ldquo;joyful\u0026rdquo; would be positioned closer to each other than \u0026ldquo;happy\u0026rdquo; and \u0026ldquo;automobile\u0026rdquo; because they share more semantic similarity.\nVector Databases vs. Traditional Databases To appreciate the value of vector databases, it\u0026rsquo;s important to understand how they differ from traditional database systems:\nFeature Traditional Databases Vector Databases Data Storage Structured records, tables, documents Vector embeddings + metadata Query Type Exact matches, range queries, joins Similarity search, nearest neighbors Search Paradigm \u0026ldquo;Find exact records matching criteria\u0026rdquo; \u0026ldquo;Find similar items to this reference\u0026rdquo; Indexing B-trees, hash indexes, inverted indexes Approximate Nearest Neighbor (ANN) indexes Use Cases Transactional data, structured reporting Semantic search, recommendations, classification Query Complexity SQL, complex query languages Vector similarity + optional filtering The fundamental difference lies in the approach to understanding data: traditional databases treat data as literal values, while vector databases understand the semantic relationships between data points.\n2. The Architecture of Vector Databases Core Components of a Vector Database Modern vector databases consist of several key components working together:\nVector Storage Layer: Responsible for efficiently storing high-dimensional vector data Indexing Mechanism: Enables fast retrieval of similar vectors Metadata Storage: Stores additional information about each vector (original text, categories, timestamps, etc.) Query Processing Engine: Handles vector similarity searches and optional filtering API Layer: Provides interfaces for data insertion and querying These components work together to deliver the core functionality of storing and retrieving vectors based on similarity.\nApproximate Nearest Neighbor (ANN) Algorithms One of the biggest challenges in vector databases is efficiently finding similar vectors in high-dimensional spaces. Exact nearest-neighbor searches become computationally prohibitive as the dataset grows. This is where Approximate Nearest Neighbor (ANN) algorithms come in.\nPopular ANN algorithms used in vector databases include:\nHNSW (Hierarchical Navigable Small World): Creates a multi-layer graph structure for efficient navigation IVF (Inverted File Index): Partitions the vector space into clusters for faster search PQ (Product Quantization): Compresses vectors while preserving similarity relationships FAISS (Facebook AI Similarity Search): Combines multiple techniques for scalable similarity search These algorithms make tradeoffs between search accuracy and performance, typically allowing for sub-millisecond query times even with millions of vectors.\nVector Database Architecture Models Vector databases can be implemented with different architectural approaches:\nStandalone Vector Databases: Purpose-built systems designed exclusively for vector storage and retrieval (e.g., Weaviate, Pinecone) Vector Extensions to Traditional Databases: Adding vector capabilities to existing database systems (e.g., PostgreSQL with pgvector) Hybrid Architectures: Combining vector search with traditional search capabilities Each approach has its advantages, with standalone vector databases typically offering the best performance for pure vector-based workloads.\n3. Weaviate: An Open-Source Vector Database What is Weaviate? Weaviate is a powerful open-source vector database that combines the capabilities of a vector search engine with the features of a traditional database system. It\u0026rsquo;s designed to provide semantic search capabilities with the reliability and scalability expected in production environments.\nKey features of Weaviate include:\nGraphQL API: Intuitive interface for queries and mutations RESTful API: Alternative interface for standard HTTP operations Hybrid Search: Combining vector search with keyword-based retrieval Modular Architecture: Pluggable vectorizer modules for different embedding models Schema Definition: Flexible data modeling capabilities Cross-References: Ability to link objects within the database Classification Capabilities: Built-in machine learning for data classification Weaviate Architecture Weaviate\u0026rsquo;s architecture consists of several core components:\nVector Index: The HNSW-based vector index for similarity search Object Store: Storage for both vector data and associated metadata GraphQL Interface: The primary API for interacting with Weaviate Vectorization Modules: Pluggable components for generating embeddings Query Planner: Optimizes and executes search queries This architecture allows Weaviate to deliver high-performance vector search while maintaining a user-friendly interface.\nData Modeling in Weaviate Weaviate uses a flexible schema-based approach to data modeling. Each data object in Weaviate:\nBelongs to a class (similar to a table in relational databases) Has properties (attributes that describe the object) Has an associated vector embedding (automatically generated or imported) Can have cross-references to other objects A simple Weaviate schema for a collection of articles might look like this:\n{ \u0026#34;classes\u0026#34;: [ { \u0026#34;class\u0026#34;: \u0026#34;Article\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;A news or blog article\u0026#34;, \u0026#34;properties\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;title\u0026#34;, \u0026#34;dataType\u0026#34;: [\u0026#34;text\u0026#34;], \u0026#34;description\u0026#34;: \u0026#34;The title of the article\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;content\u0026#34;, \u0026#34;dataType\u0026#34;: [\u0026#34;text\u0026#34;], \u0026#34;description\u0026#34;: \u0026#34;The main content of the article\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;publishedDate\u0026#34;, \u0026#34;dataType\u0026#34;: [\u0026#34;date\u0026#34;], \u0026#34;description\u0026#34;: \u0026#34;When the article was published\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;author\u0026#34;, \u0026#34;dataType\u0026#34;: [\u0026#34;Author\u0026#34;], \u0026#34;description\u0026#34;: \u0026#34;The author of the article\u0026#34; } ] }, { \u0026#34;class\u0026#34;: \u0026#34;Author\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;A person who writes articles\u0026#34;, \u0026#34;properties\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;name\u0026#34;, \u0026#34;dataType\u0026#34;: [\u0026#34;text\u0026#34;], \u0026#34;description\u0026#34;: \u0026#34;The author\u0026#39;s full name\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;biography\u0026#34;, \u0026#34;dataType\u0026#34;: [\u0026#34;text\u0026#34;], \u0026#34;description\u0026#34;: \u0026#34;The author\u0026#39;s biographical information\u0026#34; } ] } ] } This schema-based approach makes Weaviate approachable for developers familiar with traditional database systems.\n4. Key Capabilities of Vector Databases Semantic Search The most prominent capability of vector databases is semantic search—finding results based on meaning rather than keywords. This includes:\nConceptual Matching: Finding results that match the concept of a query, even if they use different terminology Contextual Understanding: Recognizing the intent behind queries and matching accordingly Multilingual Support: Finding relevant content across different languages based on semantic similarity Semantic search significantly improves search quality over traditional keyword-based approaches, especially for complex or nuanced queries.\nHybrid Search While vector search excels at capturing semantic relationships, it may miss exact keyword matches that are relevant. Hybrid search combines the best of both worlds:\nVector Search: Captures semantic similarity and conceptual matching Keyword Search: Ensures exact term matches are not missed Fusion Methods: Intelligently combines results from both approaches Hybrid search typically delivers better overall search quality than either approach alone, especially for general-purpose search applications.\nMultimodal Search Advanced vector databases support multimodal search—the ability to search across different types of media using a single query:\nCross-Modal Search: Using one modality to search another (e.g., text-to-image search) Unified Embeddings: Representing different data types in a shared vector space Multimodal Queries: Combining multiple modalities in a single query This capability enables powerful applications such as searching for images using text descriptions, or finding text content related to an image.\nClassification and Recommendation Beyond search, vector databases enable other important capabilities:\nAutomatic Classification: Categorizing new items based on similarity to existing categorized items Recommendation Systems: Suggesting related items based on vector similarity Anomaly Detection: Identifying outliers in vector space These capabilities make vector databases valuable not just for search applications, but for a wide range of AI-enhanced systems.\n5. Advantages of Vector Databases Enhanced Search Quality Vector databases offer significant improvements in search quality:\nUnderstanding Intent: Capturing the meaning behind queries rather than just matching keywords Handling Synonyms: Recognizing different terms with the same meaning Concept Matching: Finding results related to the same concept even with different terminology Context Sensitivity: Understanding the nuance and context of queries These improvements translate to better user experiences and more effective information retrieval.\nScalability and Performance Modern vector databases are designed for production-grade performance:\nSub-Second Query Times: Even with millions of vectors Horizontal Scaling: Distributing workloads across multiple nodes Efficient Storage: Optimized for high-dimensional vector data Low Latency: For real-time applications This scalability makes vector databases suitable for everything from small applications to enterprise-scale deployments.\nIntegration with AI Workflows Vector databases fit seamlessly into modern AI workflows:\nLLM Integration: Enhancing large language models with retrieval capabilities Embedding Pipeline Integration: Working directly with embedding models Data Processing Support: Handling continuous updates and new data API-First Design: Easy integration with existing systems This integration potential makes vector databases a key component in the AI infrastructure stack.\n6. Common Use Cases for Vector Databases Semantic Document Search Vector databases excel at finding relevant documents based on meaning:\nEnterprise Knowledge Bases: Helping employees find relevant information Legal Document Search: Finding case law and precedents based on concepts Research Databases: Discovering relevant papers across different terminology Content Management: Organizing and retrieving content based on themes Recommendation Systems Vector similarity powers effective recommendation systems:\nProduct Recommendations: \u0026ldquo;Customers who viewed this also viewed\u0026hellip;\u0026rdquo; Content Discovery: Finding articles, videos, or music with similar themes Person Matching: Dating apps, professional networking, team formation Educational Resources: Suggesting learning materials on similar topics Image and Media Search Beyond text, vector databases handle multimedia content effectively:\nReverse Image Search: Finding similar images to a reference Content-Based Media Retrieval: Finding videos or audio with similar content Digital Asset Management: Organizing and retrieving media based on content Visual Product Search: Finding products that look similar to a reference RAG (Retrieval Augmented Generation) Vector databases are a key component in RAG systems:\nQuery-Based Document Retrieval: Finding relevant documents for an LLM Knowledge Grounding: Providing factual information to ground LLM responses Domain Adaptation: Allowing general LLMs to access domain-specific knowledge Fact Verification: Retrieving information to verify LLM-generated content 7. Implementing Weaviate in Applications Setting Up a Weaviate Server The first step in working with Weaviate is setting up a server. This can be done in several ways:\nUsing Docker (most common method) Cloud-hosted options Building from source In the implementation section, I\u0026rsquo;ll provide code examples for setting up a Weaviate server using Docker.\nDefining Your Data Schema Before importing data, you need to define your schema. This involves:\nDefining classes (collections of similar objects) Specifying properties for each class Setting up cross-references between classes Configuring vectorizer modules The implementation section will include code for defining and creating a schema in Weaviate.\nImporting Data into Weaviate Once your schema is defined, you can import data. This typically involves:\nPreparing your data in the correct format Batching data for efficient imports Handling errors and validation Monitoring the import process I\u0026rsquo;ll provide code examples for efficient data importing in the implementation section.\nImplementing Hybrid Search Hybrid search combines vector search with traditional keyword search. Implementation involves:\nConfiguring both search types Setting appropriate weights for each Tuning parameters for optimal results Handling and processing results The implementation code will demonstrate how to set up and execute hybrid search queries.\n8. Best Practices and Optimization Strategies Schema Design Best Practices Effective schema design is crucial for Weaviate performance:\nAppropriate Property Types: Using the right data types for each property Vectorization Configuration: Choosing the right vectorizer for your data Cross-Reference Planning: Designing efficient object relationships Indexing Strategy: Configuring HNSW parameters for your use case Data Import Optimization Efficient data importing ensures faster time-to-value:\nBatch Processing: Grouping objects for more efficient imports Parallel Processing: Utilizing multiple threads for faster imports Incremental Updates: Strategies for updating existing data Error Handling: Gracefully managing import failures Query Optimization Techniques Optimizing queries improves both performance and result quality:\nVector Search Parameters: Tuning distance metrics and k values Hybrid Search Configuration: Balancing vector and keyword components Filter Optimization: Efficient use of metadata filters Result Processing: Handling and transforming search results Scaling and Production Considerations For production deployments, consider these best practices:\nResource Allocation: CPU, memory, and storage requirements Backup Strategies: Ensuring data durability Monitoring and Logging: Tracking performance and errors High Availability: Configuring for redundancy and failover 9. Challenges and Limitations Vector Database Challenges While powerful, vector databases come with certain challenges:\nCold Start Problem: Initial setup without existing embeddings Embedding Drift: Changes in embedding models over time Explainability: Understanding why certain results are returned Resource Intensity: Higher computational requirements than traditional databases Addressing Common Pitfalls To avoid common issues with vector databases:\nTest Search Quality: Regularly evaluate search results with real queries Monitor Performance: Track query times and resource utilization Update Embeddings: Regenerate embeddings when models change Tune Incrementally: Make small changes and measure impact Implementation: Development with Weaviate Following the steps at https://weaviate.io/developers/weaviate/quickstart, we create an endpoint and API key for ourselves.\nWe start a project locally or from a GitHub repository and run the following commands in sequence.\nnpm init -y npm install axios openai weaviate-client After creating our project and installing the necessary components, we use the following script to convert sample data from https://dummyjson.com/products into embeddings.\nimport axios from \u0026#39;axios\u0026#39;; import { writeFileSync } from \u0026#39;fs\u0026#39;; import { OpenAI } from \u0026#39;openai\u0026#39;; import fs from \u0026#39;fs\u0026#39;; // Initialize OpenAI API client const openai = new OpenAI({ apiKey: \u0026#39;\u0026#39;, // Add your OpenAI API key here }); /** * Converts product title to URL-friendly format * @param {string} title - Product title * @returns {string} - Formatted URI string */ function formatProductUri(title) { if (!title) return \u0026#39;\u0026#39;; return title.toLowerCase().replace(/\\s+/g, \u0026#39;-\u0026#39;); } /** * Processes product data and generates embeddings * @param {Object} product - Raw product data * @returns {Object} - Formatted product with vector embedding */ async function formatProductData(product) { try { // Combine product data as string for embedding const productString = JSON.stringify(product); // Generate embedding using OpenAI const embeddingResponse = await openai.embeddings.create({ model: \u0026#39;text-embedding-ada-002\u0026#39;, input: productString, }); const embedding = embeddingResponse.data[0].embedding; // Return product in the required format return { data: product, id: formatProductUri(product?.title) + \u0026#39;-\u0026#39; + product?.id, vectorContent: embedding, }; } catch (error) { console.error(`Error processing product: ${product.title}`, error); throw error; } } /** * Main function to fetch products from API and process them * Generates vector embeddings for each product */ async function fetchAndProcessProducts() { try { console.log(\u0026#39;Fetching products...\u0026#39;); const response = await axios.get(\u0026#39;https://dummyjson.com/products?limit=200\u0026#39;); const products = response.data.products; fs.writeFileSync(\u0026#39;products.json\u0026#39;, JSON.stringify(products, null, 2)); console.log(`Fetched ${products.length} products. Processing...`); // Process all products const processedProducts = []; let index = 0; // Process each product sequentially to avoid rate limits for (const product of products) { index++; console.log(`Processing product ${index}/${products.length}: ${product.title}`); try { const formattedProduct = await formatProductData(product); processedProducts.push(formattedProduct); // Add delay every 10 products to avoid OpenAI rate limits if (index % 10 === 0) { console.log(\u0026#39;Waiting 1 second for rate limit...\u0026#39;); await new Promise((resolve) =\u0026gt; setTimeout(resolve, 1000)); } } catch (error) { console.error(`Error processing product: ${product.title}`, error); // Continue despite errors continue; } } // Save results to JSON file writeFileSync(\u0026#39;processed_products.json\u0026#39;, JSON.stringify(processedProducts, null, 2)); console.log(\u0026#34;Processing complete. Results saved to \u0026#39;processed_products.json\u0026#39;\u0026#34;); } catch (error) { console.error(\u0026#39;Error occurred:\u0026#39;, error); } } // Start the process fetchAndProcessProducts(); This script will give us a JSON file named \u0026lsquo;processed_products.json\u0026rsquo; that contains both the data itself and its embedded version. Later, we import this data into the Weaviate cloud environment using the script below. Unlike what was explained above, I\u0026rsquo;m not using the schema approach here as I\u0026rsquo;m trying to explain the concept and help you understand the logic behind it.\n/** * Import script for loading product data into Weaviate vector database * This script reads product data from a JSON file and imports it into a Weaviate collection */ import weaviate, { generateUuid5 } from \u0026#39;weaviate-client\u0026#39;; import { readFileSync } from \u0026#39;fs\u0026#39;; // Load product data from JSON file const products = JSON.parse(readFileSync(\u0026#39;./processed_products.json\u0026#39;, \u0026#39;utf8\u0026#39;)); // Weaviate cloud service connection details const WCD_URL = \u0026#39;\u0026#39;; // Add your WCD URL here const WCD_API_KEY = \u0026#39;\u0026#39;; // Add your WCD API key here const wcdUrl = WCD_URL; const wcdApiKey = WCD_API_KEY; // Validate connection details are available if (!wcdUrl || !wcdApiKey) { throw new Error(\u0026#39;Missing required environment variables WCD_URL or WCD_API_KEY\u0026#39;); } // Initialize Weaviate client const client = await weaviate.connectToWeaviateCloud(wcdUrl, { authCredentials: new weaviate.ApiKey(wcdApiKey), }); /** * Main function to import product data into Weaviate */ async function main() { try { console.log(\u0026#39;Starting data import to Weaviate...\u0026#39;); console.log(\u0026#39;products recieved\u0026#39;, products.length); // Transform product data into Weaviate objects const dataObjects = products.map((item) =\u0026gt; ({ properties: { data: JSON.stringify(item.data), }, // Generate a deterministic UUID based on collection name and item ID id: generateUuid5(\u0026#39;Ecommerce\u0026#39;, item.id), // Use vector if available, otherwise let Weaviate generate it vector: Array.isArray(item.vectorContent) ? item.vectorContent : undefined, })); console.log(\u0026#39;dataObjects received\u0026#39;, dataObjects.length); // Get reference to the Ecommerce collection const collection = await client.collections.get(\u0026#39;Ecommerce\u0026#39;); // Insert all objects in a batch operation const result = await collection.data.insertMany(dataObjects); console.log(\u0026#39;Insertion response: \u0026#39;, result); console.log(\u0026#39;Data import completed\u0026#39;); } catch (error) { console.error(\u0026#39;Error:\u0026#39;, error); } } // Run the main function main().catch(console.error); With this script, we upload the created JSON file to the Weaviate system. There are two important aspects here:\nIf your data contains its own ID value, you can specify it separately in the properties section or define it with a different property name because Weaviate has its own Id parameter which must be in UUID format, so we cannot use the data\u0026rsquo;s id field directly there. However, we can use Weaviate\u0026rsquo;s own UUID generator as shown in the example. The other field is the collection name. This actually represents the class name. This collection name is used in all operations such as searching, deleting data, etc. After importing our data, we move on to searching the data. Above, I mentioned various search types both specific to Weaviate and vector databases in general. In the script below, I used Weaviate\u0026rsquo;s GraphQL feature and hybrid search capability.\n// Import required libraries // axios for making HTTP requests import axios from \u0026#39;axios\u0026#39;; // OpenAI SDK for generating embeddings import OpenAI from \u0026#39;openai\u0026#39;; // Initialize OpenAI client with API key const openai = new OpenAI({ apiKey: \u0026#39;\u0026#39;, //Add your openAI API key }); // Array of questions to process const questions = [\u0026#39;do you have macbook?\u0026#39;]; /** * Generate an embedding vector for the given text using OpenAI\u0026#39;s API * @param {string} text - The text to generate an embedding for * @returns {Promise\u0026lt;Array\u0026lt;number\u0026gt;\u0026gt;} The embedding vector */ async function getEmbedding(text) { const response = await openai.embeddings.create({ model: \u0026#39;text-embedding-ada-002\u0026#39;, input: text, }); return response.data[0].embedding; } /** * Search Weaviate database using hybrid search (text + vector) * @param {string} question - The question to search for * @param {Array\u0026lt;number\u0026gt;} vector - The embedding vector of the question * @returns {Promise\u0026lt;Object\u0026gt;} Search results and metadata */ async function searchWeaviate(question, vector) { // Track response time const startTime = Date.now(); // Prepare GraphQL query for Weaviate const data = JSON.stringify({ query: `{ Get { Ecommerce ( hybrid: { query: \u0026#34;${question}\u0026#34; alpha: 0.5, vector: ${JSON.stringify(vector)} } limit: 3 ) { data _additional { score } } } }`, }); // Configure request parameters const config = { method: \u0026#39;post\u0026#39;, url: \u0026#39;https://ltwfnj0szusp5t1natqdw.c0.us-west3.gcp.weaviate.cloud/v1/graphql\u0026#39;, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;, Authorization: \u0026#39;Bearer AUV3GwGDrHKwVCJpFFxKc6ppUl7xXF54uQAM\u0026#39;, }, data: data, }; try { // Execute the request const response = await axios.request(config); const endTime = Date.now(); // Format and return results return { question: question, results: response.data.data.Get.Ecommerce.map((item) =\u0026gt; item.data), responseTime: `${endTime - startTime}ms`, }; } catch (error) { // Handle errors console.error(`Error for question \u0026#34;${question}\u0026#34;:`, error); return { question: question, error: error.message, responseTime: null, }; } } /** * Main function to process all questions */ async function main() { for (const question of questions) { try { // Generate embedding for the question const embedding = await getEmbedding(question); // Search Weaviate using the question and its embedding const result = await searchWeaviate(question, embedding); // Output results console.log(\u0026#39;\\n-------------------\u0026#39;); console.log(\u0026#39;Question:\u0026#39;, result.question); console.log(\u0026#39;Products:\u0026#39;, result.results); console.log(\u0026#39;Response Time:\u0026#39;, result.responseTime); } catch (error) { console.error(`Failed to process question \u0026#34;${question}\u0026#34;:`, error); } } } // Execute the main function main(); This script takes the question(s) in the questions array and sequentially searches for them on Weaviate servers. While doing this, it uses\nconst data = JSON.stringify({ query: `{ Get { Ecommerce ( hybrid: { query: \u0026#34;${question}\u0026#34; alpha: 0.5, vector: ${JSON.stringify(vector)} } limit: 3 ) { data _additional { score } } } }`, }); This part uses Weaviate\u0026rsquo;s hybrid search feature. In the query section, the direct question itself is included. In the vector section, the question\u0026rsquo;s embedded version is used. This way, it performs a hybrid search using both text and vector. The alpha parameter determines the weight of the search. As it increases, the weight of vector search increases, and as it decreases, the weight of keyword search increases. In the limit section, we specify the number of returned data items. In the data section, we specify the property name we want to be returned. The score section shows the scores determined for search results.\nConclusion Vector databases like Weaviate represent a significant advancement in how we store, retrieve, and understand data. By capturing semantic relationships and enabling similarity-based search, they unlock new capabilities that were previously impractical with traditional database systems.\nAs AI continues to transform software development, vector databases will play an increasingly central role in connecting language models, search systems, and user interfaces. Understanding their capabilities, architecture, and implementation strategies is becoming an essential skill for developers working with AI-enhanced applications.\n",
    "tags": ["vectordb","weaviate","semantic-search","embeddings"],
    "categories": ["AI"],
    "lang": "en"
} 