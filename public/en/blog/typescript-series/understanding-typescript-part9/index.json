{
    "title": "Understanding TypeScript - Part 9: Sample Project",
    "permalink": "/en/blog/typescript-series/understanding-typescript-part9/",
    "summary": "In this article, we will explore the process of developing a Todo application using TypeScript and Node.js with JWT and Google OAuth authentication. We will discuss the experience of designing a modern REST API by implementing TypeScript\u0026rsquo;s type safety, MongoDB integration, and clean architecture principles.",
    "content": "Developing a Node.js Authentication API with TypeScript: Comprehensive Guide Introduction Type safety and code quality are becoming increasingly important when developing modern web applications. In this tutorial, we will learn TypeScript\u0026rsquo;s powerful features through a real project. While developing a Todo application with JWT and Google OAuth authentication, we will implement TypeScript\u0026rsquo;s core concepts and best practices. You can access the complete project at this GitHub repository.\nThis project will provide you with:\nPractice in writing secure code with TypeScript Experience in designing a modern REST API Authentication and Authorization implementation Using TypeScript with MongoDB Applying Clean Architecture principles TypeScript Features and Project Structure We\u0026rsquo;ll develop a secure and scalable API using TypeScript\u0026rsquo;s core features. Let\u0026rsquo;s explain each feature with examples from our actual project code:\n1. TypeScript Basics (Basics) TypeScript\u0026rsquo;s basic building blocks are used in our project like this:\n// src/config/env.ts\u0026#39;de Tip Tanımlamaları const PORT: number = Number(process.env.PORT) || 3000; const JWT_EXPIRES_IN: string = \u0026#39;1d\u0026#39;; // src/middleware/auth.middleware.ts\u0026#39;de Type Assertion const decoded = jwt.verify(token, JWT_SECRET) as IJwtPayload; // Burada JWT\u0026#39;den gelen veriyi IJwtPayload tipine dönüştürüyoruz // src/interfaces/user.interface.ts\u0026#39;de Literal Types type UserRole = \u0026#39;user\u0026#39; | \u0026#39;admin\u0026#39;; // User modelinde kullanıcı rollerini sadece bu iki değerle sınırlıyoruz Projedeki Kullanım Örnekleri:\nPORT tanımı src/index.ts\u0026lsquo;de server başlatırken kullanılıyor Type assertion auth.middleware.ts\u0026lsquo;de JWT doğrulamasında kullanılıyor UserRole tipi IUser interface\u0026rsquo;inde kullanıcı rolünü kısıtlamak için kullanılıyor 2. Functions TypeScript\u0026rsquo;te functions are typed like this:\n// src/services/auth.service.ts\u0026#39;de Method Signatures interface IAuthService { login(credentials: IUserLogin): Promise\u0026lt;{ user: IUser; token: string }\u0026gt;; register(userData: IUserRegistration): Promise\u0026lt;IUser\u0026gt;; } // src/controllers/auth.controller.ts\u0026#39;de Implementation public async login(req: Request, res: Response): Promise\u0026lt;void\u0026gt; { const { email, password } = req.body; const result = await this.authService.login({ email, password }); // ... } Projedeki Kullanım Örnekleri:\nIAuthService interface\u0026rsquo;i auth.service.ts\u0026lsquo;de servis implementasyonunu tanımlıyor Controller\u0026rsquo;lardaki tüm handler functions use Request and Response types All async functions are typed with Promise return type 3. Object Types We model complex data structures with object types in our project:\n// src/config/database.ts\u0026#39;de Configuration Types type DatabaseConfig = { uri: string; options: { useNewUrlParser: boolean; useUnifiedTopology: boolean; }; }; // src/controllers/todo.controller.ts\u0026#39;de Request Types interface ITodoCreate { title: string; description?: string; // Optional property example } Projedeki Kullanım Örnekleri:\nDatabaseConfig type defines MongoDB connection settings ITodoCreate interface is used for request body validation in todo creation endpoint Optional properties allow partial updates in todo updates 4. Interfaces Interfaces are used in our project both for type definition and for contracts:\n// src/interfaces/base.interface.ts\u0026#39;de Base Interface interface IBaseEntity { _id: string; createdAt: Date; updatedAt: Date; } // src/interfaces/user.interface.ts\u0026#39;de Interface Extension interface IUser extends IBaseEntity { email: string; password?: string; name: string; role: UserRole; } Projedeki Kullanım Örnekleri:\nIBaseEntity defines common fields for all MongoDB models IUser interface defines User model schema and methods Interfaces ensure type safety in mongoose model definitions 5. TypeScript Compiler We configure TypeScript compiler specifically for our project:\n{ \u0026#34;compilerOptions\u0026#34;: { \u0026#34;target\u0026#34;: \u0026#34;es2016\u0026#34;, \u0026#34;module\u0026#34;: \u0026#34;commonjs\u0026#34;, \u0026#34;strict\u0026#34;: true, \u0026#34;esModuleInterop\u0026#34;: true, \u0026#34;skipLibCheck\u0026#34;: true, \u0026#34;forceConsistentCasingInFileNames\u0026#34;: true, \u0026#34;outDir\u0026#34;: \u0026#34;./dist\u0026#34;, \u0026#34;rootDir\u0026#34;: \u0026#34;./src\u0026#34; } } Compiler Settings\u0026rsquo;s Importance:\nstrict: Enables strict type checking target: Allows us to use modern JavaScript features module: Uses Node.js compatible module system 6. Classes We implement OOP principles with TypeScript classes:\n// src/services/base.service.ts\u0026#39;de Abstract Base Class abstract class BaseService\u0026lt;T extends IBaseEntity\u0026gt; { constructor(protected model: Model\u0026lt;T\u0026gt;) {} abstract create(data: Partial\u0026lt;T\u0026gt;): Promise\u0026lt;T\u0026gt;; async findById(id: string): Promise\u0026lt;T | null\u0026gt; { return this.model.findById(id); } } // src/services/todo.service.ts\u0026#39;de Class Implementation class TodoService extends BaseService\u0026lt;ITodo\u0026gt; { async create(data: ICreateTodo): Promise\u0026lt;ITodo\u0026gt; { return this.model.create(data); } async markAsCompleted(id: string): Promise\u0026lt;ITodo | null\u0026gt; { return this.model.findByIdAndUpdate(id, { completed: true }); } } Why This Feature?\nAbstract classes enforce common behaviors Inheritance reduces code repetition Organizes service layer Projedeki Kullanım Örnekleri:\nBaseService defines basic CRUD operations for all services TodoService and AuthService extend this base class to add their own specific methods Abstract methods ensure each service must implement its own create method 7. Generics We use generics in our project like this:\n// src/services/base.service.ts\u0026#39;de Generic Service class CrudService\u0026lt;T extends IBaseEntity\u0026gt; { async findOne(filter: FilterQuery\u0026lt;T\u0026gt;): Promise\u0026lt;T | null\u0026gt; { return this.model.findOne(filter); } } // src/utils/response.ts\u0026#39;de Generic Response Handler function createResponse\u0026lt;T\u0026gt;(success: boolean, message: string, data?: T): IApiResponse\u0026lt;T\u0026gt; { return { success, message, data }; } // src/utils/error.ts\u0026#39;de Generic Error Handler class ApiError\u0026lt;T = unknown\u0026gt; extends Error { constructor(public statusCode: number, message: string, public data?: T) { super(message); } } Why This Feature?\nKeeps type safety while writing reusable code Creates functions that work with different data types Creates flexible structures with type parameters Projedeki Kullanım Örnekleri:\nCrudService works with different model types (User, Todo, etc.) createResponse creates consistent API responses for all data structures ApiError provides customizable error handling for different error types 8. Type Narrowing We safely perform runtime type checking and narrowing in TypeScript:\n// src/utils/error.ts\u0026#39;de Type Guards function isError(error: unknown): error is Error { return error instanceof Error; } // src/middleware/error.middleware.ts\u0026#39;de Error Handling function handleError(error: unknown): IApiResponse\u0026lt;null\u0026gt; { if (isError(error)) { return createResponse(false, error.message); } if (typeof error === \u0026#39;string\u0026#39;) { return createResponse(false, error); } return createResponse(false, \u0026#39;Unknown error occurred\u0026#39;); } // src/types/error.types.ts\u0026#39;de Discriminated Unions type ValidationError = { type: \u0026#39;validation\u0026#39;; fields: { [key: string]: string }; }; type AuthError = { type: \u0026#39;auth\u0026#39;; message: string; }; type AppError = ValidationError | AuthError; // src/utils/error-handler.ts\u0026#39;de Error Type Handling function handleAppError(error: AppError) { switch (error.type) { case \u0026#39;validation\u0026#39;: return error.fields; case \u0026#39;auth\u0026#39;: return error.message; } } Why This Feature?\nKeeps runtime type safety Improves error handling Works with Union types correctly Projedeki Kullanım Örnekleri:\nisError type guard in middleware detects error type correctly Error handling middleware distinguishes different error types Discriminated unions allow handling validation and auth errors separately Project Summary Our API will include the following features:\nUser Management\nRegistration and Login JWT Authentication Google OAuth Integration Role-based authorization Todo Operations\nCreate, read, update, delete todos User-specific todos Todo status changes Security and Validation\nInput validation Route protection Error handling Project Structure Our project is organized as follows:\nsrc/ ├── config/ # Configuration files ├── controllers/ # HTTP request handlers ├── interfaces/ # TypeScript interfaces ├── middleware/ # Express middleware ├── models/ # Mongoose models ├── routes/ # API routes ├── services/ # Business logic ├── utils/ # Helper functions └── index.ts # Application entry point Developing the Project with TypeScript 1. Project Setup and TypeScript Configuration First step is to integrate TypeScript into our project:\nmkdir nodejs-typescript-auth cd nodejs-typescript-auth npm init -y npm install typescript ts-node @types/node --save-dev Dependencies Let\u0026rsquo;s install necessary packages for our project:\n# Main dependencies npm install express mongoose dotenv jsonwebtoken bcrypt passport passport-google-oauth20 passport-jwt cors # Type definitions npm install @types/express @types/mongoose @types/jsonwebtoken @types/bcrypt @types/passport @types/passport-google-oauth20 @types/passport-jwt @types/cors --save-dev TypeScript Configuration { \u0026#34;compilerOptions\u0026#34;: { \u0026#34;target\u0026#34;: \u0026#34;es2016\u0026#34;, \u0026#34;module\u0026#34;: \u0026#34;commonjs\u0026#34;, \u0026#34;outDir\u0026#34;: \u0026#34;./dist\u0026#34;, \u0026#34;rootDir\u0026#34;: \u0026#34;./src\u0026#34;, \u0026#34;strict\u0026#34;: true, \u0026#34;esModuleInterop\u0026#34;: true, \u0026#34;skipLibCheck\u0026#34;: true, \u0026#34;forceConsistentCasingInFileNames\u0026#34;: true } } 2. Defining Data Models User Model Let\u0026rsquo;s define our User model with TypeScript interfaces:\n// src/interfaces/user.interface.ts // Base interface - basic user properties interface IBaseUser { email: string; name: string; } // Main user interface - includes all properties interface IUser extends IBaseUser { password?: string; // Optional: Google OAuth users may not have a password googleId?: string; // Optional: Only for users who sign in with Google role: \u0026#39;user\u0026#39; | \u0026#39;admin\u0026#39;; // Union type to limit roles comparePassword(candidatePassword: string): Promise\u0026lt;boolean\u0026gt;; } // Required fields for registration interface IUserRegistration { email: string; password: string; name: string; } // Required fields for login interface IUserLogin { email: string; password: string; } Todo Model Let\u0026rsquo;s define the interfaces needed for todo operations:\n// src/interfaces/todo.interface.ts interface ITodo { title: string; description?: string; completed: boolean; user: string; // Reference: User ID createdAt: Date; updatedAt: Date; } // Required fields for todo creation interface ICreateTodo { title: string; description?: string; } // Optional fields for todo updates interface IUpdateTodo { title?: string; description?: string; completed?: boolean; } 3. Service Layer Implementation Base Service Let\u0026rsquo;s create a generic base service to reduce code repetition:\n// src/services/base.service.ts abstract class BaseService\u0026lt;T\u0026gt; { constructor(protected model: Model\u0026lt;T\u0026gt;) {} async findById(id: string): Promise\u0026lt;T | null\u0026gt; { return this.model.findById(id); } async findOne(filter: FilterQuery\u0026lt;T\u0026gt;): Promise\u0026lt;T | null\u0026gt; { return this.model.findOne(filter); } async find(filter: FilterQuery\u0026lt;T\u0026gt;): Promise\u0026lt;T[]\u0026gt; { return this.model.find(filter); } } Auth Service Service to handle authentication operations:\n// src/services/auth.service.ts class AuthService extends BaseService\u0026lt;IUser\u0026gt; { public async register(userData: IUserRegistration): Promise\u0026lt;IUser\u0026gt; { const existingUser = await this.findOne({ email: userData.email }); if (existingUser) { throw new Error(\u0026#39;This email is already in use\u0026#39;); } const user = await this.model.create(userData); return user; } public async login(loginData: IUserLogin): Promise\u0026lt;{ user: IUser; token: string }\u0026gt; { const user = await this.findOne({ email: loginData.email }); if (!user || !(await user.comparePassword(loginData.password))) { throw new Error(\u0026#39;Invalid credentials\u0026#39;); } return { user, token: this.generateToken(user), }; } private generateToken(user: IUser): string { return jwt.sign({ id: user._id, email: user.email, role: user.role }, process.env.JWT_SECRET!, { expiresIn: \u0026#39;1d\u0026#39; }); } } Todo Service Service to handle todo operations:\n// src/services/todo.service.ts class TodoService extends BaseService\u0026lt;ITodo\u0026gt; { public async getAllTodos(userId: string): Promise\u0026lt;ITodo[]\u0026gt; { return this.find({ user: userId }); } public async createTodo(todoData: ICreateTodo, userId: string): Promise\u0026lt;ITodo\u0026gt; { return this.model.create({ ...todoData, user: userId, completed: false, }); } public async updateTodo(todoId: string, todoData: Partial\u0026lt;ITodo\u0026gt;, userId: string): Promise\u0026lt;ITodo | null\u0026gt; { return this.model.findOneAndUpdate({ _id: todoId, user: userId }, todoData, { new: true }); } } 4. Middleware Implementation TypeScript\u0026rsquo;s safe middleware writing:\n// src/middleware/auth.middleware.ts // Request type extension declare global { namespace Express { interface Request { user?: IUser; } } } export const isAuthenticated = async (req: Request, res: Response, next: NextFunction): Promise\u0026lt;void\u0026gt; =\u0026gt; { try { const token = req.headers.authorization?.split(\u0026#39; \u0026#39;)[1]; if (!token) { throw new Error(\u0026#39;Token not found\u0026#39;); } const decoded = jwt.verify(token, process.env.JWT_SECRET!) as IJwtPayload; const user = await UserModel.findById(decoded.id); if (!user) { throw new Error(\u0026#39;User not found\u0026#39;); } req.user = user; next(); } catch (error) { res.status(401).json({ success: false, message: \u0026#39;Authorization error\u0026#39;, error: error instanceof Error ? error.message : \u0026#39;Unknown error\u0026#39;, }); } }; 5. Controller Layer TypeScript\u0026rsquo;s safe controller:\n// src/controllers/todo.controller.ts class TodoController { constructor(private todoService: TodoService) {} public async getAllTodos(req: Request, res: Response): Promise\u0026lt;void\u0026gt; { try { const todos = await this.todoService.getAllTodos(req.user!._id); res.status(200).json({ success: true, message: \u0026#39;Todos fetched successfully\u0026#39;, data: todos, }); } catch (error) { res.status(500).json({ success: false, message: \u0026#39;Error fetching todos\u0026#39;, error: error instanceof Error ? error.message : \u0026#39;Unknown error\u0026#39;, }); } } } API Endpoints Auth Endpoints POST /api/auth/register - Request Body: { email: string, password: string, name: string } - Response: { success: boolean, message: string, data: { user: IUser, token: string } } POST /api/auth/login - Request Body: { email: string, password: string } - Response: { success: boolean, message: string, data: { user: IUser, token: string } } GET /api/auth/google - Google OAuth initiation endpoint GET /api/auth/google/callback - Google OAuth callback endpoint Todo Endpoints GET /api/todos - Headers: { Authorization: \u0026#34;Bearer ${token}\u0026#34; } - Response: { success: boolean, message: string, data: ITodo[] } POST /api/todos - Headers: { Authorization: \u0026#34;Bearer ${token}\u0026#34; } - Request Body: { title: string, description?: string } - Response: { success: boolean, message: string, data: ITodo } PUT /api/todos/:id - Headers: { Authorization: \u0026#34;Bearer ${token}\u0026#34; } - Request Body: { title?: string, description?: string, completed?: boolean } - Response: { success: boolean, message: string, data: ITodo } DELETE /api/todos/:id - Headers: { Authorization: \u0026#34;Bearer ${token}\u0026#34; } - Response: { success: boolean, message: string } Best Practices Type Safety\nAlways use specific types Avoid the any type Limit value sets with Union types Write reusable code with Generic types Code Organization\nUse separate folders for each layer Keep interfaces in relevant domain folders Generalize service layer with abstract classes Error Handling\nCreate custom error classes Use global error handler Standardize error messages Security\nStore sensitive information in environment variables Implement input validation Apply rate limiting Configure CORS policies correctly Conclusion In this project, we learned:\nWriting secure code with TypeScript\u0026rsquo;s type system Implementing OOP principles with TypeScript Designing a modern API architecture Implementing authentication and authorization TypeScript provided our project with important advantages such as:\nCompile-time error detection Better IDE support Self-documenting code Maintainability ",
    "tags": ["typescript","nodejs","microservices"],
    "categories": ["TypeScript","Node.js","Backend"],
    "lang": "en"
} 