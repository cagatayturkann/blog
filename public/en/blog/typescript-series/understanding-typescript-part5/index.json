{
    "title": "Understanding TypeScript - Part 5: The TypeScript Compiler",
    "permalink": "/en/blog/typescript-series/understanding-typescript-part5/",
    "summary": "In this article, we will examine the TypeScript compiler in detail. We will learn how to manage compiler settings, configuration options, and project configuration.",
    "content": "Hello! In this part of our TypeScript series, we will examine how our code is transformed into JavaScript and how we can manage this process. The TypeScript compiler and configuration options are among the important topics that form the foundation of our projects.\nWhat is the TypeScript Compiler? The TypeScript compiler (tsc) is a tool that converts our TypeScript code into JavaScript code that browsers can understand. It transforms the code we write using modern TypeScript features into our targeted JavaScript version.\nStarting the Project: tsc \u0026ndash;init When starting our TypeScript project, our first step is to create a configuration file. We can do this with the tsc --init command:\nnpx tsc --init This command creates a tsconfig.json file in our project\u0026rsquo;s root directory. This file contains the basic settings that determine the compiler\u0026rsquo;s behavior:\n{ \u0026#34;compilerOptions\u0026#34;: { \u0026#34;target\u0026#34;: \u0026#34;es2016\u0026#34;, \u0026#34;module\u0026#34;: \u0026#34;commonjs\u0026#34;, \u0026#34;strict\u0026#34;: true, \u0026#34;esModuleInterop\u0026#34;: true, \u0026#34;skipLibCheck\u0026#34;: true, \u0026#34;forceConsistentCasingInFileNames\u0026#34;: true } } Development with Watch Mode We can use Watch Mode to instantly compile changes we make to our code during development:\ntsc --watch # or tsc -w Advantages of Watch Mode:\nAutomatically detects file changes Performs instant compilation Shows errors in real-time Speeds up the development process // example.ts let message = \u0026#39;Hello TypeScript!\u0026#39;; console.log(message); // When Watch Mode is active, the JavaScript file // is automatically updated when you save the file Multiple File Compilation The TypeScript compiler can compile all TypeScript files in our project with a single command. When we run the tsc command in the project directory, all .ts files are automatically compiled:\n// user.ts export interface User { id: number; name: string; } // service.ts import { User } from \u0026#39;./user\u0026#39;; export class UserService { // service code } // Both files are compiled with a single command tsconfig.json and Basic Settings Files Option The files option in the tsconfig.json file allows us to explicitly specify which files to compile:\n{ \u0026#34;compilerOptions\u0026#34;: { // other options }, \u0026#34;files\u0026#34;: [\u0026#34;src/main.ts\u0026#34;, \u0026#34;src/utils/helpers.ts\u0026#34;, \u0026#34;src/types/index.d.ts\u0026#34;] } Include and Exclude Options We use include and exclude options to determine which files should be compiled and which should be excluded in our project:\n{ \u0026#34;compilerOptions\u0026#34;: { // other options }, \u0026#34;include\u0026#34;: [ \u0026#34;src/**/*\u0026#34; // all files under src directory ], \u0026#34;exclude\u0026#34;: [ \u0026#34;node_modules\u0026#34;, // exclude node_modules directory \u0026#34;**/*.test.ts\u0026#34;, // exclude test files \u0026#34;src/temp/*\u0026#34; // exclude temporary files ] } This configuration is particularly useful for:\nKeeping the node_modules directory out of compilation Separating test files from production code Excluding specific directories or file types OutDir: Determining Output Directory We specify where the compiled JavaScript files will be saved using the outDir option:\n{ \u0026#34;compilerOptions\u0026#34;: { \u0026#34;outDir\u0026#34;: \u0026#34;./dist\u0026#34; } } With this configuration:\nTypeScript files stay in the src folder Compiled JavaScript files are saved to the dist folder Project structure becomes more organized Example project structure:\nproject/ ├── src/ │ ├── index.ts │ └── utils/ │ └── helpers.ts ├── dist/ │ ├── index.js │ └── utils/ │ └── helpers.js └── tsconfig.json Target: JavaScript Version Target The target option determines which JavaScript version our TypeScript code will be compiled to:\n{ \u0026#34;compilerOptions\u0026#34;: { \u0026#34;target\u0026#34;: \u0026#34;es2020\u0026#34; // Other options: \u0026#34;es3\u0026#34;, \u0026#34;es5\u0026#34;, \u0026#34;es6\u0026#34;, \u0026#34;es2016\u0026#34;, \u0026#34;es2017\u0026#34;, \u0026#34;esnext\u0026#34; } } An example showing the effect of different targets:\n// TypeScript code class Animal { constructor(public name: string) {} } // output for target: \u0026#34;es5\u0026#34; var Animal = /** @class */ (function () { function Animal(name) { this.name = name; } return Animal; })(); // output for target: \u0026#34;es2020\u0026#34; class Animal { constructor(name) { this.name = name; } } Strict Mode and Null Checks We can enable strict mode to use TypeScript\u0026rsquo;s type safety features at the highest level:\n{ \u0026#34;compilerOptions\u0026#34;: { \u0026#34;strict\u0026#34;: true, \u0026#34;strictNullChecks\u0026#34;: true } } Effect of these settings:\n// strict: false let name: string; name = null; // No problem // strict: true and strictNullChecks: true let name: string; name = null; // Error! Type \u0026#39;null\u0026#39; is not assignable to type \u0026#39;string\u0026#39; // Correct usage let name: string | null; name = null; // Now it works Including JavaScript Files In some projects, we may need to use JavaScript and TypeScript files together. The allowJs option makes this possible:\n{ \u0026#34;compilerOptions\u0026#34;: { \u0026#34;allowJs\u0026#34;: true, \u0026#34;checkJs\u0026#34;: true // Performs type checking in JavaScript files } } This feature is particularly useful when:\nConverting existing JavaScript projects to TypeScript Working with third-party JavaScript libraries Doing gradual TypeScript adaptation Example usage:\n// utils.js (JavaScript file) export function add(a, b) { return a + b; } // index.ts (TypeScript file) import { add } from \u0026#39;./utils.js\u0026#39;; const result = add(5, 3); // TypeScript type checking works Best Practices Adjust Configuration According to Project\n{ \u0026#34;compilerOptions\u0026#34;: { \u0026#34;target\u0026#34;: \u0026#34;es2020\u0026#34;, // For modern browsers \u0026#34;module\u0026#34;: \u0026#34;esnext\u0026#34;, // Modern module system \u0026#34;strict\u0026#34;: true, // Strict type checking \u0026#34;outDir\u0026#34;: \u0026#34;./dist\u0026#34;, // Output directory \u0026#34;rootDir\u0026#34;: \u0026#34;./src\u0026#34; // Source directory } } Use Watch Mode Effectively\n# package.json { \u0026#34;scripts\u0026#34;: { \u0026#34;dev\u0026#34;: \u0026#34;tsc --watch\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;tsc\u0026#34; } } Keep Project Structure Organized\nproject/ ├── src/ # TypeScript source files ├── dist/ # Compiled JavaScript files ├── tests/ # Test files ├── tsconfig.json # TypeScript configuration └── package.json Appropriate Include/Exclude Configuration\n{ \u0026#34;include\u0026#34;: [\u0026#34;src/**/*\u0026#34;], \u0026#34;exclude\u0026#34;: [\u0026#34;node_modules\u0026#34;, \u0026#34;**/*.test.ts\u0026#34;, \u0026#34;**/*.spec.ts\u0026#34;] } Conclusion The TypeScript compiler and configuration options are an important part of modern web development processes. With proper configuration, you can:\nWrite safer code Speed up the development process Better organize project structure Make team collaboration easier In our next article, we\u0026rsquo;ll examine more advanced features of TypeScript. See you then!\n",
    "tags": ["typescript","compiler","configuration"],
    "categories": ["TypeScript"],
    "lang": "en"
} 