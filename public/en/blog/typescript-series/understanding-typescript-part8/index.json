{
    "title": "Understanding TypeScript - Part 8: Type Narrowing",
    "permalink": "/en/blog/typescript-series/understanding-typescript-part8/",
    "summary": "In this article, we\u0026rsquo;ll explore type narrowing techniques in TypeScript. We\u0026rsquo;ll cover type checking methods like typeof, instanceof, type predicates, and discriminated unions.",
    "content": "Hello! In this part of our TypeScript series, we\u0026rsquo;ll explore type narrowing, one of the most powerful features of the type system. Type narrowing refers to the techniques that allow us to narrow down a variable\u0026rsquo;s type to a more specific type. These techniques help us work more safely with union types and complex type structures.\nWhat is Type Narrowing? Type narrowing is TypeScript\u0026rsquo;s ability to narrow down a variable\u0026rsquo;s type to a more specific type within a context. This feature is particularly useful when working with union types. For example, if a variable can be either a string or a number, but we know it\u0026rsquo;s definitely a string in a specific code block, TypeScript uses this information to enhance type safety.\ntypeof Type Guards The typeof operator is one of the most basic type narrowing methods in TypeScript:\nconst isTeenager = (age: number | string) =\u0026gt; { if (typeof age === \u0026#39;string\u0026#39;) { // Here age is definitely a string return age.charAt(0) === \u0026#39;1\u0026#39;; } else { // Here age is definitely a number return age \u0026gt; 12 \u0026amp;\u0026amp; age \u0026lt; 20; } }; isTeenager(\u0026#39;20\u0026#39;); // false isTeenager(13); // true Advantages of using typeof type guards:\nProvides type safety Improves IDE support and code completion features Prevents runtime errors Increases code readability Truthiness Type Guards We can also perform type narrowing using JavaScript\u0026rsquo;s truthiness feature:\nconst printLetters = (word: string | null) =\u0026gt; { if (!word) { console.log(\u0026#39;No word was provided.\u0026#39;); return; } // Here word is definitely a string word.split(\u0026#39;\u0026#39;).forEach((letter) =\u0026gt; console.log(letter)); }; printLetters(\u0026#39;Hello\u0026#39;); // H, e, l, l, o printLetters(null); // No word was provided. Truthiness check evaluates these values as false:\nfalse 0 \u0026quot;\u0026quot; null undefined NaN Equality Type Narrowing Equality comparisons are also used for type narrowing in TypeScript:\nconst someFunc = (x: string | boolean, y: string | number) =\u0026gt; { if (x === y) { // Here both x and y are definitely strings console.log(x.toUpperCase()); console.log(y.toLowerCase()); } else { // x: string | boolean // y: string | number console.log(x); console.log(y); } }; in Operator Type Guards JavaScript\u0026rsquo;s in operator checks if a property exists in an object. TypeScript uses this check for type narrowing:\ntype Cat = { meow: () =\u0026gt; void }; type Dog = { bark: () =\u0026gt; void }; const talk = (creature: Cat | Dog) =\u0026gt; { if (\u0026#39;meow\u0026#39; in creature) { // Here creature is definitely a Cat creature.meow(); } else { // Here creature is definitely a Dog creature.bark(); } }; const kitty: Cat = { meow: () =\u0026gt; console.log(\u0026#39;MEOWWW\u0026#39;) }; talk(kitty); // MEOWWW instanceof Narrowing The instanceof operator checks if a variable is an instance of a specific class:\nconst printFullDate = (date: Date | string) =\u0026gt; { if (date instanceof Date) { // Here date is definitely a Date return date.toUTCString(); } else { // Here date is definitely a string return new Date(date).toUTCString(); } }; console.log(printFullDate(new Date())); console.log(printFullDate(\u0026#39;2025-02-21\u0026#39;)); Type Predicates In TypeScript, you can write custom type guard functions. These functions have a return type in the format parameterName is Type:\ninterface Cat { meow: () =\u0026gt; void; } interface Dog { bark: () =\u0026gt; void; } // Type predicate function function isCat(pet: Cat | Dog): pet is Cat { return (pet as Cat).meow !== undefined; } let pet = getAnimal(); if (isCat(pet)) { // Here pet is definitely a Cat pet.meow(); } else { // Here pet is definitely a Dog pet.bark(); } Advantages of type predicates:\nYou can write custom type guard logic Prevents code duplication Centralizes type checks Improves readability Discriminated Unions Discriminated unions is a technique for distinguishing between related types using a common literal property:\ninterface Circle { kind: \u0026#39;circle\u0026#39;; radius: number; } interface Square { kind: \u0026#39;square\u0026#39;; sideLength: number; } type Shape = Circle | Square; function getArea(shape: Shape) { switch (shape.kind) { case \u0026#39;circle\u0026#39;: // Here shape is definitely a Circle return Math.PI * shape.radius ** 2; case \u0026#39;square\u0026#39;: // Here shape is definitely a Square return shape.sideLength ** 2; } } Advantages of discriminated unions:\nProvides type safety Easy to use with switch cases Excellent IDE support Easy to add new types Catches missing cases at compile time Best Practices Choosing the Right Type Guard\n// typeof for simple types function processValue(value: string | number) { if (typeof value === \u0026#39;string\u0026#39;) { return value.toUpperCase(); } return value.toFixed(2); } // instanceof for classes function processDate(date: Date | string) { if (date instanceof Date) { return date.toISOString(); } return new Date(date).toISOString(); } Effective Use of Type Predicates\ninterface User { id: number; name: string; } interface Admin extends User { role: \u0026#39;admin\u0026#39;; permissions: string[]; } function isAdmin(user: User): user is Admin { return \u0026#39;role\u0026#39; in user \u0026amp;\u0026amp; user.role === \u0026#39;admin\u0026#39;; } Properly Structuring Discriminated Unions\ninterface ApiSuccess { status: \u0026#39;success\u0026#39;; data: any; } interface ApiError { status: \u0026#39;error\u0026#39;; error: string; } type ApiResponse = ApiSuccess | ApiError; function handleResponse(response: ApiResponse) { if (response.status === \u0026#39;success\u0026#39;) { processData(response.data); } else { handleError(response.error); } } Conclusion Type narrowing is one of TypeScript\u0026rsquo;s most powerful features. With these techniques, you can:\nWrite safer code Reduce runtime errors Get maximum benefit from IDE support Manage complex type structures more easily In our next article, we\u0026rsquo;ll continue exploring other advanced features of TypeScript. See you soon!\n",
    "tags": ["typescript","type-narrowing","type-guards"],
    "categories": ["TypeScript"],
    "lang": "en"
} 