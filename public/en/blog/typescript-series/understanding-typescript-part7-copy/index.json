{
    "title": "Understanding TypeScript - Part 7: Generics",
    "permalink": "/en/blog/typescript-series/understanding-typescript-part7-copy/",
    "summary": "In this article, we\u0026rsquo;ll explore generics, one of TypeScript\u0026rsquo;s most powerful features. We\u0026rsquo;ll learn how to write reusable code while maintaining type safety.",
    "content": "Hello! In this part of our TypeScript series, we\u0026rsquo;ll explore generic structures that make your code more flexible and reusable. Generics allow us to write functions and classes that can work with different data types while maintaining type safety.\nWhat are Generic Structures? Generics is a feature that allows a function or class to work with different types. The key point here is maintaining type safety while providing this flexibility. Let\u0026rsquo;s start with a simple example:\n// Non-generic approach - Separate function for each type function getFirstNumber(arr: number[]): number { return arr[0]; } function getFirstString(arr: string[]): string { return arr[0]; } // Generic approach - Single function, all types function getFirst\u0026lt;T\u0026gt;(arr: T[]): T { return arr[0]; } // Usage const firstNumber = getFirst\u0026lt;number\u0026gt;([1, 2, 3]); // type number const firstText = getFirst\u0026lt;string\u0026gt;([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]); // type string Here, \u0026lt;T\u0026gt; is a type parameter that specifies which types the function will work with. Since TypeScript can infer types in most cases, we don\u0026rsquo;t need to explicitly specify the type parameter:\nconst firstNumber = getFirst([1, 2, 3]); // automatically infers number type const firstText = getFirst([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]); // automatically infers string type Built-in Generic Types TypeScript has several commonly used built-in generic types:\nArray let numbers: Array\u0026lt;number\u0026gt; = [1, 2, 3]; // number[] let texts: Array\u0026lt;string\u0026gt; = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;]; // string[] Promise async function fetchData(): Promise\u0026lt;User\u0026gt; { const response = await fetch(\u0026#39;/api/user\u0026#39;); return response.json(); } Record\u0026lt;K,V\u0026gt; type UserRoles = Record\u0026lt;string, string[]\u0026gt;; const roles: UserRoles = { admin: [\u0026#39;read\u0026#39;, \u0026#39;write\u0026#39;, \u0026#39;delete\u0026#39;], editor: [\u0026#39;read\u0026#39;, \u0026#39;write\u0026#39;], user: [\u0026#39;read\u0026#39;], }; Writing Generic Functions Here are some key points to consider when writing generic functions:\n// Simple generic function function reverse\u0026lt;T\u0026gt;(items: T[]): T[] { return items.reverse(); } // Generic function - Arrow function syntax const filter = \u0026lt;T\u0026gt;(arr: T[], fn: (item: T) =\u0026gt; boolean): T[] =\u0026gt; { return arr.filter(fn); }; // Usage examples const numbers = reverse\u0026lt;number\u0026gt;([1, 2, 3]); const texts = reverse([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]); // Type inference const filteredArray = filter([1, 2, 3, 4], (n) =\u0026gt; n % 2 === 0); Multiple Type Parameters Sometimes we need multiple type parameters:\nfunction pair\u0026lt;T, U\u0026gt;(x: T, y: U): [T, U] { return [x, y]; } const result = pair\u0026lt;string, number\u0026gt;(\u0026#39;hello\u0026#39;, 42); const automatic = pair(\u0026#39;hello\u0026#39;, 42); // Type inference works Type Constraints We can use type constraints to specify what properties generic types should have:\ninterface Length { length: number; } function showLength\u0026lt;T extends Length\u0026gt;(arg: T): number { return arg.length; } // Works - string has length property showLength(\u0026#39;Hello\u0026#39;); // Works - array has length property showLength([1, 2, 3]); // Error - number doesn\u0026#39;t have length property // showLength(123); Generic Classes We can also use generic structures in classes:\nclass DataContainer\u0026lt;T\u0026gt; { private data: T[]; constructor(initialData: T[]) { this.data = initialData; } add(item: T): void { this.data.push(item); } get(index: number): T { return this.data[index]; } getAll(): T[] { return this.data; } } // Usage const numberContainer = new DataContainer\u0026lt;number\u0026gt;([1, 2, 3]); numberContainer.add(4); console.log(numberContainer.getAll()); // [1, 2, 3, 4] const textContainer = new DataContainer\u0026lt;string\u0026gt;([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]); textContainer.add(\u0026#39;d\u0026#39;); console.log(textContainer.get(0)); // \u0026#39;a\u0026#39; Generic Interface\u0026rsquo;s Interfaces can also use generic structures:\ninterface APIResponse\u0026lt;T\u0026gt; { data: T; status: number; message: string; } interface User { id: number; name: string; } // Usage function fetchUser(): Promise\u0026lt;APIResponse\u0026lt;User\u0026gt;\u0026gt; { return fetch(\u0026#39;/api/user\u0026#39;).then((res) =\u0026gt; res.json()); } // async/await usage async function getUser(): Promise\u0026lt;APIResponse\u0026lt;User\u0026gt;\u0026gt; { const response = await fetch(\u0026#39;/api/user\u0026#39;); return response.json(); } Generic Type Inference (Type Inference) TypeScript\u0026rsquo;s type inference system is very powerful. In most cases, we don\u0026rsquo;t need to explicitly specify generic types:\n// Explicit type parameter const x = getFirst\u0026lt;number\u0026gt;([1, 2, 3]); // Allow type inference const y = getFirst([1, 2, 3]); // automatically infers number type // Type inference for generic class const container = new DataContainer([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]); // automatically infers string[] type Best Practices Generic Naming Rules // Common generic type names: // T: Type (General type parameter) // K: Key (Primary type) // V: Value (Value type) // E: Element (Element type) // P: Properties (Property type) Using Type Constraints Correctly // Good usage interface HasId { id: number; } function getById\u0026lt;T extends HasId\u0026gt;(items: T[], id: number): T | undefined { return items.find((item) =\u0026gt; item.id === id); } Generic Constraint vs Union Types // Generic constraint usage function process\u0026lt;T extends string | number\u0026gt;(value: T): T { return value; } // Union type usage function process2(value: string | number): string | number { return value; } // Generic constraint is safer and maintains type information Keep Generics Simple // Complex function processData\u0026lt;T, U, V, W\u0026gt;( data: T[], transformer: (item: T) =\u0026gt; U, validator: (transformed: U) =\u0026gt; V, formatter: (validated: V) =\u0026gt; W ): W[] { // ... } // Better - Use separate interfaces for intermediate types interface DataProcessor\u0026lt;T, R\u0026gt; { transform(item: T): R; } function processData\u0026lt;T, R\u0026gt;(data: T[], processor: DataProcessor\u0026lt;T, R\u0026gt;): R[] { return data.map((item) =\u0026gt; processor.transform(item)); } Generic\u0026rsquo;s with Arrow Functions When using generic arrow functions in TypeScript, there are some syntax features to consider:\n// Standard generic arrow function const identity = (arg: T): T =\u0026gt; arg; // Prevent TSX conflict when using with React const identity = (arg: T): T =\u0026gt; arg; // Arrow function with multiple type parameters const pair = (first: T, second: U): [T, U] =\u0026gt; [first, second]; Generic\u0026rsquo;s with Asynchronous Operations Asynchronous operations are common in modern web applications. Generics can also help in this area:\n// Generic async function async function fetchData(url: string): Promise { const response = await fetch(url); return response.json(); } // Usage interface User { id: number; name: string; email: string; } // Type-safe API call const user = await fetchData(\u0026#39;/api/user/1\u0026#39;); console.log(user.name); // Type-safe access // Generic error handling interface APIError { code: number; message: string; } async function fetchWithError(): Promise { try { const response = await fetch(\u0026#39;/api/data\u0026#39;); if (!response.ok) { throw (await response.json()) as APIError; } return response.json(); } catch (error) { throw error as APIError; } } Generics with Utility Types TypeScript\u0026rsquo;s built-in utility types also use generic structures. Here are some common examples:\n// Partial - Makes all properties optional interface User { id: number; name: string; email: string; } type PartialUser = Partial; // { id?: number; name?: string; email?: string; } // Pick - Selects specific properties type UserBasicInfo = Pick; // { name: string; email: string; } // Omit - Removes specific properties type UserWithoutId = Omit; // { name: string; email: string; } // Record - Creates key-value structure type UserRoles = Record; // { [key: string]: string[] } Advanced Type Inference Topics TypeScript\u0026rsquo;s type inference system is very advanced. Here are some advanced examples:\n// Return type inference function createPair(first: T) { return { first, second: first, }; } // TypeScript automatically infers { first: T, second: T } type // Generic constraints with type inference interface HasLength { length: number; } function longest(a: T, b: T): T { return a.length \u0026gt;= b.length ? a : b; } // TypeScript makes separate inferences for string[] and string const longerArray = longest([1, 2], [1, 2, 3]); // type: number[] const longerString = longest(\u0026#39;123\u0026#39;, \u0026#39;12345\u0026#39;); // type: string Generic Type Alias vs Interface When using generic structures with type alias and interface, there are some differences:\n// Generic type alias type Container = { value: T; tag: string; }; // Generic interface interface Box { value: T; tag: string; } // They are used similarly const numberContainer: Container = { value: 42, tag: \u0026#39;number\u0026#39; }; const stringBox: Box = { value: \u0026#39;test\u0026#39;, tag: \u0026#39;text\u0026#39; }; // Interfaces can be extended interface LabeledBox extends Box { label: string; } // Type aliases can be extended with intersection types type LabeledContainer = Container \u0026amp; { label: string; }; Important Points and Tips Carefully Use Generic Constraints\nVery broad constraints reduce type safety Very narrow constraints reduce reusability Trust Type Inference\nTypeScript can infer the correct type in most cases Don\u0026rsquo;t explicitly specify generic types unnecessarily Maintain Readability\nGeneric type names should be meaningful Avoid too many type parameters Break down complex generic structures into smaller parts Conclusion Generics are one of the most powerful features of TypeScript. When used correctly:\nReduce code repetition Increase type safety Allow reusable and flexible code Provide better IDE support Especially when developing large projects or libraries, using generics can maximize the power of generics. Understanding and using generics is a must when developing with TypeScript.\nOur next article will explore other advanced features of TypeScript. See you soon!\nDefault Type Parameters We can assign default values to generic types:\nclass Queue\u0026lt;T = number\u0026gt; { private data: T[] = []; push(item: T) { this.data.push(item); } pop(): T | undefined { return this.data.shift(); } } // Uses number type by default const numberQueue = new Queue(); // Customized for string type const textQueue = new Queue\u0026lt;string\u0026gt;(); Generic Interfaces We can also use generic structures in interfaces:\ninterface APIResponse\u0026lt;T\u0026gt; { data: T; status: number; message: string; } interface User { id: number; name: string; } // Usage function fetchUser(): Promise\u0026lt;APIResponse\u0026lt;User\u0026gt;\u0026gt; { return fetch(\u0026#39;/api/user\u0026#39;).then((res) =\u0026gt; res.json()); } // Usage with async/await async function getUser(): Promise\u0026lt;APIResponse\u0026lt;User\u0026gt;\u0026gt; { const response = await fetch(\u0026#39;/api/user\u0026#39;); return response.json(); } ",
    "tags": ["typescript","generics","type-safety"],
    "categories": ["TypeScript"],
    "lang": "en"
} 