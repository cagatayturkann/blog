{
    "title": "",
    "permalink": "/en/blog/typescript/part2/typescript-functions-blog-en-part2/",
    "summary": "\u003cp\u003eKey differences between optional parameters and default values:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eOptional Parameters (\u003ccode\u003e?\u003c/code\u003e)\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eParameter becomes \u003ccode\u003eundefined\u003c/code\u003e if not provided\u003c/li\u003e\n\u003cli\u003eRequires checks in the function body\u003c/li\u003e\n\u003cli\u003eMore flexible but requires more handling\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eDefault Values (\u003ccode\u003e= value\u003c/code\u003e)\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eUses specified value if parameter is omitted\u003c/li\u003e\n\u003cli\u003eNo extra checks needed\u003c/li\u003e\n\u003cli\u003eLess flexible but easier to use\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"important-parameter-order\"\u003eImportant: Parameter Order\u003c/h3\u003e\n\u003cp\u003eWhen using both required and optional parameters, required parameters must come first:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-typescript\" data-lang=\"typescript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// CORRECT\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003efunction\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ecorrect\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003erequired\u003c/span\u003e: \u003cspan style=\"color:#66d9ef\"\u003estring\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003eoptional?\u003c/span\u003e: \u003cspan style=\"color:#66d9ef\"\u003estring\u003c/span\u003e) {}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// WRONG - TypeScript will error\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003efunction\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ewrong\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003eoptional?\u003c/span\u003e: \u003cspan style=\"color:#66d9ef\"\u003estring\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003erequired\u003c/span\u003e: \u003cspan style=\"color:#66d9ef\"\u003estring\u003c/span\u003e) {} \u003cspan style=\"color:#75715e\"\u003e// Error!\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"anonymous-functions-and-type-inference\"\u003eAnonymous Functions and Type Inference\u003c/h2\u003e\n\u003cp\u003eTypeScript is particularly good at inferring types in anonymous functions, especially in callbacks:\u003c/p\u003e",
    "content": "Key differences between optional parameters and default values:\nOptional Parameters (?)\nParameter becomes undefined if not provided Requires checks in the function body More flexible but requires more handling Default Values (= value)\nUses specified value if parameter is omitted No extra checks needed Less flexible but easier to use Important: Parameter Order When using both required and optional parameters, required parameters must come first:\n// CORRECT function correct(required: string, optional?: string) {} // WRONG - TypeScript will error function wrong(optional?: string, required: string) {} // Error! Anonymous Functions and Type Inference TypeScript is particularly good at inferring types in anonymous functions, especially in callbacks:\nconst numbers = [1, 2, 3, 4, 5]; // TypeScript automatically infers \u0026#39;number\u0026#39; type for \u0026#39;num\u0026#39; numbers.forEach(num =\u0026gt; { console.log(num.toFixed(2)); // Works because TypeScript knows num is a number }); // Type inference in array methods const squares = numbers.map(num =\u0026gt; num * num); // squares is inferred as number[] The never Type The never type is special in TypeScript and represents values that never occur. It has two main use cases:\nFunctions that never complete: function infiniteLoop(): never { while (true) { console.log(\u0026#34;I\u0026#39;m still going!\u0026#34;); } } function infiniteRecursion(): never { return infiniteRecursion(); } Functions that always throw errors: function throwError(message: string): never { throw new Error(message); } function validateUser(user: never): never { throw new Error(\u0026#34;Should never be called with a value\u0026#34;); } Don\u0026rsquo;t confuse never with void:\nvoid returns undefined or null (technically still a value) never means the function never completes execution Function Overloads TypeScript allows you to define multiple function signatures for different parameter types:\n// Overload signatures function combine(a: string, b: string): string; function combine(a: number, b: number): number; // Implementation function combine(a: string | number, b: string | number): string | number { if (typeof a === \u0026#34;string\u0026#34; \u0026amp;\u0026amp; typeof b === \u0026#34;string\u0026#34;) { return a.concat(b); } if (typeof a === \u0026#34;number\u0026#34; \u0026amp;\u0026amp; typeof b === \u0026#34;number\u0026#34;) { return a + b; } throw new Error(\u0026#34;Parameters must be of the same type!\u0026#34;); } console.log(combine(\u0026#34;Hello, \u0026#34;, \u0026#34;World\u0026#34;)); // \u0026#34;Hello, World\u0026#34; console.log(combine(5, 10)); // 15 // combine(\u0026#34;5\u0026#34;, 10); // Error! This combination isn\u0026#39;t defined Best Practices Always Type Parameters\n// BAD function bad(name) { return `Hello ${name}`; } // GOOD function good(name: string): string { return `Hello ${name}`; } Consider Return Types\n// Type inference is sometimes enough const add = (a: number, b: number) =\u0026gt; a + b; // But explicit return types are better for complex functions function processData(data: any[]): ProcessedData { // Complex operations... return processedResult; } Use Optional Parameters Wisely\nPut required parameters before optional ones Consider using default values instead of optional parameters when appropriate Document the behavior of optional parameters Avoid any Type\n// BAD function processAny(data: any) { return data.someMethod(); // Dangerous! } // GOOD function processTyped\u0026lt;T\u0026gt;(data: T) { // Type-safe operations } Quick Reference Here\u0026rsquo;s a quick reference of function types in TypeScript:\n// Basic function with parameter and return types function basic(param: string): number { } // Arrow function with type annotations const arrow = (x: number): string =\u0026gt; { } // Optional parameter function optional(name: string, age?: number) { } // Default value function defaultValue(name: string = \u0026#34;Anonymous\u0026#34;) { } // Void return type function noReturn(): void { } // Never return type function neverReturns(): never { } // Function overloads function overloaded(x: string): string; function overloaded(x: number): number; Conclusion TypeScript\u0026rsquo;s function features provide powerful tools for writing safer and more maintainable code. Through type checking, we can catch errors early and make our code more self-documenting. While it might seem like extra work at first, the benefits become clear as your projects grow in size and complexity.\nIn the next article, we\u0026rsquo;ll explore interfaces and how they help us define complex object types. Stay tuned!\n",
    "tags": null,
    "categories": null,
    "lang": "en"
} 