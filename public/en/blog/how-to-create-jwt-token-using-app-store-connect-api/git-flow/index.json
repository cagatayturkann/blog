{
    "title": "Git Flow Nedir?",
    "permalink": "/en/blog/how-to-create-jwt-token-using-app-store-connect-api/git-flow/",
    "summary": "Git Flow, versiyon kontrol sistemlerinde branch yönetimini sistematik hale getiren etkili bir yaklaşımdır. Bu yazıda Git Flow\u0026rsquo;un ne olduğunu, nasıl kullanıldığını ve en iyi uygulama önerilerini detaylı bir şekilde anlatacağım.",
    "content": "\nSelamlar. Bu yazımda versiyon kontrol sistemlerinden kısaca bahsedip, Git Flow\u0026rsquo;un ne olduğunu ve nasıl kullanıldığını detaylı bir şekilde anlatacağım. Versiyon kontrol sistemleri, yazılım geliştirme süreçlerinde kodun versiyonlarını takip etmek ve yönetmek için kullanılan önemli araçlardır. Git Flow ise bu versiyon kontrol sistemini daha etkili kullanmamızı sağlayan bir branching modelidir.\nVersiyon Kontrol Sistemi Nedir? Versiyon kontrol sistemi, bir veya daha fazla dosya, doküman (yazılım projesi, ofis belgesi vb.) üzerinde yaptığımız değişiklikleri adım adım kaydeden, daha sonra belirli bir sürüme geri dönebilmemizi sağlayan ve istersek bunu internet üzerinde depoda (repository) saklamamızı ve yönetmemizi sağlayan bir sistemdir. Git, SVN, BitKeeper, Mercurial sürüm kontrol sistemlerine örnek olarak gösterilebilir.\nNeden Versiyon Kontrol Sistemi Kullanıyoruz? Her dosyanın tam bir uzun vadeli değişiklik geçmişi tutulur.\nBu, dosya üzerinde yıllar içinde birçok kişi tarafından yapılan her değişikliğin tutulması anlamına gelir. Bu da bulunduğumuz konuma nereden geldiğimizi anlamak için eski ve yeni kodumuz arasında karşılaştırma yapmamızı sağlar. Ekip üyelerinin eşzamanlı olarak aynı kod üzerinde çalışmasına imkan verir.\nAlt sürümler oluşturarak yazılım üzerinde farklı çalışmaları yürütüp, sonrasında ana yazılıma bunu entegre etmek mümkündür. Yazılımda yapılan her değişikliği takip edip proje yönetimine bağlayabilme imkanı sağlar.\nYazılım üzerindeki sorunların, sürümler ile ilişkilendirilmesine ve takip edilebilmesine olanak sağlar. Projede hatayla karşılaştığımız durumlarda eski kod kaydına dönmemizi sağlar.\nVersiyon Kontrol Sistemleri Lokal VKS: En eski versiyon kontrol sistemi yaklaşımıdır. Çalıştığımız projemiz ve yaptığımız değişiklikler kullanıcı makinesi üzerindeki veritabanında tutulur. Her yapılan commit bir versiyon olarak tutulur ve commit değerine hash ataması yapılarak her versiyon birbirinden ayırt edilmektedir. Ayrıca versiyon görüntüleme imkanını sağlar. Ancak bu sistemde sadece bir kullanıcı etkin bir şekilde çalışabilir.\nMerkezi VKS: Birden fazla kişinin bir proje üzerinde etkin çalışması için ortaya atılmış versiyonlama sistemidir. CVS, SVN birer merkezi versiyon kontrol sistemleridir. Bu sistemde proje ortak bir repository\u0026rsquo;de tutulur ve birden fazla geliştirici aynı repository üzerinde checkout ve commit işlemlerini gerçekleştirmektedir. Bu yöntemde herkesin projeye katkı sağlamasının yanı sıra bazı ciddi sorunları vardır. Tek merkezli sunucunun 1 saatliğine arızalanması durumunda, kullanıcılar 1 saat boyunca çalışmalarını veya çalıştıkları projenin sürümlenmiş kopyalarını kaydetmeleri mümkün olmayacaktır.\nDağıtık VKS: Merkezi versiyon sistemlerinin geliştiricilerin çevrimdışı çalışabilmesi ve repository\u0026rsquo;nin zarar görmesi durumunda geri getirme gibi eksikliklerinden dolayı ortaya atılmış bir versiyon sistemidir. Git, Mercurial, BitKeeper gibi sistemler dağıtık versiyon sistemlerine örnek gösterilebilir. Bu sistemlerde merkezi bir repository olmayıp, proje üzerinde çalışan her makine, projenin kopyasını kendi yerel bilgisayarında tutmaktadır. Geliştiriciler proje üzerinde değişiklik yapmak veya proje geçmişine göz atmak istediklerinde, uzak depo ile iletişime geçmek zorunda değildir. Sunuculardan biri çökerse ve o sunucu üzerinde ortak çalışma yürüten sistemler varsa, geliştiricilerden birinin projeyi sunucuya geri yükleyerek sistem kurtarılabilir. Özet olarak aynı projede farklı geliştiriciler, farklı biçimlerde çalışma yürüterek, farklı iş akışları ile çalışabilmeyi sağlar.\nGit Flow Nedir? 5 Ocak 2020 tarihinde https://nvie.com/posts/a-successful-git-branching-model/ adresinde yayınlanan bir yazı ile nvie, git repolarını derli toplu tutmak adına bir model önerdi. Daha sonra bu modeli kullanmayı kolaylaştıran git eklentilerini de barındıran Git-Flow isimli bir proje yayınladı. GitFlow modeli temel olarak git versiyon kontrol sistemine dayanıyor. Yani modelin tüm işleyişini git komutları ile de yürütmek mümkün.\nGit Flow\u0026rsquo;un Avantajları ve Dezavantajları Avantajları:\nDüzenli ve tahmin edilebilir bir geliştirme süreci sağlar Büyük ekipler için ideal bir yapı sunar Sürüm yönetimini kolaylaştırır Her branch\u0026rsquo;in net bir amacı vardır Paralel geliştirmeyi destekler Dezavantajları:\nKüçük projeler için fazla karmaşık olabilir Sürekli teslimat (continuous delivery) için uygun olmayabilir Branch yapısı bazen gereksiz karmaşıklığa yol açabilir Ek araç kurulumu gerektirir Öğrenme eğrisi diğer modellere göre daha yüksektir Git Flow\u0026rsquo;a Alternatifler GitHub Flow: Daha basit bir model, sadece master ve feature branch\u0026rsquo;lerini kullanır GitLab Flow: Git Flow ile GitHub Flow arasında bir denge kurar Trunk Based Development: Ana dal üzerinde geliştirmeye odaklanır Git Flow Çalışma Prensibi Git Flow modelinde 5 ana branch bulunmaktadır:\nmaster: Ana dallardan olan Master, proje süresince var olan daldır. Master dalında her zaman canlıya alınabilecek kod bulunur. İdeal şartlarda Master dalına yapılan her bir commit bir versiyondur ve \u0026ldquo;git tag\u0026rdquo; ile işaretlenmesi yani sürüm numarası verilmesi gereklidir. Master dalına doğrudan commit yapılmaz, sadece hotfix ve release dallarından merge işlemleri yapılır.\ndevelop: Develop dalı da proje süresince var olan diğer ana daldır. Develop dalında ise bir sonraki sürüm için yapılan değişiklikler yer alır. Tüm feature dalları önce bu dala merge edilir. Bu dal projenin ana geliştirme dalıdır ve sürekli entegrasyon (CI) süreçleri genellikle bu dal üzerinden yürütülür.\nhotfix: Hotfix dalı yayında olan sürümde kritik bir hata olduğunda ve hatanın acilen çözülüp yayına alınması durumunda kullanılır. Açılan Hotfix dalı master dalından oluşturulur ve isimlendirilmesi genellikle \u0026lsquo;hotfix/[versiyon]-[açıklama]\u0026rsquo; formatında yapılır. Hotfix dalında gerekli hata çözümü yapıldığı zaman bu dal Developer ve Master ile birleştirilir. Master ile birleştirme sonrası yapılan değişiklik yeni bir sürüm numarası ile etiketlenir.\nfeature: Yeni özellik ekleneceğinde bu özellik için Feature dalı açılır. Feature dalları her zaman develop dalından oluşturulur ve isimlendirilmesi genellikle \u0026lsquo;feature/[özellik-adı]\u0026rsquo; formatında yapılır. Özelliklere burada görece yapılacak değişiklikler denebilir. Aynı anda birden fazla özellik dalı açılabilir. Yani farklı geliştiriciler farklı özellikler üzerinde çalışabilir. Özelliklerin ayrı dallarda geliştirilmesi hem Develop dalının gereksiz commit\u0026rsquo;ler ile dolmasını engeller hem de bu yöntemle özellikten vazgeçilmesi durumunda yalnızca özellik dalının silinmesi yeterli olur. Özellik tamamlandığında bu dal ile Develop dalı birleştirilir ve özellik dalı silinir. Yani özellik dalları yalnızca geliştirme süresince yaşamlarını sürdürür. Tabii bu süreçte Develop dalına ara ara kontrol amaçlı pull yapılması gerekebilir çünkü bir başka geliştirici özellik dalını önce bitirmiş ve Develop dalına versiyon geçmiş olabilir. Feature dalları isimlendirilirken master, release, develop ve hotfix içermeyen isimler verilmelidir.\nrelease: Tüm değişiklikler bitti diyelim. Sonrasında yeni bir sürüm yayınlanacağı zaman Develop dalından yeni bir Release dalı oluşturulur. Release dalları genellikle \u0026lsquo;release/[versiyon]\u0026rsquo; formatında isimlendirilir. Sürümdeki son değişiklikler, sürüm numarası değiştirmek vb. gibi işlemler bu dal içerisinde gerçekleştirilir. Release dalında sadece hata düzeltmeleri yapılmalı, yeni özellik eklenmemelidir. Gerekli tüm değişiklikler tamamlandığında Release dalında tamamlanan tüm değişiklikler Master ve Develop branch\u0026rsquo;lerine merge edilir. Master dalında git tag ile sürüm numarası etiketlenir ve daha sonra Release branch\u0026rsquo;i silinir.\nGit Flow Örnek Proje /brew install git-flow \u0026gt; git flow init Öncelikle \u0026ldquo;brew install git-flow\u0026rdquo; ile kurulumu sağlıyoruz. GitFlow git ile birlikte gelmiyor. Ayrıca kurulum yapılmalı. Dezavantajlarından bir tanesi olarak kabul ediliyor. Git tarafında projeyi başlatmak için \u0026ldquo;git init\u0026rdquo; komutunu giriyorduk. Git-flow için ise \u0026ldquo;git flow init\u0026rdquo; komutunu giriyoruz ve git-flow sürecini başlatıyoruz. Komut çalıştığında eğer herhangi bir repo mevcut değilse önce repo oluşur. Daha sonra kullanıcıya süreç için kullanılacak branch isimlerini sorar. Dal isimleri özelleştirilebilir durumdadır ancak önerilen default değerlerin bırakılmasıdır.\n/git flow feature start performance Bu komut ile yeni bir feature dalı açılır. Özellik adı performans olduğundan varsayılan dal feature/performans olacaktır. Aynı işi mevcut git komutuyla da yapabiliriz. Bunun için girmemiz gereken komut ise \u0026ldquo;git checkout -b myFeature feature/performans\u0026rdquo; olacaktı.\n/git flow feature finish performance Bu komut ile daha önce açılmış olan dal kapatılır. Kapatma işlemi önce özellik dalının develop dalına merge edilmesi ile başlar ardından özellik dalının silinmesi ile sonlanır. Komut çalıştırıldığında şayet değişiklikler commit edilmedi ise hata verir. Commit sonrası push işlemi yapılmaz ise hata verir. Normal git komutları ile bu işlemi yapmak için önce ilgili dalda commit yapılır daha sonra sırasıyla \u0026ldquo;git checkout develop \u0026gt; git merge \u0026ndash;no-ff feature/performans \u0026gt; git branch -D feature/performans\u0026rdquo; komutları çalıştırılır.\n/git flow release start 1.0.0 Bu komut girildiğinde yeni bir sürüm yayınlanmaya hazır hale gelir. Komut çalıştırıldığında Develop dalından yeni bir release/1.0.0 dalı oluşur. Mevcut git komutu ile bu işlemi gerçekleştirmek için ise \u0026ldquo;git checkout -b release/1.0.0 develop\u0026rdquo; komutu çalıştırılır.\n/git flow release finish 1.0.0 Komut girildiğinde hazırlanması tamamlanan sürüm master dalına taşınır. Yapılan değişiklikler hem develop hem master dalı ile birleşir. Master dalındaki son commit sürüm numarası ile etiketlenir. Ardından release dalı otomatik silinir. Aynı işlemi git komutları ile birlikte yapmak için aşağıdaki komutlar sırayla çalıştırılır.\ngit checkout master git merge --no-ff release/1.0.0 git tag -a 1.0.0 git checkout develop git merge --no-ff release/1.0.0 git branch -d release/1.0.0 /git flow hotfix start 1.0.1 Komut ile yeni bir hotfix başlatılır. Hotfix dalları acil güncellemelerde kullanılır ve master dalından oluşturulurlar. Komut çalıştığında master dalından dallanan yeni bir hotfix/1.0.1 dalı oluşur. Git komutu ile işlemi yapmak için \u0026ldquo;git checkout -b hotfix/1.0.1 master\u0026rdquo; komutu çalıştırılır.\n/git flow hotfix finish 1.0.1 Komut ile hotfix tamamlanır. Değişiklikler hem Develop hem Master dalına alınır. Master dalı 1.0.1 ile etiketlenir ve hotfix dalı silinir. \u0026ldquo;git tag -l\u0026rdquo; komutu çalıştırıldığında sürüm versiyonları görülür. Aynı işlemi mevcut git komutlarıyla yapmak için aşağıdaki komutlar sırasıyla çalıştırılır.\ngit checkout master git merge --no-ff hotfix/1.0.1 git tag -a 1.0.1 git checkout develop git merge --no-ff hotfix/1.0.1 git branch -d hotfix/1.0.1 Git Flow En İyi Uygulama Önerileri Branch İsimlendirme Kuralları\nFeature branch\u0026rsquo;leri için açıklayıcı isimler kullanın (örn: feature/user-authentication) Hotfix ve release branch\u0026rsquo;leri için semantic versioning kullanın Commit Mesajları\nAçıklayıcı commit mesajları yazın Conventional Commits standardını takip edin Her commit\u0026rsquo;in tek bir amacı olmasına dikkat edin Code Review Süreci\nFeature branch\u0026rsquo;lerini merge etmeden önce code review yapın Automated testing süreçlerini kullanın Dokümantasyon güncellemelerini unutmayın Merge Stratejisi\n\u0026ndash;no-ff (no fast-forward) parametresini kullanın Merge çakışmalarını hızlıca çözün Squash commit\u0026rsquo;leri kullanmayı değerlendirin Sonuç Git Flow, modern yazılım geliştirme süreçlerinde branch yönetimini sistematik ve düzenli hale getiren etkili bir yaklaşımdır. Bu workflow sayesinde ekipler daha organize çalışabilir, sürüm kontrolünü daha iyi yapabilir ve kod kalitesini artırabilir. Özellikle büyük projelerde ve ekip çalışmalarında Git Flow\u0026rsquo;un sunduğu yapılandırılmış branch stratejisi, geliştirme süreçlerini önemli ölçüde iyileştirir. Yukarıda bahsedilen best practice\u0026rsquo;leri takip ederek, Git Flow\u0026rsquo;u projenizde başarıyla uygulayabilir ve yazılım geliştirme süreçlerinizi daha verimli hale getirebilirsiniz.\n",
    "tags": ["git-flow","git"],
    "categories": ["Git"],
    "lang": "en"
} 