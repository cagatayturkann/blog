{
    "title": "TypeScript'i Anlamak - Bölüm 7: Generics",
    "permalink": "/blog/tr/typescript-serisi/typescripti-anlamak-bolum7/",
    "summary": "Bu makalede, TypeScript\u0026rsquo;in en güçlü özelliklerinden biri olan generic yapıları inceleyeceğiz. Tip güvenliğini korurken yeniden kullanılabilir kod yazmanın yollarını öğreneceğiz.",
    "content": "Merhaba! TypeScript serimizin bu bölümünde, kodunuzu daha esnek ve yeniden kullanılabilir hale getiren generic yapıları inceleyeceğiz. Generics, tip güvenliğinden ödün vermeden farklı veri tipleriyle çalışabilen fonksiyonlar ve sınıflar yazmamızı sağlar.\nGeneric Yapılar Nedir? Generics, bir fonksiyon veya sınıfın farklı tiplerle çalışabilmesini sağlayan bir özelliktir. Burada önemli nokta, tip güvenliğini korurken bu esnekliği sağlayabilmesidir. Basit bir örnekle başlayalım:\n// Generic olmayan yaklaşım - Her tip için ayrı fonksiyon function getFirstNumber(arr: number[]): number { return arr[0]; } function getFirstString(arr: string[]): string { return arr[0]; } // Generic yaklaşım - Tek fonksiyon, tüm tipler function getFirst\u0026lt;T\u0026gt;(arr: T[]): T { return arr[0]; } // Kullanım const ilkSayi = getFirst\u0026lt;number\u0026gt;([1, 2, 3]); // number tipinde const ilkMetin = getFirst\u0026lt;string\u0026gt;([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]); // string tipinde Bu örnekte \u0026lt;T\u0026gt; bir tip parametresidir ve fonksiyonun hangi tiplerle çalışacağını belirtir. TypeScript çoğu durumda tip çıkarımı yapabildiği için tip parametresini açıkça belirtmek zorunda değiliz:\nconst ilkSayi = getFirst([1, 2, 3]); // number tipini otomatik çıkarır const ilkMetin = getFirst([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]); // string tipini otomatik çıkarır Built-in Generic Tipler TypeScript\u0026rsquo;te sık kullanılan bazı yerleşik generic tipler vardır:\nArray let sayilar: Array\u0026lt;number\u0026gt; = [1, 2, 3]; // number[] let metinler: Array\u0026lt;string\u0026gt; = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;]; // string[] Promise async function veriGetir(): Promise\u0026lt;User\u0026gt; { const response = await fetch(\u0026#39;/api/user\u0026#39;); return response.json(); } Record\u0026lt;K,V\u0026gt; type KullaniciRolleri = Record\u0026lt;string, string[]\u0026gt;; const roller: KullaniciRolleri = { admin: [\u0026#39;okuma\u0026#39;, \u0026#39;yazma\u0026#39;, \u0026#39;silme\u0026#39;], editor: [\u0026#39;okuma\u0026#39;, \u0026#39;yazma\u0026#39;], user: [\u0026#39;okuma\u0026#39;], }; Generic Fonksiyonlar Yazmak Generic fonksiyonlar yazarken dikkat etmemiz gereken bazı noktalar var:\n// Basit generic fonksiyon function reverse\u0026lt;T\u0026gt;(items: T[]): T[] { return items.reverse(); } // Generic fonksiyon - Ok fonksiyonu syntax const filter = \u0026lt;T\u0026gt;(arr: T[], fn: (item: T) =\u0026gt; boolean): T[] =\u0026gt; { return arr.filter(fn); }; // Kullanım örnekleri const sayilar = reverse\u0026lt;number\u0026gt;([1, 2, 3]); const metinler = reverse([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]); // Tip çıkarımı const filtrelenmisArray = filter([1, 2, 3, 4], (n) =\u0026gt; n % 2 === 0); Çoklu Tip Parametreleri Bazen birden fazla tip parametresine ihtiyaç duyabiliriz:\nfunction cift\u0026lt;T, U\u0026gt;(x: T, y: U): [T, U] { return [x, y]; } const sonuc = cift\u0026lt;string, number\u0026gt;(\u0026#39;merhaba\u0026#39;, 42); const otomatik = cift(\u0026#39;merhaba\u0026#39;, 42); // Tip çıkarımı çalışır Tip Kısıtlamaları (Constraints) Generic tiplerin hangi özelliklere sahip olması gerektiğini belirtmek için tip kısıtlamaları kullanabiliriz:\ninterface Uzunluk { length: number; } function uzunlukGoster\u0026lt;T extends Uzunluk\u0026gt;(arg: T): number { return arg.length; } // Çalışır - string\u0026#39;in length özelliği var uzunlukGoster(\u0026#39;Merhaba\u0026#39;); // Çalışır - array\u0026#39;in length özelliği var uzunlukGoster([1, 2, 3]); // Hata - number\u0026#39;ın length özelliği yok // uzunlukGoster(123); Generic Sınıflar Generic yapıları sınıflarda da kullanabiliriz:\nclass DataContainer\u0026lt;T\u0026gt; { private data: T[]; constructor(initialData: T[]) { this.data = initialData; } add(item: T): void { this.data.push(item); } get(index: number): T { return this.data[index]; } getAll(): T[] { return this.data; } } // Kullanım const sayiContainer = new DataContainer\u0026lt;number\u0026gt;([1, 2, 3]); sayiContainer.add(4); console.log(sayiContainer.getAll()); // [1, 2, 3, 4] const metinContainer = new DataContainer\u0026lt;string\u0026gt;([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]); metinContainer.add(\u0026#39;d\u0026#39;); console.log(metinContainer.get(0)); // \u0026#39;a\u0026#39; Varsayılan Tip Parametreleri Generic tiplere varsayılan değerler atayabiliriz:\nclass Queue\u0026lt;T = number\u0026gt; { private data: T[] = []; push(item: T) { this.data.push(item); } pop(): T | undefined { return this.data.shift(); } } // number tipini varsayılan olarak kullanır const sayiKuyrugu = new Queue(); // string tipi için özelleştirilmiş const metinKuyrugu = new Queue\u0026lt;string\u0026gt;(); Generic Interface\u0026rsquo;ler Interface\u0026rsquo;lerde de generic yapıları kullanabiliriz:\ninterface APIResponse\u0026lt;T\u0026gt; { data: T; status: number; message: string; } interface User { id: number; name: string; } // Kullanım function fetchUser(): Promise\u0026lt;APIResponse\u0026lt;User\u0026gt;\u0026gt; { return fetch(\u0026#39;/api/user\u0026#39;).then((res) =\u0026gt; res.json()); } // async/await ile kullanım async function getUser(): Promise\u0026lt;APIResponse\u0026lt;User\u0026gt;\u0026gt; { const response = await fetch(\u0026#39;/api/user\u0026#39;); return response.json(); } Generic Type Inference (Tip Çıkarımı) TypeScript\u0026rsquo;in güçlü tip çıkarım sistemi sayesinde çoğu durumda generic tipleri açıkça belirtmemize gerek kalmaz:\n// Tip parametrelerini açıkça belirtme const x = getFirst\u0026lt;number\u0026gt;([1, 2, 3]); // Tip çıkarımına izin verme const y = getFirst([1, 2, 3]); // number tipini otomatik çıkarır // Generic sınıf için tip çıkarımı const container = new DataContainer([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]); // string[] çıkarımı Best Practices Generic İsimlendirme Kuralları // Yaygın kullanılan generic tip isimleri: // T: Type (Genel tip parametresi) // K: Key (Anahtar tipi) // V: Value (Değer tipi) // E: Element (Eleman tipi) // P: Properties (Özellik tipi) Tip Kısıtlamalarını Doğru Kullanma // İyi kullanım interface HasId { id: number; } function getById\u0026lt;T extends HasId\u0026gt;(items: T[], id: number): T | undefined { return items.find((item) =\u0026gt; item.id === id); } Generic Constraint vs Union Types // Generic constraint kullanımı function process\u0026lt;T extends string | number\u0026gt;(value: T): T { return value; } // Union type kullanımı function process2(value: string | number): string | number { return value; } // Generic constraint daha güvenli ve tip bilgisini korur Generic\u0026rsquo;leri Basit Tutun // Karmaşık function processData\u0026lt;T, U, V, W\u0026gt;( data: T[], transformer: (item: T) =\u0026gt; U, validator: (transformed: U) =\u0026gt; V, formatter: (validated: V) =\u0026gt; W ): W[] { // ... } // Daha iyi - Ara tipler için ayrı interface\u0026#39;ler kullan interface DataProcessor\u0026lt;T, R\u0026gt; { transform(item: T): R; } function processData\u0026lt;T, R\u0026gt;(data: T[], processor: DataProcessor\u0026lt;T, R\u0026gt;): R[] { return data.map((item) =\u0026gt; processor.transform(item)); } Generic\u0026rsquo;lerle Arrow Functions TypeScript\u0026rsquo;te generic\u0026rsquo;leri arrow function\u0026rsquo;larla kullanırken dikkat etmemiz gereken bazı syntax özellikleri vardır:\n// Standart generic arrow function const identity = (arg: T): T =\u0026gt; arg; // React ile kullanırken TSX çakışmasını önlemek için const identity = (arg: T): T =\u0026gt; arg; // Çoklu tip parametreli arrow function const pair = (first: T, second: U): [T, U] =\u0026gt; [first, second]; Generic\u0026rsquo;lerle Asenkron İşlemler Modern web uygulamalarında asenkron işlemler çok yaygın. Generic\u0026rsquo;ler bu konuda da yardımcımız olabilir:\n// Generic async fonksiyon async function fetchData(url: string): Promise { const response = await fetch(url); return response.json(); } // Kullanım interface User { id: number; name: string; email: string; } // Tip güvenli API çağrısı const user = await fetchData(\u0026#39;/api/user/1\u0026#39;); console.log(user.name); // Tip güvenli erişim // Generic error handling interface APIError { code: number; message: string; } async function fetchWithError(): Promise { try { const response = await fetch(\u0026#39;/api/data\u0026#39;); if (!response.ok) { throw (await response.json()) as APIError; } return response.json(); } catch (error) { throw error as APIError; } } Generics ile Utility Types TypeScript\u0026rsquo;in yerleşik utility type\u0026rsquo;ları da generic yapıları kullanır. İşte sık kullanılan örnekler:\n// Partial - Tüm özellikleri opsiyonel yapar interface User { id: number; name: string; email: string; } type PartialUser = Partial; // { id?: number; name?: string; email?: string; } // Pick - Belirli özellikleri seçer type UserBasicInfo = Pick; // { name: string; email: string; } // Omit - Belirli özellikleri çıkarır type UserWithoutId = Omit; // { name: string; email: string; } // Record - Key-value yapısı oluşturur type UserRoles = Record; // { [key: string]: string[] } Generic Tip Çıkarımında İleri Konular TypeScript\u0026rsquo;in tip çıkarım sistemi oldukça gelişmiştir. İşte bazı ileri seviye örnekler:\n// Return type çıkarımı function createPair(first: T) { return { first, second: first, }; } // TypeScript otomatik olarak { first: T, second: T } tipini çıkarır // Generic constraints ile tip çıkarımı interface HasLength { length: number; } function longest(a: T, b: T): T { return a.length \u0026gt;= b.length ? a : b; } // TypeScript string[] ve string için ayrı çıkarımlar yapar const longerArray = longest([1, 2], [1, 2, 3]); // type: number[] const longerString = longest(\u0026#39;123\u0026#39;, \u0026#39;12345\u0026#39;); // type: string Generic Type Alias vs Interface Generic yapıları type alias ve interface ile kullanırken bazı farklılıklar vardır:\n// Generic type alias type Container = { value: T; tag: string; }; // Generic interface interface Box { value: T; tag: string; } // İkisi de benzer şekilde kullanılır const numberContainer: Container = { value: 42, tag: \u0026#39;sayı\u0026#39; }; const stringBox: Box = { value: \u0026#39;test\u0026#39;, tag: \u0026#39;metin\u0026#39; }; // Interface\u0026#39;ler extends edilebilir interface LabeledBox extends Box { label: string; } // Type alias\u0026#39;lar intersection type ile genişletilebilir type LabeledContainer = Container \u0026amp; { label: string; }; Önemli Noktalar ve İpuçları Generic Constraint\u0026rsquo;leri İyi Düşünün\nÇok geniş constraint\u0026rsquo;ler tip güvenliğini azaltır Çok dar constraint\u0026rsquo;ler yeniden kullanılabilirliği azaltır Tip İnference\u0026rsquo;a Güvenin\nTypeScript çoğu durumda doğru tipi çıkarabilir Generic tipleri gereksiz yere açıkça belirtmeyin Okunabilirliği Koruyun\nGeneric tip isimleri anlamlı olsun Çok fazla tip parametresinden kaçının Karmaşık generic yapıları daha küçük parçalara bölün Sonuç Generic\u0026rsquo;ler, TypeScript\u0026rsquo;in en güçlü özelliklerinden biridir. Doğru kullanıldığında:\nKod tekrarını azaltır Tip güvenliğini artırır Yeniden kullanılabilir ve esnek kod yazmanızı sağlar Daha iyi IDE desteği sunar Özellikle büyük projelerde ve kütüphane geliştirirken generic\u0026rsquo;lerin gücünden maksimum fayda sağlayabilirsiniz. Generic\u0026rsquo;leri anlamak ve etkili kullanmak, TypeScript ile geliştirme yaparken vazgeçilmez bir beceridir.\nBir sonraki yazımızda TypeScript\u0026rsquo;in diğer ileri seviye özelliklerini inceleyeceğiz. Görüşmek üzere!\n",
    "tags": ["typescript","generics","type-safety"],
    "categories": ["TypeScript"],
    "lang": "tr"
} 