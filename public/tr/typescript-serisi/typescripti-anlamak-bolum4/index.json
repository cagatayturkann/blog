{
    "title": "TypeScript'i Anlamak - BÃ¶lÃ¼m 4: Interfaces",
    "permalink": "/blog/tr/typescript-serisi/typescripti-anlamak-bolum4/",
    "summary": "Bu yazÄ±da, TypeScript\u0026rsquo;in Ã¶nemli Ã¶zelliklerinden biri olan interface\u0026rsquo;leri detaylÄ± bir ÅŸekilde inceleyeceÄŸiz. Type Aliases ile farklarÄ±nÄ± anlayacak ve pratik kullanÄ±m senaryolarÄ±nÄ± Ã¶ÄŸreneceÄŸiz.",
    "content": "Merhaba! TypeScript serimizin bu bÃ¶lÃ¼mÃ¼nde, tip sisteminin en gÃ¼Ã§lÃ¼ Ã¶zelliklerinden biri olan interface\u0026rsquo;leri detaylÄ± bir ÅŸekilde inceleyeceÄŸiz. Interface\u0026rsquo;lerin ne olduÄŸunu, neden kullanmamÄ±z gerektiÄŸini ve gerÃ§ek dÃ¼nya uygulamalarÄ±nda nasÄ±l fayda saÄŸladÄ±ÄŸÄ±nÄ± Ã¶ÄŸreneceÄŸiz.\nInterface Nedir ve Neden KullanmalÄ±yÄ±z? Interface\u0026rsquo;ler, TypeScript\u0026rsquo;te objelerin yapÄ±sÄ±nÄ± tanÄ±mlamamÄ±zÄ± saÄŸlayan bir Ã¶zelliktir. Bilale anlatÄ±r gibi sÃ¶ylersek:\n\u0026ldquo;DÃ¼ÅŸÃ¼n ki bir inÅŸaat planÄ± Ã§iziyorsun. Bu planda binanÄ±n kaÃ§ katÄ± olacaÄŸÄ±, odalarÄ±n boyutlarÄ±, pencerelerin yerleri gibi detaylar var. Interface de aynÄ± bunun gibi - bir objenin \u0026lsquo;planÄ±nÄ±\u0026rsquo; Ã§iziyor. Hangi Ã¶zellikleri olacak, bu Ã¶zellikler hangi tipte olacak, hepsini Ã¶nceden belirliyoruz.\u0026rdquo;\nÄ°ÅŸte basit bir Ã¶rnek:\n// Basit bir interface tanÄ±mÄ± interface Kullanici { // Zorunlu Ã¶zellikler id: number; // KullanÄ±cÄ±nÄ±n benzersiz numarasÄ± ad: string; // KullanÄ±cÄ±nÄ±n adÄ± email: string; // E-posta adresi // Opsiyonel Ã¶zellikler (? iÅŸareti ile belirtilir) telefon?: string; // Telefon numarasÄ± (opsiyonel) yas?: number; // YaÅŸ bilgisi (opsiyonel) } // Interface\u0026#39;i kullanma const yeniKullanici: Kullanici = { id: 1, ad: \u0026#39;Ahmet YÄ±lmaz\u0026#39;, email: \u0026#39;ahmet@ornek.com\u0026#39;, // telefon ve yas opsiyonel olduÄŸu iÃ§in yazmak zorunda deÄŸiliz }; // TypeScript burada bizi korur const hataliKullanici: Kullanici = { id: \u0026#39;1\u0026#39;, // Hata! string bir deÄŸer number tipine atanamaz ad: \u0026#39;Mehmet\u0026#39;, email: true, // Hata! boolean bir deÄŸer string tipine atanamaz }; Interface KullanmanÄ±n AvantajlarÄ± Kod GÃ¼venliÄŸi: // Interface ile tanÄ±mlanmÄ±ÅŸ fonksiyon function kullaniciGuncelle(id: number, kullanici: Kullanici) { // TypeScript sayesinde kullanici objesinin yapÄ±sÄ±ndan eminiz console.log(`${kullanici.ad} gÃ¼ncelleniyor...`); // ... gÃ¼ncelleme iÅŸlemleri } // Bu Ã§alÄ±ÅŸÄ±r kullaniciGuncelle(1, { id: 1, ad: \u0026#39;Ahmet\u0026#39;, email: \u0026#39;ahmet@ornek.com\u0026#39;, }); // Bu hata verir - eksik ve yanlÄ±ÅŸ Ã¶zellikler kullaniciGuncelle(1, { id: 1, isim: \u0026#39;Ahmet\u0026#39;, // Hata! \u0026#39;isim\u0026#39; yerine \u0026#39;ad\u0026#39; olmalÄ± }); Kod Tamamlama: Interface\u0026rsquo;ler IDE\u0026rsquo;nizin kod tamamlama Ã¶zelliÄŸini gÃ¼Ã§lendirir. Bir objenin Ã¶zelliklerine eriÅŸirken, IDE size mevcut tÃ¼m Ã¶zellikleri gÃ¶sterir.\nDokÃ¼mantasyon: Interface\u0026rsquo;ler aynÄ± zamanda bir dokÃ¼mantasyon gÃ¶revi gÃ¶rÃ¼r. Kodunuzu okuyan diÄŸer geliÅŸtiriciler, bir objenin yapÄ±sÄ±nÄ± hÄ±zlÄ±ca anlayabilir.\nInterface vs Type: FarklarÄ± Anlamak Interface ve Type arasÄ±ndaki farklarÄ± gerÃ§ek Ã¶rneklerle inceleyelim:\n1. Declaration Merging (Bildirimleri BirleÅŸtirme) // Interface\u0026#39;de bildirim birleÅŸtirme mÃ¼mkÃ¼n interface Araba { marka: string; } interface Araba { // AynÄ± isimle yeni Ã¶zellikler ekleyebiliriz model: string; } const tesla: Araba = { marka: \u0026#39;Tesla\u0026#39;, // Her iki interface\u0026#39;den gelen model: \u0026#39;Model 3\u0026#39;, // Ã¶zellikler gerekli }; // Type\u0026#39;da bu mÃ¼mkÃ¼n deÄŸil type Bisiklet = { marka: string; }; // Hata! \u0026#39;Bisiklet\u0026#39; identifier\u0026#39;Ä± zaten tanÄ±mlÄ± type Bisiklet = { model: string; }; Bu Ã¶zellik Ã¶zellikle kÃ¼tÃ¼phane geliÅŸtirirken Ã§ok faydalÄ±dÄ±r. KullanÄ±cÄ±lar mevcut interface\u0026rsquo;lere yeni Ã¶zellikler ekleyebilir.\n2. Extends ve Implements Interface\u0026rsquo;ler, nesne yÃ¶nelimli programlamada Ã§ok kullanÄ±ÅŸlÄ±dÄ±r:\n// Temel interface interface Hayvan { isim: string; tur: string; sesCikar(): void; } // Interface\u0026#39;den tÃ¼retme interface Kedi extends Hayvan { patiliMi: boolean; tirmanabilir: boolean; } // Class\u0026#39;larda kullanÄ±m class TekirkKedisi implements Kedi { // TÃ¼m Ã¶zellikleri ve metodlarÄ± implemente etmeliyiz isim: string; tur: string = \u0026#39;Kedi\u0026#39;; patiliMi: boolean = true; tirmanabilir: boolean = true; constructor(isim: string) { this.isim = isim; } sesCikar() { console.log(\u0026#39;Miyav!\u0026#39;); } } Interface MetodlarÄ± ve Ã–zellikler Interface\u0026rsquo;ler sadece veri yapÄ±sÄ±nÄ± deÄŸil, nesnelerin davranÄ±ÅŸlarÄ±nÄ± da tanÄ±mlayabilir. GerÃ§ek bir Ã¶rnek Ã¼zerinden ilerleyelim:\n// E-ticaret sisteminde Ã¼rÃ¼n yÃ¶netimi iÃ§in interface interface UrunYonetimi { // Temel CRUD operasyonlarÄ± urunEkle(urun: Urun): Promise\u0026lt;boolean\u0026gt;; urunGuncelle(id: string, urun: Urun): Promise\u0026lt;boolean\u0026gt;; urunSil(id: string): Promise\u0026lt;boolean\u0026gt;; urunGetir(id: string): Promise\u0026lt;Urun | null\u0026gt;; // Stok yÃ¶netimi metodlarÄ± stokGuncelle(urunId: string, miktar: number): Promise\u0026lt;void\u0026gt;; stokKontrol(urunId: string): Promise\u0026lt;number\u0026gt;; // Ä°statistik metodlarÄ± satisRaporuOlustur(baslangic: Date, bitis: Date): Promise\u0026lt;SatisRaporu\u0026gt;; } // Bu interface\u0026#39;i kullanan bir class class PostgreSQLUrunYonetimi implements UrunYonetimi { constructor(private db: Database) {} async urunEkle(urun: Urun): Promise\u0026lt;boolean\u0026gt; { try { await this.db.query(\u0026#39;INSERT INTO urunler (id, ad, fiyat, stok) VALUES ($1, $2, $3, $4)\u0026#39;, [ urun.id, urun.ad, urun.fiyat, urun.stok, ]); return true; } catch (error) { console.error(\u0026#39;ÃœrÃ¼n eklenirken hata:\u0026#39;, error); return false; } } // DiÄŸer metodlarÄ±n implementasyonu... } Readonly ve Optional Ã–zellikler Interface\u0026rsquo;lerde bazÄ± Ã¶zellikleri salt okunur (readonly) veya opsiyonel yapabiliriz. Ä°ÅŸte gerÃ§ek bir senaryo:\n// KullanÄ±cÄ± profili iÃ§in interface interface KullaniciProfili { // Salt okunur Ã¶zellikler (deÄŸiÅŸtirilemez) readonly id: string; // KullanÄ±cÄ± ID\u0026#39;si asla deÄŸiÅŸmez readonly kayitTarihi: Date; // KayÄ±t tarihi deÄŸiÅŸtirilemez // Zorunlu Ã¶zellikler email: string; // E-posta adresi ad: string; // KullanÄ±cÄ± adÄ± // Opsiyonel Ã¶zellikler telefon?: string; // Telefon numarasÄ± adres?: { // Adres bilgileri sehir: string; ilce: string; postaKodu?: string; }; profilResmi?: string; // Profil resmi URL\u0026#39;i // Sosyal medya bilgileri (hepsi opsiyonel) sosyalMedya?: { twitter?: string; linkedin?: string; github?: string; }; } // KullanÄ±m Ã¶rneÄŸi const yeniProfil: KullaniciProfili = { id: \u0026#39;usr_123\u0026#39;, // readonly olduÄŸu iÃ§in sadece ilk atamada deÄŸer verebiliriz kayitTarihi: new Date(), // readonly olduÄŸu iÃ§in sadece ilk atamada deÄŸer verebiliriz email: \u0026#39;ali@ornek.com\u0026#39;, ad: \u0026#39;Ali YÄ±lmaz\u0026#39;, // Opsiyonel alanlarÄ± eklemek zorunda deÄŸiliz }; // HATALI KULLANIM - readonly Ã¶zellikleri deÄŸiÅŸtiremeyiz yeniProfil.id = \u0026#39;usr_456\u0026#39;; // Hata! readonly Ã¶zellik deÄŸiÅŸtirilemez yeniProfil.kayitTarihi = new Date(); // Hata! readonly Ã¶zellik deÄŸiÅŸtirilemez // Opsiyonel Ã¶zellikleri sonradan ekleyebiliriz yeniProfil.telefon = \u0026#39;555-0123\u0026#39;; yeniProfil.adres = { sehir: \u0026#39;Ä°stanbul\u0026#39;, ilce: \u0026#39;KadÄ±kÃ¶y\u0026#39;, }; Generic Interface\u0026rsquo;ler Generic\u0026rsquo;ler, interface\u0026rsquo;leri daha esnek ve yeniden kullanÄ±labilir hale getirir. Ã–rneÄŸin, bir API yanÄ±t yapÄ±sÄ± iÃ§in generic interface:\n// Generic API yanÄ±t interface\u0026#39;i interface APIResponse\u0026lt;T\u0026gt; { success: boolean; // Ä°ÅŸlem baÅŸarÄ±lÄ± mÄ±? data: T; // Generic veri tipi timestamp: number; // Ä°ÅŸlem zamanÄ± statusCode: number; // HTTP durum kodu message?: string; // Opsiyonel mesaj errors?: string[]; // Varsa hata mesajlarÄ± } // FarklÄ± veri tipleri iÃ§in kullanÄ±m interface Kullanici { id: number; ad: string; email: string; } interface Urun { id: number; ad: string; fiyat: number; } // KullanÄ±cÄ± listesi iÃ§in API yanÄ±tÄ± const kullanicilarYanit: APIResponse\u0026lt;Kullanici[]\u0026gt; = { success: true, data: [ { id: 1, ad: \u0026#39;Ahmet\u0026#39;, email: \u0026#39;ahmet@ornek.com\u0026#39; }, { id: 2, ad: \u0026#39;Mehmet\u0026#39;, email: \u0026#39;mehmet@ornek.com\u0026#39; }, ], timestamp: Date.now(), statusCode: 200, }; // Tek bir Ã¼rÃ¼n iÃ§in API yanÄ±tÄ± const urunYanit: APIResponse\u0026lt;Urun\u0026gt; = { success: false, data: { id: 0, ad: \u0026#39;\u0026#39;, fiyat: 0 }, // BoÅŸ Ã¼rÃ¼n timestamp: Date.now(), statusCode: 404, message: \u0026#39;ÃœrÃ¼n bulunamadÄ±\u0026#39;, errors: [\u0026#34;Belirtilen ID\u0026#39;ye sahip Ã¼rÃ¼n mevcut deÄŸil\u0026#34;], }; Interface Inheritance (KalÄ±tÄ±m) Interface\u0026rsquo;ler birbirinden tÃ¼reyebilir. Bu Ã¶zellik, kod tekrarÄ±nÄ± Ã¶nler ve modÃ¼ler bir yapÄ± oluÅŸturmamÄ±zÄ± saÄŸlar:\n// Temel varlÄ±k Ã¶zellikleri interface Varlik { id: string; // Benzersiz tanÄ±mlayÄ±cÄ± olusturmaTarihi: Date; // OluÅŸturulma tarihi guncellemeTarihi: Date; // Son gÃ¼ncelleme tarihi silindi: boolean; // Silinme durumu } // Temel kiÅŸi bilgileri interface Kisi extends Varlik { ad: string; soyad: string; email: string; telefon?: string; } // Ã–ÄŸrenci bilgileri interface Ogrenci extends Kisi { ogrenciNo: string; bolum: string; sinif: number; dersler: string[]; notOrtalamasi?: number; } // Ã–ÄŸretmen bilgileri interface Ogretmen extends Kisi { sicilNo: string; brans: string; verdigiDersler: string[]; maas: number; } // KullanÄ±m Ã¶rneÄŸi const yeniOgrenci: Ogrenci = { // Varlik\u0026#39;ten gelen Ã¶zellikler id: \u0026#39;ogr_123\u0026#39;, olusturmaTarihi: new Date(), guncellemeTarihi: new Date(), silindi: false, // Kisi\u0026#39;den gelen Ã¶zellikler ad: \u0026#39;Ali\u0026#39;, soyad: \u0026#39;YÄ±lmaz\u0026#39;, email: \u0026#39;ali@okul.edu.tr\u0026#39;, // Ogrenci\u0026#39;ye Ã¶zel Ã¶zellikler ogrenciNo: \u0026#39;2024001\u0026#39;, bolum: \u0026#39;Bilgisayar MÃ¼hendisliÄŸi\u0026#39;, sinif: 2, dersler: [\u0026#39;Algoritma\u0026#39;, \u0026#39;Veri YapÄ±larÄ±\u0026#39;, \u0026#39;TypeScript 101\u0026#39;], }; Interface\u0026rsquo;lerin YaygÄ±n KullanÄ±m AlanlarÄ± Interface\u0026rsquo;ler yazÄ±lÄ±m geliÅŸtirmenin birÃ§ok alanÄ±nda karÅŸÄ±mÄ±za Ã§Ä±kar. Ä°ÅŸte en yaygÄ±n kullanÄ±m alanlarÄ±:\n1. API Ä°letiÅŸimi API\u0026rsquo;lerle Ã§alÄ±ÅŸÄ±rken, gelen ve giden veri yapÄ±larÄ±nÄ± tanÄ±mlamak iÃ§in interface\u0026rsquo;leri kullanÄ±rÄ±z. Ã–rneÄŸin:\n// API\u0026#39;den gelecek kullanÄ±cÄ± verisinin yapÄ±sÄ± interface KullaniciYaniti { id: number; ad: string; email: string; rol: \u0026#39;admin\u0026#39; | \u0026#39;kullanici\u0026#39;; sonGiris?: Date; } // API\u0026#39;ye gÃ¶nderilecek giriÅŸ bilgileri interface GirisBilgileri { email: string; sifre: string; hatirla?: boolean; } 2. VeritabanÄ± Ä°ÅŸlemleri VeritabanÄ± iÅŸlemlerinde, tablo yapÄ±larÄ±nÄ± ve sorgu sonuÃ§larÄ±nÄ± modellemek iÃ§in interface\u0026rsquo;leri kullanÄ±rÄ±z:\ninterface Urun { id: number; // ÃœrÃ¼n benzersiz numarasÄ± ad: string; // ÃœrÃ¼n adÄ± fiyat: number; // ÃœrÃ¼n fiyatÄ± stok: number; // Stok miktarÄ± kategori: string; // ÃœrÃ¼n kategorisi } 3. Form YÃ¶netimi Form verilerinin yapÄ±sÄ±nÄ± ve doÄŸrulama kurallarÄ±nÄ± tanÄ±mlarken interface\u0026rsquo;ler iÅŸimizi kolaylaÅŸtÄ±rÄ±r:\ninterface KayitFormu { email: string; // KullanÄ±cÄ± e-postasÄ± sifre: string; // Åifre sifreTekrar: string; // Åifre tekrarÄ± kullaniciAdi: string; // KullanÄ±cÄ± adÄ± } 4. YapÄ±landÄ±rma YÃ¶netimi Uygulama ayarlarÄ±nÄ± ve yapÄ±landÄ±rmalarÄ±nÄ± tanÄ±mlarken interface\u0026rsquo;leri kullanÄ±rÄ±z:\ninterface UygulamaAyarlari { apiUrl: string; // API sunucu adresi maxDeneme: number; // Maximum deneme sayÄ±sÄ± timeout: number; // Zaman aÅŸÄ±mÄ± sÃ¼resi debug: boolean; // Debug modu aÃ§Ä±k/kapalÄ± } 5. Veri Modelleri UygulamamÄ±zdaki temel veri yapÄ±larÄ±nÄ± tanÄ±mlarken interface\u0026rsquo;lerden faydalanÄ±rÄ±z:\ninterface Siparis { id: string; // SipariÅŸ numarasÄ± musteriId: string; // MÃ¼ÅŸteri numarasÄ± urunler: string[]; // SipariÅŸteki Ã¼rÃ¼nler toplamTutar: number; // Toplam tutar durum: \u0026#39;beklemede\u0026#39; | \u0026#39;onaylandi\u0026#39; | \u0026#39;iptal\u0026#39;; // SipariÅŸ durumu } Bu kullanÄ±m alanlarÄ±, interface\u0026rsquo;lerin tip gÃ¼venliÄŸi ve kod organizasyonu aÃ§Ä±sÄ±ndan ne kadar Ã¶nemli olduÄŸunu gÃ¶sterir. Her bir alanda interface\u0026rsquo;ler, kodumuzun daha gÃ¼venli ve bakÄ±mÄ± kolay olmasÄ±nÄ± saÄŸlar.\nBest Practices ve Ä°puÃ§larÄ± TypeScript interface\u0026rsquo;lerini kullanÄ±rken dikkat etmemiz gereken bazÄ± Ã¶nemli noktalar var. Bu pratikleri uygulayarak daha okunabilir ve bakÄ±mÄ± kolay kod yazabiliriz.\n1. Ä°simlendirme KurallarÄ± Interface isimleri, ne iÅŸ yaptÄ±klarÄ±nÄ± aÃ§Ä±kÃ§a belirtmeli ve bazÄ± standartlara uymalÄ±:\n// âœ… Ä°yi Ä°simlendirme Ã–rnekleri interface KullaniciServisi { kullaniciGetir(id: string): Promise\u0026lt;Kullanici\u0026gt;; } interface UrunDeposu { stokGuncelle(urunId: string, miktar: number): void; } // âŒ KaÃ§Ä±nÄ±lmasÄ± Gereken Ä°simlendirmeler interface IKullanici { // \u0026#39;I\u0026#39; Ã¶neki kullanmayÄ±n // ... } interface veriYoneticisi { // PascalCase kullanÄ±n // ... } interface DATA_SERVICE { // BÃœYÃœK HARF kullanmayÄ±n // ... } 2. Tek Sorumluluk Prensibi Her interface tek bir iÅŸe odaklanmalÄ± ve o iÅŸi iyi yapmalÄ±:\n// âœ… Ä°yi TasarlanmÄ±ÅŸ Interface\u0026#39;ler interface KimlikBilgileri { id: string; tcKimlikNo: string; pasaportNo?: string; } interface IletisimBilgileri { email: string; telefon?: string; adres?: { il: string; ilce: string; }; } // Ä°htiyaÃ§ halinde birleÅŸtirin interface Kullanici extends KimlikBilgileri, IletisimBilgileri { ad: string; soyad: string; } // âŒ KaÃ§Ä±nÄ±lmasÄ± Gereken Durum: Her ÅŸeyi tek interface\u0026#39;de toplamak interface KocamanInterface { // Kimlik bilgileri id: string; tcKimlikNo: string; // Ä°letiÅŸim bilgileri email: string; telefon: string; // Adres bilgileri il: string; ilce: string; // KullanÄ±cÄ± bilgileri ad: string; soyad: string; // DiÄŸer bilgiler... // ... ve daha birÃ§ok Ã¶zellik } 3. AÃ§Ä±klayÄ±cÄ± Yorumlar Ekleme Interface\u0026rsquo;lerin nasÄ±l kullanÄ±lacaÄŸÄ±nÄ± aÃ§Ä±kÃ§a belirten yorumlar ekleyin:\n/** * Ã–deme iÅŸlemi sÄ±rasÄ±nda kullanÄ±lacak kart bilgileri. * Bu interface sadece Ã¶deme iÅŸlemi sÄ±rasÄ±nda kullanÄ±lmalÄ± ve * hassas bilgiler iÅŸlem sonrasÄ± bellekten temizlenmelidir. */ interface OdemeBilgileri { /** Ã–denecek tutar (TL cinsinden, kuruÅŸ hassasiyetinde) */ tutar: number; /** 16 haneli kart numarasÄ± */ kartNo: string; /** AA/YY formatÄ±nda son kullanma tarihi (Ã¶rnek: 12/25) */ sonKullanmaTarihi: string; /** KartÄ±n arkasÄ±ndaki 3 haneli gÃ¼venlik kodu */ guvenlikKodu: string; } 4. Opsiyonel Ã–zellikleri DoÄŸru Kullanma Opsiyonel Ã¶zellikleri kullanÄ±rken dikkatli olun ve belgelendirin:\ninterface KullaniciProfili { // Zorunlu alanlar id: string; ad: string; email: string; // Opsiyonel alanlar - neden opsiyonel olduklarÄ±nÄ± aÃ§Ä±klayÄ±n /** KullanÄ±cÄ± telefon vermek istemeyebilir */ telefon?: string; /** Profil fotoÄŸrafÄ± yÃ¼klenmemiÅŸse varsayÄ±lan kullanÄ±lÄ±r */ profilFotoUrl?: string; /** KullanÄ±cÄ± henÃ¼z konum izni vermemiÅŸ olabilir */ konum?: { lat: number; lng: number; }; } SonuÃ§ Interface\u0026rsquo;ler, TypeScript\u0026rsquo;in en gÃ¼Ã§lÃ¼ Ã¶zelliklerinden biridir ve doÄŸru kullanÄ±ldÄ±ÄŸÄ±nda:\nKodunuzu daha okunabilir hale getirir Tip gÃ¼venliÄŸi saÄŸlar BakÄ±mÄ± kolaylaÅŸtÄ±rÄ±r TakÄ±m Ã§alÄ±ÅŸmasÄ±nÄ± iyileÅŸtirir DokÃ¼mantasyon gÃ¶revi gÃ¶rÃ¼r Bu yazÄ±da gÃ¶rdÃ¼ÄŸÃ¼mÃ¼z Ã¶rnekler ve best practice\u0026rsquo;ler, gÃ¼nlÃ¼k TypeScript geliÅŸtirmelerinizde size yol gÃ¶sterecektir. Bir sonraki yazÄ±da gÃ¶rÃ¼ÅŸeceÄŸiz.\nSorularÄ±nÄ±z varsa yorum bÄ±rakabilirsiniz. Ä°yi kodlamalar! ğŸš€\n",
    "tags": ["typescript","interfaces","type-system"],
    "categories": ["TypeScript"],
    "lang": "tr"
} 