{
    "title": "TypeScript'i Anlamak - Bölüm 4: Interfaces",
    "permalink": "/blog/tr/typescript-serisi/typescripti-anlamak-bolum4/",
    "summary": "Bu yazıda, TypeScript\u0026rsquo;in önemli özelliklerinden biri olan interface\u0026rsquo;leri detaylı bir şekilde inceleyeceğiz. Type Aliases ile farklarını anlayacak ve pratik kullanım senaryolarını öğreneceğiz.",
    "content": "Merhaba! TypeScript serimizin bu bölümünde, tip sisteminin en güçlü özelliklerinden biri olan interface\u0026rsquo;leri detaylı bir şekilde inceleyeceğiz. Interface\u0026rsquo;lerin ne olduğunu, neden kullanmamız gerektiğini ve gerçek dünya uygulamalarında nasıl fayda sağladığını öğreneceğiz.\nInterface Nedir ve Neden Kullanmalıyız? Interface\u0026rsquo;ler, TypeScript\u0026rsquo;te objelerin yapısını tanımlamamızı sağlayan bir özelliktir. Bilale anlatır gibi söylersek:\n\u0026ldquo;Düşün ki bir inşaat planı çiziyorsun. Bu planda binanın kaç katı olacağı, odaların boyutları, pencerelerin yerleri gibi detaylar var. Interface de aynı bunun gibi - bir objenin \u0026lsquo;planını\u0026rsquo; çiziyor. Hangi özellikleri olacak, bu özellikler hangi tipte olacak, hepsini önceden belirliyoruz.\u0026rdquo;\nİşte basit bir örnek:\n// Basit bir interface tanımı interface Kullanici { // Zorunlu özellikler id: number; // Kullanıcının benzersiz numarası ad: string; // Kullanıcının adı email: string; // E-posta adresi // Opsiyonel özellikler (? işareti ile belirtilir) telefon?: string; // Telefon numarası (opsiyonel) yas?: number; // Yaş bilgisi (opsiyonel) } // Interface\u0026#39;i kullanma const yeniKullanici: Kullanici = { id: 1, ad: \u0026#39;Ahmet Yılmaz\u0026#39;, email: \u0026#39;ahmet@ornek.com\u0026#39;, // telefon ve yas opsiyonel olduğu için yazmak zorunda değiliz }; // TypeScript burada bizi korur const hataliKullanici: Kullanici = { id: \u0026#39;1\u0026#39;, // Hata! string bir değer number tipine atanamaz ad: \u0026#39;Mehmet\u0026#39;, email: true, // Hata! boolean bir değer string tipine atanamaz }; Interface Kullanmanın Avantajları Kod Güvenliği: // Interface ile tanımlanmış fonksiyon function kullaniciGuncelle(id: number, kullanici: Kullanici) { // TypeScript sayesinde kullanici objesinin yapısından eminiz console.log(`${kullanici.ad} güncelleniyor...`); // ... güncelleme işlemleri } // Bu çalışır kullaniciGuncelle(1, { id: 1, ad: \u0026#39;Ahmet\u0026#39;, email: \u0026#39;ahmet@ornek.com\u0026#39;, }); // Bu hata verir - eksik ve yanlış özellikler kullaniciGuncelle(1, { id: 1, isim: \u0026#39;Ahmet\u0026#39;, // Hata! \u0026#39;isim\u0026#39; yerine \u0026#39;ad\u0026#39; olmalı }); Kod Tamamlama: Interface\u0026rsquo;ler IDE\u0026rsquo;nizin kod tamamlama özelliğini güçlendirir. Bir objenin özelliklerine erişirken, IDE size mevcut tüm özellikleri gösterir.\nDokümantasyon: Interface\u0026rsquo;ler aynı zamanda bir dokümantasyon görevi görür. Kodunuzu okuyan diğer geliştiriciler, bir objenin yapısını hızlıca anlayabilir.\nInterface vs Type: Farkları Anlamak Interface ve Type arasındaki farkları gerçek örneklerle inceleyelim:\n1. Declaration Merging (Bildirimleri Birleştirme) // Interface\u0026#39;de bildirim birleştirme mümkün interface Araba { marka: string; } interface Araba { // Aynı isimle yeni özellikler ekleyebiliriz model: string; } const tesla: Araba = { marka: \u0026#39;Tesla\u0026#39;, // Her iki interface\u0026#39;den gelen model: \u0026#39;Model 3\u0026#39;, // özellikler gerekli }; // Type\u0026#39;da bu mümkün değil type Bisiklet = { marka: string; }; // Hata! \u0026#39;Bisiklet\u0026#39; identifier\u0026#39;ı zaten tanımlı type Bisiklet = { model: string; }; Bu özellik özellikle kütüphane geliştirirken çok faydalıdır. Kullanıcılar mevcut interface\u0026rsquo;lere yeni özellikler ekleyebilir.\n2. Extends ve Implements Interface\u0026rsquo;ler, nesne yönelimli programlamada çok kullanışlıdır:\n// Temel interface interface Hayvan { isim: string; tur: string; sesCikar(): void; } // Interface\u0026#39;den türetme interface Kedi extends Hayvan { patiliMi: boolean; tirmanabilir: boolean; } // Class\u0026#39;larda kullanım class TekirkKedisi implements Kedi { // Tüm özellikleri ve metodları implemente etmeliyiz isim: string; tur: string = \u0026#39;Kedi\u0026#39;; patiliMi: boolean = true; tirmanabilir: boolean = true; constructor(isim: string) { this.isim = isim; } sesCikar() { console.log(\u0026#39;Miyav!\u0026#39;); } } Interface Metodları ve Özellikler Interface\u0026rsquo;ler sadece veri yapısını değil, nesnelerin davranışlarını da tanımlayabilir. Gerçek bir örnek üzerinden ilerleyelim:\n// E-ticaret sisteminde ürün yönetimi için interface interface UrunYonetimi { // Temel CRUD operasyonları urunEkle(urun: Urun): Promise\u0026lt;boolean\u0026gt;; urunGuncelle(id: string, urun: Urun): Promise\u0026lt;boolean\u0026gt;; urunSil(id: string): Promise\u0026lt;boolean\u0026gt;; urunGetir(id: string): Promise\u0026lt;Urun | null\u0026gt;; // Stok yönetimi metodları stokGuncelle(urunId: string, miktar: number): Promise\u0026lt;void\u0026gt;; stokKontrol(urunId: string): Promise\u0026lt;number\u0026gt;; // İstatistik metodları satisRaporuOlustur(baslangic: Date, bitis: Date): Promise\u0026lt;SatisRaporu\u0026gt;; } // Bu interface\u0026#39;i kullanan bir class class PostgreSQLUrunYonetimi implements UrunYonetimi { constructor(private db: Database) {} async urunEkle(urun: Urun): Promise\u0026lt;boolean\u0026gt; { try { await this.db.query(\u0026#39;INSERT INTO urunler (id, ad, fiyat, stok) VALUES ($1, $2, $3, $4)\u0026#39;, [ urun.id, urun.ad, urun.fiyat, urun.stok, ]); return true; } catch (error) { console.error(\u0026#39;Ürün eklenirken hata:\u0026#39;, error); return false; } } // Diğer metodların implementasyonu... } Readonly ve Optional Özellikler Interface\u0026rsquo;lerde bazı özellikleri salt okunur (readonly) veya opsiyonel yapabiliriz. İşte gerçek bir senaryo:\n// Kullanıcı profili için interface interface KullaniciProfili { // Salt okunur özellikler (değiştirilemez) readonly id: string; // Kullanıcı ID\u0026#39;si asla değişmez readonly kayitTarihi: Date; // Kayıt tarihi değiştirilemez // Zorunlu özellikler email: string; // E-posta adresi ad: string; // Kullanıcı adı // Opsiyonel özellikler telefon?: string; // Telefon numarası adres?: { // Adres bilgileri sehir: string; ilce: string; postaKodu?: string; }; profilResmi?: string; // Profil resmi URL\u0026#39;i // Sosyal medya bilgileri (hepsi opsiyonel) sosyalMedya?: { twitter?: string; linkedin?: string; github?: string; }; } // Kullanım örneği const yeniProfil: KullaniciProfili = { id: \u0026#39;usr_123\u0026#39;, // readonly olduğu için sadece ilk atamada değer verebiliriz kayitTarihi: new Date(), // readonly olduğu için sadece ilk atamada değer verebiliriz email: \u0026#39;ali@ornek.com\u0026#39;, ad: \u0026#39;Ali Yılmaz\u0026#39;, // Opsiyonel alanları eklemek zorunda değiliz }; // HATALI KULLANIM - readonly özellikleri değiştiremeyiz yeniProfil.id = \u0026#39;usr_456\u0026#39;; // Hata! readonly özellik değiştirilemez yeniProfil.kayitTarihi = new Date(); // Hata! readonly özellik değiştirilemez // Opsiyonel özellikleri sonradan ekleyebiliriz yeniProfil.telefon = \u0026#39;555-0123\u0026#39;; yeniProfil.adres = { sehir: \u0026#39;İstanbul\u0026#39;, ilce: \u0026#39;Kadıköy\u0026#39;, }; Generic Interface\u0026rsquo;ler Generic\u0026rsquo;ler, interface\u0026rsquo;leri daha esnek ve yeniden kullanılabilir hale getirir. Örneğin, bir API yanıt yapısı için generic interface:\n// Generic API yanıt interface\u0026#39;i interface APIResponse\u0026lt;T\u0026gt; { success: boolean; // İşlem başarılı mı? data: T; // Generic veri tipi timestamp: number; // İşlem zamanı statusCode: number; // HTTP durum kodu message?: string; // Opsiyonel mesaj errors?: string[]; // Varsa hata mesajları } // Farklı veri tipleri için kullanım interface Kullanici { id: number; ad: string; email: string; } interface Urun { id: number; ad: string; fiyat: number; } // Kullanıcı listesi için API yanıtı const kullanicilarYanit: APIResponse\u0026lt;Kullanici[]\u0026gt; = { success: true, data: [ { id: 1, ad: \u0026#39;Ahmet\u0026#39;, email: \u0026#39;ahmet@ornek.com\u0026#39; }, { id: 2, ad: \u0026#39;Mehmet\u0026#39;, email: \u0026#39;mehmet@ornek.com\u0026#39; }, ], timestamp: Date.now(), statusCode: 200, }; // Tek bir ürün için API yanıtı const urunYanit: APIResponse\u0026lt;Urun\u0026gt; = { success: false, data: { id: 0, ad: \u0026#39;\u0026#39;, fiyat: 0 }, // Boş ürün timestamp: Date.now(), statusCode: 404, message: \u0026#39;Ürün bulunamadı\u0026#39;, errors: [\u0026#34;Belirtilen ID\u0026#39;ye sahip ürün mevcut değil\u0026#34;], }; Interface Inheritance (Kalıtım) Interface\u0026rsquo;ler birbirinden türeyebilir. Bu özellik, kod tekrarını önler ve modüler bir yapı oluşturmamızı sağlar:\n// Temel varlık özellikleri interface Varlik { id: string; // Benzersiz tanımlayıcı olusturmaTarihi: Date; // Oluşturulma tarihi guncellemeTarihi: Date; // Son güncelleme tarihi silindi: boolean; // Silinme durumu } // Temel kişi bilgileri interface Kisi extends Varlik { ad: string; soyad: string; email: string; telefon?: string; } // Öğrenci bilgileri interface Ogrenci extends Kisi { ogrenciNo: string; bolum: string; sinif: number; dersler: string[]; notOrtalamasi?: number; } // Öğretmen bilgileri interface Ogretmen extends Kisi { sicilNo: string; brans: string; verdigiDersler: string[]; maas: number; } // Kullanım örneği const yeniOgrenci: Ogrenci = { // Varlik\u0026#39;ten gelen özellikler id: \u0026#39;ogr_123\u0026#39;, olusturmaTarihi: new Date(), guncellemeTarihi: new Date(), silindi: false, // Kisi\u0026#39;den gelen özellikler ad: \u0026#39;Ali\u0026#39;, soyad: \u0026#39;Yılmaz\u0026#39;, email: \u0026#39;ali@okul.edu.tr\u0026#39;, // Ogrenci\u0026#39;ye özel özellikler ogrenciNo: \u0026#39;2024001\u0026#39;, bolum: \u0026#39;Bilgisayar Mühendisliği\u0026#39;, sinif: 2, dersler: [\u0026#39;Algoritma\u0026#39;, \u0026#39;Veri Yapıları\u0026#39;, \u0026#39;TypeScript 101\u0026#39;], }; Interface\u0026rsquo;lerin Yaygın Kullanım Alanları Interface\u0026rsquo;ler yazılım geliştirmenin birçok alanında karşımıza çıkar. İşte en yaygın kullanım alanları:\n1. API İletişimi API\u0026rsquo;lerle çalışırken, gelen ve giden veri yapılarını tanımlamak için interface\u0026rsquo;leri kullanırız. Örneğin:\n// API\u0026#39;den gelecek kullanıcı verisinin yapısı interface KullaniciYaniti { id: number; ad: string; email: string; rol: \u0026#39;admin\u0026#39; | \u0026#39;kullanici\u0026#39;; sonGiris?: Date; } // API\u0026#39;ye gönderilecek giriş bilgileri interface GirisBilgileri { email: string; sifre: string; hatirla?: boolean; } 2. Veritabanı İşlemleri Veritabanı işlemlerinde, tablo yapılarını ve sorgu sonuçlarını modellemek için interface\u0026rsquo;leri kullanırız:\ninterface Urun { id: number; // Ürün benzersiz numarası ad: string; // Ürün adı fiyat: number; // Ürün fiyatı stok: number; // Stok miktarı kategori: string; // Ürün kategorisi } 3. Form Yönetimi Form verilerinin yapısını ve doğrulama kurallarını tanımlarken interface\u0026rsquo;ler işimizi kolaylaştırır:\ninterface KayitFormu { email: string; // Kullanıcı e-postası sifre: string; // Şifre sifreTekrar: string; // Şifre tekrarı kullaniciAdi: string; // Kullanıcı adı } 4. Yapılandırma Yönetimi Uygulama ayarlarını ve yapılandırmalarını tanımlarken interface\u0026rsquo;leri kullanırız:\ninterface UygulamaAyarlari { apiUrl: string; // API sunucu adresi maxDeneme: number; // Maximum deneme sayısı timeout: number; // Zaman aşımı süresi debug: boolean; // Debug modu açık/kapalı } 5. Veri Modelleri Uygulamamızdaki temel veri yapılarını tanımlarken interface\u0026rsquo;lerden faydalanırız:\ninterface Siparis { id: string; // Sipariş numarası musteriId: string; // Müşteri numarası urunler: string[]; // Siparişteki ürünler toplamTutar: number; // Toplam tutar durum: \u0026#39;beklemede\u0026#39; | \u0026#39;onaylandi\u0026#39; | \u0026#39;iptal\u0026#39;; // Sipariş durumu } Bu kullanım alanları, interface\u0026rsquo;lerin tip güvenliği ve kod organizasyonu açısından ne kadar önemli olduğunu gösterir. Her bir alanda interface\u0026rsquo;ler, kodumuzun daha güvenli ve bakımı kolay olmasını sağlar.\nBest Practices ve İpuçları TypeScript interface\u0026rsquo;lerini kullanırken dikkat etmemiz gereken bazı önemli noktalar var. Bu pratikleri uygulayarak daha okunabilir ve bakımı kolay kod yazabiliriz.\n1. İsimlendirme Kuralları Interface isimleri, ne iş yaptıklarını açıkça belirtmeli ve bazı standartlara uymalı:\n// ✅ İyi İsimlendirme Örnekleri interface KullaniciServisi { kullaniciGetir(id: string): Promise\u0026lt;Kullanici\u0026gt;; } interface UrunDeposu { stokGuncelle(urunId: string, miktar: number): void; } // ❌ Kaçınılması Gereken İsimlendirmeler interface IKullanici { // \u0026#39;I\u0026#39; öneki kullanmayın // ... } interface veriYoneticisi { // PascalCase kullanın // ... } interface DATA_SERVICE { // BÜYÜK HARF kullanmayın // ... } 2. Tek Sorumluluk Prensibi Her interface tek bir işe odaklanmalı ve o işi iyi yapmalı:\n// ✅ İyi Tasarlanmış Interface\u0026#39;ler interface KimlikBilgileri { id: string; tcKimlikNo: string; pasaportNo?: string; } interface IletisimBilgileri { email: string; telefon?: string; adres?: { il: string; ilce: string; }; } // İhtiyaç halinde birleştirin interface Kullanici extends KimlikBilgileri, IletisimBilgileri { ad: string; soyad: string; } // ❌ Kaçınılması Gereken Durum: Her şeyi tek interface\u0026#39;de toplamak interface KocamanInterface { // Kimlik bilgileri id: string; tcKimlikNo: string; // İletişim bilgileri email: string; telefon: string; // Adres bilgileri il: string; ilce: string; // Kullanıcı bilgileri ad: string; soyad: string; // Diğer bilgiler... // ... ve daha birçok özellik } 3. Açıklayıcı Yorumlar Ekleme Interface\u0026rsquo;lerin nasıl kullanılacağını açıkça belirten yorumlar ekleyin:\n/** * Ödeme işlemi sırasında kullanılacak kart bilgileri. * Bu interface sadece ödeme işlemi sırasında kullanılmalı ve * hassas bilgiler işlem sonrası bellekten temizlenmelidir. */ interface OdemeBilgileri { /** Ödenecek tutar (TL cinsinden, kuruş hassasiyetinde) */ tutar: number; /** 16 haneli kart numarası */ kartNo: string; /** AA/YY formatında son kullanma tarihi (örnek: 12/25) */ sonKullanmaTarihi: string; /** Kartın arkasındaki 3 haneli güvenlik kodu */ guvenlikKodu: string; } 4. Opsiyonel Özellikleri Doğru Kullanma Opsiyonel özellikleri kullanırken dikkatli olun ve belgelendirin:\ninterface KullaniciProfili { // Zorunlu alanlar id: string; ad: string; email: string; // Opsiyonel alanlar - neden opsiyonel olduklarını açıklayın /** Kullanıcı telefon vermek istemeyebilir */ telefon?: string; /** Profil fotoğrafı yüklenmemişse varsayılan kullanılır */ profilFotoUrl?: string; /** Kullanıcı henüz konum izni vermemiş olabilir */ konum?: { lat: number; lng: number; }; } Sonuç Interface\u0026rsquo;ler, TypeScript\u0026rsquo;in en güçlü özelliklerinden biridir ve doğru kullanıldığında:\nKodunuzu daha okunabilir hale getirir Tip güvenliği sağlar Bakımı kolaylaştırır Takım çalışmasını iyileştirir Dokümantasyon görevi görür Bu yazıda gördüğümüz örnekler ve best practice\u0026rsquo;ler, günlük TypeScript geliştirmelerinizde size yol gösterecektir. Bir sonraki yazıda görüşeceğiz.\nSorularınız varsa yorum bırakabilirsiniz. İyi kodlamalar! 🚀\n",
    "tags": ["typescript","interfaces","type-system"],
    "categories": ["TypeScript"],
    "lang": "tr"
} 