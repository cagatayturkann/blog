{
    "title": "Vektör Veritabanları ve Weaviate: Anlamsal Arama Uygulamaları Oluşturma",
    "permalink": "/blog/tr/vector-veritabanlari-weaviate/",
    "summary": "Bu makale, Weaviate\u0026rsquo;e odaklanarak vektör veritabanlarını inceliyor, temel kavramları, mimarisi ve uygulama stratejilerini kapsıyor. Vektör veritabanlarının anlamsal arama yeteneklerini nasıl sağladığını, geleneksel veritabanlarına göre avantajlarını ve Weaviate ile güçlü arama uygulamaları nasıl oluşturulacağını öğrenin.",
    "content": "Vektör Veritabanları ve Weaviate: Anlamsal Arama Uygulamaları Oluşturma Giriş Veri depolama ve erişim sistemlerinin sürekli gelişen dünyasında, vektör veritabanları geleneksel veritabanları ile modern yapay zeka uygulamaları arasındaki boşluğu dolduran devrim niteliğinde bir teknoloji olarak ortaya çıktı. Tam eşleşmelerde ve yapılandırılmış sorgularda mükemmel olan geleneksel veritabanlarının aksine, vektör veritabanları verilerin arkasındaki anlamı ve bağlamı anlamak için tasarlanmıştır, böylece yeni nesil uygulamaları güçlendiren benzerlik tabanlı arama yetenekleri sağlar.\nBu makalede şunları inceleyeceğiz:\nVektör veritabanlarının arkasındaki temel kavramlar ve geleneksel sistemlerden nasıl farklılaştıkları Vektör veritabanlarının mimarisi ve temel bileşenleri Önde gelen açık kaynaklı vektör veritabanı platformlarından biri olan Weaviate\u0026rsquo;in derinlemesine incelenmesi Weaviate ile güçlü anlamsal arama uygulamalarının nasıl uygulanacağı En iyi uygulamalar, optimizasyon stratejileri ve gerçek dünya kullanım örnekleri İster vektör veritabanlarına yeni başlıyor olun, ister mevcut bilginizi geliştirmek istiyor olun, bu rehber bu güçlü teknolojiyi anlamanız ve kullanmanız için ihtiyacınız olan teorik temeli sağlayacaktır.\n1. Vektör Veritabanlarını Anlamak: Temel Kavramlar Vektör Veritabanları Nedir? Vektör veritabanı, verilerin yüksek boyutlu vektör temsillerini depolamak, yönetmek ve sorgulamak için tasarlanmış özel bir veritabanı sistemidir. Bu vektörler (gömme olarak da adlandırılır), metin, görüntü, ses veya sayısal formatta temsil edilebilen diğer verilerin anlamsal anlamını yakalar.\nVektör veritabanlarının arkasındaki temel fikir basit ama güçlüdür: verileri anlamsal ilişkileri koruyan vektörlere dönüştürerek, tam eşleşmeler yerine anlama dayalı benzerlik aramaları gerçekleştirebiliriz. Bu, geleneksel veritabanı sistemleriyle daha önce zor veya imkansız olan çok çeşitli uygulamaları mümkün kılar.\nVektör Gömmeleri: Yapı Taşları Vektör veritabanlarının kalbinde gömmeler—yüksek boyutlu bir uzayda verilerin sayısal temsilleri—bulunur. İşte nasıl çalıştıkları:\nGömme Oluşturma: Veriler (metin, görüntü veya ses gibi) onu kayan noktalı sayılardan oluşan bir vektöre dönüştüren bir gömme modeli aracılığıyla işlenir. Boyutsal Temsil: Bu vektörler genellikle yüzlerce veya binlerce boyuta sahiptir ve her boyut verinin anlamsal özelliklerinin bir yönünü yakalar. Anlamsal Yakınlık: Benzer anlamlara veya özelliklere sahip öğeler, bu yüksek boyutlu uzayda birbirine yakın konumlandırılır. Örneğin, bir metin gömme uzayında, \u0026ldquo;mutlu\u0026rdquo; ve \u0026ldquo;neşeli\u0026rdquo; kelimeleri, \u0026ldquo;mutlu\u0026rdquo; ve \u0026ldquo;otomobil\u0026rdquo; kelimelerine göre daha fazla anlamsal benzerlik paylaştıkları için birbirlerine daha yakın konumlandırılır.\nVektör Veritabanları ve Geleneksel Veritabanları Vektör veritabanlarının değerini anlamak için, geleneksel veritabanı sistemlerinden nasıl farklılaştıklarını anlamak önemlidir:\nÖzellik Geleneksel Veritabanları Vektör Veritabanları Veri Depolama Yapılandırılmış kayıtlar, tablolar, belgeler Vektör gömmeleri + meta veriler Sorgu Tipi Tam eşleşmeler, aralık sorguları, birleştirmeler Benzerlik araması, en yakın komşular Arama Paradigması \u0026ldquo;Kriterlere tam uyan kayıtları bul\u0026rdquo; \u0026ldquo;Bu referansa benzer öğeleri bul\u0026rdquo; İndeksleme B-ağaçları, hash indeksleri, ters indeksler Yaklaşık En Yakın Komşu (ANN) indeksleri Kullanım Durumları İşlemsel veriler, yapılandırılmış raporlama Anlamsal arama, öneriler, sınıflandırma Sorgu Karmaşıklığı SQL, karmaşık sorgu dilleri Vektör benzerliği + isteğe bağlı filtreleme Temel fark, verileri anlama yaklaşımında yatar: geleneksel veritabanları verileri literal değerler olarak ele alırken, vektör veritabanları veri noktaları arasındaki anlamsal ilişkileri anlar.\n2. Vektör Veritabanlarının Mimarisi Vektör Veritabanının Temel Bileşenleri Modern vektör veritabanları, birlikte çalışan birkaç temel bileşenden oluşur:\nVektör Depolama Katmanı: Yüksek boyutlu vektör verilerini verimli bir şekilde depolamaktan sorumludur İndeksleme Mekanizması: Benzer vektörlerin hızlı bir şekilde alınmasını sağlar Meta Veri Depolama: Her vektör hakkında ek bilgileri (orijinal metin, kategoriler, zaman damgaları vb.) depolar Sorgu İşleme Motoru: Vektör benzerlik aramalarını ve isteğe bağlı filtrelemeyi yönetir API Katmanı: Veri ekleme ve sorgulama için arayüzler sağlar Bu bileşenler, vektörleri benzerliğe dayalı olarak depolama ve alma temel işlevini sunmak için birlikte çalışır.\nYaklaşık En Yakın Komşu (ANN) Algoritmaları Vektör veritabanlarındaki en büyük zorluklardan biri, yüksek boyutlu uzaylarda benzer vektörleri verimli bir şekilde bulmaktır. Veri kümesi büyüdükçe tam en yakın komşu aramaları hesaplama açısından yasaklayıcı hale gelir. İşte burada Yaklaşık En Yakın Komşu (ANN) algoritmaları devreye girer.\nVektör veritabanlarında kullanılan popüler ANN algoritmaları şunları içerir:\nHNSW (Hiyerarşik Gezinilebilir Küçük Dünya): Verimli gezinme için çok katmanlı bir grafik yapısı oluşturur IVF (Ters Dosya İndeksi): Daha hızlı arama için vektör uzayını kümelere böler PQ (Ürün Nicemleme): Benzerlik ilişkilerini korurken vektörleri sıkıştırır FAISS (Facebook AI Benzerlik Araması): Ölçeklenebilir benzerlik araması için birden çok tekniği birleştirir Bu algoritmalar, arama doğruluğu ve performans arasında ödünleşimler yapar ve genellikle milyonlarca vektörle bile milisaniyenin altında sorgu süreleri sağlar.\nVektör Veritabanı Mimari Modelleri Vektör veritabanları farklı mimari yaklaşımlarla uygulanabilir:\nBağımsız Vektör Veritabanları: Özellikle vektör depolama ve erişimi için tasarlanmış amaca özel sistemler (örn. Weaviate, Pinecone) Geleneksel Veritabanlarına Vektör Uzantıları: Mevcut veritabanı sistemlerine vektör yetenekleri ekleme (örn. pgvector ile PostgreSQL) Hibrit Mimariler: Vektör aramasını geleneksel arama yetenekleriyle birleştirme Her yaklaşımın kendi avantajları vardır, bağımsız vektör veritabanları genellikle saf vektör tabanlı iş yükleri için en iyi performansı sunar.\n3. Weaviate: Açık Kaynaklı Bir Vektör Veritabanı Weaviate Nedir? Weaviate, bir vektör arama motorunun yeteneklerini geleneksel bir veritabanı sisteminin özellikleriyle birleştiren güçlü bir açık kaynaklı vektör veritabanıdır. Üretim ortamlarında beklenen güvenilirlik ve ölçeklenebilirlikle anlamsal arama yetenekleri sağlamak için tasarlanmıştır.\nWeaviate\u0026rsquo;in temel özellikleri şunları içerir:\nGraphQL API: Sorgular ve mutasyonlar için sezgisel arayüz RESTful API: Standart HTTP işlemleri için alternatif arayüz Hibrit Arama: Vektör aramasını anahtar kelime tabanlı erişimle birleştirme Modüler Mimari: Farklı gömme modelleri için takılabilir vektörleştirici modülleri Şema Tanımı: Esnek veri modelleme yetenekleri Çapraz Referanslar: Veritabanı içindeki nesneleri bağlama yeteneği Sınıflandırma Yetenekleri: Veri sınıflandırması için yerleşik makine öğrenimi Weaviate Mimarisi Weaviate\u0026rsquo;in mimarisi birkaç temel bileşenden oluşur:\nVektör İndeksi: Benzerlik araması için HNSW tabanlı vektör indeksi Nesne Deposu: Hem vektör verileri hem de ilişkili meta veriler için depolama GraphQL Arayüzü: Weaviate ile etkileşim için birincil API Vektörleştirme Modülleri: Gömmeler oluşturmak için takılabilir bileşenler Sorgu Planlayıcısı: Arama sorgularını optimize eder ve yürütür Bu mimari, Weaviate\u0026rsquo;in kullanıcı dostu bir arayüzü korurken yüksek performanslı vektör araması sunmasını sağlar.\nWeaviate\u0026rsquo;de Veri Modelleme Weaviate, veri modellemede esnek bir şema tabanlı yaklaşım kullanır. Weaviate\u0026rsquo;deki her veri nesnesi:\nBir sınıfa aittir (ilişkisel veritabanlarındaki tablolara benzer) Özelliklere sahiptir (nesneyi tanımlayan nitelikler) İlişkili bir vektör gömmesine sahiptir (otomatik olarak oluşturulur veya içe aktarılır) Diğer nesnelere çapraz referanslara sahip olabilir Makaleler koleksiyonu için basit bir Weaviate şeması şöyle görünebilir:\n{ \u0026#34;classes\u0026#34;: [ { \u0026#34;class\u0026#34;: \u0026#34;Article\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;A news or blog article\u0026#34;, \u0026#34;properties\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;title\u0026#34;, \u0026#34;dataType\u0026#34;: [\u0026#34;text\u0026#34;], \u0026#34;description\u0026#34;: \u0026#34;The title of the article\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;content\u0026#34;, \u0026#34;dataType\u0026#34;: [\u0026#34;text\u0026#34;], \u0026#34;description\u0026#34;: \u0026#34;The main content of the article\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;publishedDate\u0026#34;, \u0026#34;dataType\u0026#34;: [\u0026#34;date\u0026#34;], \u0026#34;description\u0026#34;: \u0026#34;When the article was published\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;author\u0026#34;, \u0026#34;dataType\u0026#34;: [\u0026#34;Author\u0026#34;], \u0026#34;description\u0026#34;: \u0026#34;The author of the article\u0026#34; } ] }, { \u0026#34;class\u0026#34;: \u0026#34;Author\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;A person who writes articles\u0026#34;, \u0026#34;properties\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;name\u0026#34;, \u0026#34;dataType\u0026#34;: [\u0026#34;text\u0026#34;], \u0026#34;description\u0026#34;: \u0026#34;The author\u0026#39;s full name\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;biography\u0026#34;, \u0026#34;dataType\u0026#34;: [\u0026#34;text\u0026#34;], \u0026#34;description\u0026#34;: \u0026#34;The author\u0026#39;s biographical information\u0026#34; } ] } ] } Bu şema tabanlı yaklaşım, Weaviate\u0026rsquo;i geleneksel veritabanı sistemlerine aşina olan geliştiriciler için erişilebilir kılar.\n4. Vektör Veritabanlarının Temel Özellikleri Anlamsal Arama Vektör veritabanlarının en önemli özelliği, anahtar kelimeler yerine anlama dayalı sonuçlar bulan anlamsal aramadır. Bu şunları içerir:\nKavramsal Eşleştirme: Farklı terminoloji kullansalar bile bir sorgunun kavramıyla eşleşen sonuçları bulma Bağlamsal Anlama: Sorguların arkasındaki amacı tanıma ve buna göre eşleştirme Çok Dilli Destek: Anlamsal benzerliğe dayalı olarak farklı dillerde ilgili içeriği bulma Anlamsal arama, özellikle karmaşık veya nüanslı sorgular için geleneksel anahtar kelime tabanlı yaklaşımlara göre arama kalitesini önemli ölçüde iyileştirir.\nHibrit Arama Vektör araması anlamsal ilişkileri yakalamada mükemmel olsa da, ilgili tam anahtar kelime eşleşmelerini kaçırabilir. Hibrit arama, her iki dünyanın en iyi yanlarını birleştirir:\nVektör Araması: Anlamsal benzerliği ve kavramsal eşleştirmeyi yakalar Anahtar Kelime Araması: Tam terim eşleşmelerinin kaçırılmadığından emin olur Füzyon Yöntemleri: Her iki yaklaşımdan gelen sonuçları akıllıca birleştirir Hibrit arama, özellikle genel amaçlı arama uygulamaları için tek başına her iki yaklaşımdan daha iyi genel arama kalitesi sunar.\nÇok Modlu Arama Gelişmiş vektör veritabanları, tek bir sorgu kullanarak farklı medya türleri arasında arama yapabilme yeteneği olan çok modlu aramayı destekler:\nÇapraz Modal Arama: Bir modaliteyi başka bir modaliteyi aramak için kullanma (örn. metinden görüntüye arama) Birleşik Gömme Vektörleri: Farklı veri türlerini paylaşılan bir vektör uzayında temsil etme Çok Modlu Sorgular: Tek bir sorguda birden fazla modaliteyi birleştirme Bu özellik, metin açıklamalarını kullanarak görüntüleri aramak veya bir görüntüyle ilgili metin içeriği bulmak gibi güçlü uygulamaları mümkün kılar.\nSınıflandırma ve Öneri Aramanın ötesinde, vektör veritabanları diğer önemli özellikleri sağlar:\nOtomatik Sınıflandırma: Yeni öğeleri mevcut kategorize edilmiş öğelere benzerliğe göre sınıflandırma Öneri Sistemleri: Vektör benzerliğine dayalı olarak ilgili öğeleri önerme Anomali Tespiti: Vektör uzayındaki aykırı değerleri tanımlama Bu özellikler, vektör veritabanlarını sadece arama uygulamaları için değil, çok çeşitli AI destekli sistemler için değerli kılar.\n5. Vektör Veritabanlarının Avantajları Gelişmiş Arama Kalitesi Vektör veritabanları, arama kalitesinde önemli iyileştirmeler sunar:\nAmacı Anlama: Sadece anahtar kelimeleri eşleştirmek yerine sorguların arkasındaki anlamı yakalama Eş Anlamlıları İşleme: Aynı anlama sahip farklı terimleri tanıma Kavram Eşleştirme: Farklı terminoloji kullansa bile aynı kavramla ilgili sonuçları bulma Bağlam Duyarlılığı: Sorguların nüansını ve bağlamını anlama Bu iyileştirmeler, daha iyi kullanıcı deneyimlerine ve daha etkili bilgi erişimine dönüşür.\nÖlçeklenebilirlik ve Performans Modern vektör veritabanları, üretim düzeyinde performans için tasarlanmıştır:\nSaniyeden Az Sorgu Süreleri: Milyonlarca vektörle bile Yatay Ölçekleme: İş yüklerini birden fazla düğüme dağıtma Verimli Depolama: Yüksek boyutlu vektör verileri için optimize edilmiş Düşük Gecikme: Gerçek zamanlı uygulamalar için Bu ölçeklenebilirlik, vektör veritabanlarını küçük uygulamalardan kurumsal ölçekli dağıtımlara kadar her şey için uygun hale getirir.\nAI İş Akışlarıyla Entegrasyon Vektör veritabanları modern AI iş akışlarına sorunsuz bir şekilde uyum sağlar:\nLLM Entegrasyonu: Büyük dil modellerini erişim yetenekleriyle geliştirme Gömme Vektörü İşlem Hattı Entegrasyonu: Doğrudan gömme modelleriyle çalışma Veri İşleme Desteği: Sürekli güncellemeleri ve yeni verileri işleme API Öncelikli Tasarım: Mevcut sistemlerle kolay entegrasyon Bu entegrasyon potansiyeli, vektör veritabanlarını AI altyapı yığınında kilit bir bileşen haline getirir.\n6. Vektör Veritabanları için Yaygın Kullanım Durumları Anlamsal Belge Araması Vektör veritabanları, anlama dayalı ilgili belgeleri bulmada mükemmeldir:\nKurumsal Bilgi Tabanları: Çalışanların ilgili bilgileri bulmasına yardımcı olma Hukuki Belge Araması: Kavramlara dayalı emsal ve içtihat bulma Araştırma Veritabanları: Farklı terminolojiler arasında ilgili makaleleri keşfetme İçerik Yönetimi: İçeriği temalara göre düzenleme ve erişme Öneri Sistemleri Vektör benzerliği etkili öneri sistemlerini güçlendirir:\nÜrün Önerileri: \u0026ldquo;Bunu görüntüleyen müşteriler şunları da görüntüledi\u0026hellip;\u0026rdquo; İçerik Keşfi: Benzer temalara sahip makaleler, videolar veya müzikler bulma Kişi Eşleştirme: Arkadaşlık uygulamaları, profesyonel ağ oluşturma, takım oluşturma Eğitim Kaynakları: Benzer konularda öğrenme materyalleri önerme Görüntü ve Medya Araması Metin ötesinde, vektör veritabanları multimedya içeriğini etkili bir şekilde işler:\nTers Görüntü Araması: Bir referansa benzer görüntüler bulma İçerik Tabanlı Medya Erişimi: Benzer içeriğe sahip videolar veya ses bulma Dijital Varlık Yönetimi: İçeriğe dayalı medyayı düzenleme ve erişme Görsel Ürün Araması: Bir referansa benzeyen ürünler bulma RAG (Erişim Destekli Üretim) Vektör veritabanları RAG sistemlerinde kilit bir bileşendir:\nSorgu Tabanlı Belge Erişimi: LLM için ilgili belgeleri bulma Bilgi Temellendirme: LLM yanıtlarını temellendirmek için gerçek bilgiler sağlama Alan Adaptasyonu: Genel LLM\u0026rsquo;lerin alana özgü bilgilere erişmesine izin verme Gerçek Doğrulama: LLM tarafından oluşturulan içeriği doğrulamak için bilgi erişimi 7. Uygulamalarda Weaviate\u0026rsquo;i Uygulama Weaviate Sunucusu Kurma Weaviate ile çalışmanın ilk adımı bir sunucu kurmaktır. Bu birkaç şekilde yapılabilir:\nDocker kullanarak (en yaygın yöntem) Bulut tabanlı seçenekler Kaynak koddan derleme Uygulama bölümünde, Weaviate\u0026rsquo;in kendi sandbox yöntemi ve örnek kodlar paylaşacağım.\nVeri Şemanızı Tanımlama Verileri içe aktarmadan önce, şemanızı tanımlamanız gerekir. Bu şunları içerir:\nSınıfları tanımlama (benzer nesnelerin koleksiyonları) Her sınıf için özellikleri belirleme Sınıflar arasında çapraz referanslar kurma Vektörleştirici modülleri yapılandırma Uygulama bölümü, Weaviate\u0026rsquo;de bir şema tanımlama ve oluşturma için kod içerecektir.\nWeaviate\u0026rsquo;e Veri İçe Aktarma Şemanız tanımlandıktan sonra, verileri içe aktarabilirsiniz. Bu genellikle şunları içerir:\nVerilerinizi doğru formatta hazırlama Verimli içe aktarmalar için verileri toplu işleme Hataları ve doğrulamayı yönetme İçe aktarma sürecini izleme Uygulama bölümünde verimli veri içe aktarma için kod örnekleri sunacağım.\nHibrit Aramayı Uygulama Hibrit arama, vektör aramasını geleneksel anahtar kelime aramasıyla birleştirir. Uygulama şunları içerir:\nHer iki arama türünü yapılandırma Her biri için uygun ağırlıkları belirleme Optimal sonuçlar için parametreleri ayarlama Sonuçları işleme ve yönetme Uygulama kodu, hibrit arama sorgularını nasıl kurup yürüteceğinizi gösterecektir.\n8. En İyi Uygulamalar ve Optimizasyon Stratejileri Şema Tasarımı En İyi Uygulamaları Etkili şema tasarımı, Weaviate performansı için çok önemlidir:\nUygun Özellik Türleri: Her özellik için doğru veri türlerini kullanma Vektörleştirme Yapılandırması: Verileriniz için doğru vektörleştiriciyi seçme Çapraz Referans Planlama: Verimli nesne ilişkileri tasarlama İndeksleme Stratejisi: Kullanım durumunuz için HNSW parametrelerini yapılandırma Veri İçe Aktarma Optimizasyonu Verimli veri içe aktarma, daha hızlı değer elde etmeyi sağlar:\nToplu İşleme: Daha verimli içe aktarmalar için nesneleri gruplandırma Paralel İşleme: Daha hızlı içe aktarmalar için birden fazla iş parçacığı kullanma Artımlı Güncellemeler: Mevcut verileri güncelleme stratejileri Hata Yönetimi: İçe aktarma hatalarını düzgün bir şekilde yönetme Sorgu Optimizasyon Teknikleri Sorguları optimize etmek hem performansı hem de sonuç kalitesini iyileştirir:\nVektör Arama Parametreleri: Mesafe metriklerini ve k değerlerini ayarlama Hibrit Arama Yapılandırması: Vektör ve anahtar kelime bileşenlerini dengeleme Filtre Optimizasyonu: Meta veri filtrelerinin verimli kullanımı Sonuç İşleme: Arama sonuçlarını işleme ve dönüştürme Ölçekleme ve Üretim Hususları Üretim dağıtımları için, bu en iyi uygulamaları göz önünde bulundurun:\nKaynak Tahsisi: CPU, bellek ve depolama gereksinimleri Yedekleme Stratejileri: Veri dayanıklılığını sağlama İzleme ve Günlük Tutma: Performansı ve hataları takip etme Yüksek Kullanılabilirlik: Yedeklilik ve yük devretme için yapılandırma 9. Zorluklar ve Sınırlamalar Vektör Veritabanı Zorlukları Güçlü olmalarına rağmen, vektör veritabanları belirli zorluklarla gelir:\nSoğuk Başlangıç Sorunu: Mevcut gömme vektörleri olmadan ilk kurulum Gömme Vektörü Kayması: Zaman içinde gömme modellerindeki değişiklikler Açıklanabilirlik: Belirli sonuçların neden döndürüldüğünü anlama Kaynak Yoğunluğu: Geleneksel veritabanlarından daha yüksek hesaplama gereksinimleri Yaygın Tuzakları Ele Alma Vektör veritabanlarıyla ilgili yaygın sorunlardan kaçınmak için:\nArama Kalitesini Test Edin: Gerçek sorgularla arama sonuçlarını düzenli olarak değerlendirin Performansı İzleyin: Sorgu sürelerini ve kaynak kullanımını takip edin Gömme Vektörlerini Güncelleyin: Modeller değiştiğinde gömme vektörlerini yeniden oluşturun Kademeli Olarak Ayarlayın: Küçük değişiklikler yapın ve etkiyi ölçün Uygulama: Weaviate ile Geliştirme https://weaviate.io/developers/weaviate/quickstart adresindeki adımları izleyerek bir kendimize bir endpoint ve api key oluşturuyoruz.\nBir proje başlatıyoruz localimizde veya github reposundan ve sırasıyla aşağıdaki komutları çalıştırıyoruz.\nnpm init -y npm install axios openai weaviate-client Projemizi oluşturup gerekli bileşenleri yükledikten sonra https://dummyjson.com/products adresinden aldığımız örnek dataları embedding haline getirmek için aşağıdaki scripti kullanıyoruz.\nimport axios from \u0026#39;axios\u0026#39;; import { writeFileSync } from \u0026#39;fs\u0026#39;; import { OpenAI } from \u0026#39;openai\u0026#39;; import fs from \u0026#39;fs\u0026#39;; // Initialize OpenAI API client const openai = new OpenAI({ apiKey: \u0026#39;\u0026#39;, // Add your OpenAI API key here }); /** * Converts product title to URL-friendly format * @param {string} title - Product title * @returns {string} - Formatted URI string */ function formatProductUri(title) { if (!title) return \u0026#39;\u0026#39;; return title.toLowerCase().replace(/\\s+/g, \u0026#39;-\u0026#39;); } /** * Processes product data and generates embeddings * @param {Object} product - Raw product data * @returns {Object} - Formatted product with vector embedding */ async function formatProductData(product) { try { // Combine product data as string for embedding const productString = JSON.stringify(product); // Generate embedding using OpenAI const embeddingResponse = await openai.embeddings.create({ model: \u0026#39;text-embedding-ada-002\u0026#39;, input: productString, }); const embedding = embeddingResponse.data[0].embedding; // Return product in the required format return { data: product, id: formatProductUri(product?.title) + \u0026#39;-\u0026#39; + product?.id, vectorContent: embedding, }; } catch (error) { console.error(`Error processing product: ${product.title}`, error); throw error; } } /** * Main function to fetch products from API and process them * Generates vector embeddings for each product */ async function fetchAndProcessProducts() { try { console.log(\u0026#39;Fetching products...\u0026#39;); const response = await axios.get(\u0026#39;https://dummyjson.com/products?limit=200\u0026#39;); const products = response.data.products; fs.writeFileSync(\u0026#39;products.json\u0026#39;, JSON.stringify(products, null, 2)); console.log(`Fetched ${products.length} products. Processing...`); // Process all products const processedProducts = []; let index = 0; // Process each product sequentially to avoid rate limits for (const product of products) { index++; console.log(`Processing product ${index}/${products.length}: ${product.title}`); try { const formattedProduct = await formatProductData(product); processedProducts.push(formattedProduct); // Add delay every 10 products to avoid OpenAI rate limits if (index % 10 === 0) { console.log(\u0026#39;Waiting 1 second for rate limit...\u0026#39;); await new Promise((resolve) =\u0026gt; setTimeout(resolve, 1000)); } } catch (error) { console.error(`Error processing product: ${product.title}`, error); // Continue despite errors continue; } } // Save results to JSON file writeFileSync(\u0026#39;processed_products.json\u0026#39;, JSON.stringify(processedProducts, null, 2)); console.log(\u0026#34;Processing complete. Results saved to \u0026#39;processed_products.json\u0026#39;\u0026#34;); } catch (error) { console.error(\u0026#39;Error occurred:\u0026#39;, error); } } // Start the process fetchAndProcessProducts(); Bu script bize \u0026lsquo;processed_products.json\u0026rsquo; isminde datanın kendisini ve embed edilmiş halini barındıran bir json dosyası verecek. Daha sonra bu datayı aşağıdaki script ile weaviate bulut ortamına import ediyoruz. Yukarıda anlatılanlardan farklı olarak şema yaklaşımını burada kullanmıyorum daha çok işin mantığını kavramayı anlatamaya çalıştığım için.\n/** * Import script for loading product data into Weaviate vector database * This script reads product data from a JSON file and imports it into a Weaviate collection */ import weaviate, { generateUuid5 } from \u0026#39;weaviate-client\u0026#39;; import { readFileSync } from \u0026#39;fs\u0026#39;; // Load product data from JSON file const products = JSON.parse(readFileSync(\u0026#39;./processed_products.json\u0026#39;, \u0026#39;utf8\u0026#39;)); // Weaviate cloud service connection details const WCD_URL = \u0026#39;\u0026#39;; // Add your WCD URL here const WCD_API_KEY = \u0026#39;\u0026#39;; // Add your WCD API key here const wcdUrl = WCD_URL; const wcdApiKey = WCD_API_KEY; // Validate connection details are available if (!wcdUrl || !wcdApiKey) { throw new Error(\u0026#39;Missing required environment variables WCD_URL or WCD_API_KEY\u0026#39;); } // Initialize Weaviate client const client = await weaviate.connectToWeaviateCloud(wcdUrl, { authCredentials: new weaviate.ApiKey(wcdApiKey), }); /** * Main function to import product data into Weaviate */ async function main() { try { console.log(\u0026#39;Starting data import to Weaviate...\u0026#39;); console.log(\u0026#39;products recieved\u0026#39;, products.length); // Transform product data into Weaviate objects const dataObjects = products.map((item) =\u0026gt; ({ properties: { data: JSON.stringify(item.data), }, // Generate a deterministic UUID based on collection name and item ID id: generateUuid5(\u0026#39;Ecommerce\u0026#39;, item.id), // Use vector if available, otherwise let Weaviate generate it vector: Array.isArray(item.vectorContent) ? item.vectorContent : undefined, })); console.log(\u0026#39;dataObjects received\u0026#39;, dataObjects.length); // Get reference to the Ecommerce collection const collection = await client.collections.get(\u0026#39;Ecommerce\u0026#39;); // Insert all objects in a batch operation const result = await collection.data.insertMany(dataObjects); console.log(\u0026#39;Insertion response: \u0026#39;, result); console.log(\u0026#39;Data import completed\u0026#39;); } catch (error) { console.error(\u0026#39;Error:\u0026#39;, error); } } // Run the main function main().catch(console.error); Bu script ile oluşturulan json dosyasını weaviate sistemine yüklemiş oluyoruz. Burada iki kısım önemli.\nEğer aldığınız datanın içerisinde kendinea ait bir ID değeri var ise bunu kullanmak için properties kısmında ayrıca belirtebilirsiniz veya farklı bir property ismi ile tanımlamanız gerekiyor çünkü Weaviate\u0026rsquo;in kendi Id parametresi var ve bu UUID formatında olmalı bu yüzden direkt datanın id alanını orada kullanamıyoruz. Ancak Weavaite\u0026rsquo;in kendi UUID oluşturucusunu kullanabiliriz örnekte olduğu gibi. Diğer alan ise collection name. Burası aslında class ismini temsil ediyor. Arama yaparken, data silerken vb tüm işlemlerde buradaki collection ismi kullanılıyor. Datamızı import ettikten sonra ise geldi datayı search etme işlemine. Yukarıda çeşitli arama çeşitlerinden hem Weaviate özelinde hem vektör veritabanları özelinde bahsetmiştim. Ben aşağıdaki scriptte Weaviate\u0026rsquo;in graphql özelliğini ve hybrid arama özelliğini kullandım.\n// Import required libraries // axios for making HTTP requests import axios from \u0026#39;axios\u0026#39;; // OpenAI SDK for generating embeddings import OpenAI from \u0026#39;openai\u0026#39;; // Initialize OpenAI client with API key const openai = new OpenAI({ apiKey: \u0026#39;\u0026#39;, //Add your openAI API key }); // Array of questions to process const questions = [\u0026#39;do you have macbook?\u0026#39;]; /** * Generate an embedding vector for the given text using OpenAI\u0026#39;s API * @param {string} text - The text to generate an embedding for * @returns {Promise\u0026lt;Array\u0026lt;number\u0026gt;\u0026gt;} The embedding vector */ async function getEmbedding(text) { const response = await openai.embeddings.create({ model: \u0026#39;text-embedding-ada-002\u0026#39;, input: text, }); return response.data[0].embedding; } /** * Search Weaviate database using hybrid search (text + vector) * @param {string} question - The question to search for * @param {Array\u0026lt;number\u0026gt;} vector - The embedding vector of the question * @returns {Promise\u0026lt;Object\u0026gt;} Search results and metadata */ async function searchWeaviate(question, vector) { // Track response time const startTime = Date.now(); // Prepare GraphQL query for Weaviate const data = JSON.stringify({ query: `{ Get { Ecommerce ( hybrid: { query: \u0026#34;${question}\u0026#34; alpha: 0.5, vector: ${JSON.stringify(vector)} } limit: 3 ) { data _additional { score } } } }`, }); // Configure request parameters const config = { method: \u0026#39;post\u0026#39;, url: \u0026#39;https://ltwfnj0szusp5t1natqdw.c0.us-west3.gcp.weaviate.cloud/v1/graphql\u0026#39;, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;, Authorization: \u0026#39;Bearer AUV3GwGDrHKwVCJpFFxKc6ppUl7xXF54uQAM\u0026#39;, }, data: data, }; try { // Execute the request const response = await axios.request(config); const endTime = Date.now(); // Format and return results return { question: question, results: response.data.data.Get.Ecommerce.map((item) =\u0026gt; item.data), responseTime: `${endTime - startTime}ms`, }; } catch (error) { // Handle errors console.error(`Error for question \u0026#34;${question}\u0026#34;:`, error); return { question: question, error: error.message, responseTime: null, }; } } /** * Main function to process all questions */ async function main() { for (const question of questions) { try { // Generate embedding for the question const embedding = await getEmbedding(question); // Search Weaviate using the question and its embedding const result = await searchWeaviate(question, embedding); // Output results console.log(\u0026#39;\\n-------------------\u0026#39;); console.log(\u0026#39;Question:\u0026#39;, result.question); console.log(\u0026#39;Products:\u0026#39;, result.results); console.log(\u0026#39;Response Time:\u0026#39;, result.responseTime); } catch (error) { console.error(`Failed to process question \u0026#34;${question}\u0026#34;:`, error); } } } // Execute the main function main(); Bu script questions içerisinde yer alan soruyu/soruları alarak sırayla weaviate sunucularında arama yapıyor. Bunu yaparken\nconst data = JSON.stringify({ query: `{ Get { Ecommerce ( hybrid: { query: \u0026#34;${question}\u0026#34; alpha: 0.5, vector: ${JSON.stringify(vector)} } limit: 3 ) { data _additional { score } } } }`, }); kısmındaki Weaviate hybrid arama özelliğini kullanıyor. Burada query kısmında direkt sorunun kendisi yer alıyor. vector kısmında ise sorunun embedding haline çevrilmiş versiyonu yer alıyor. Böylece hem text hem vector olarak hybrid arama gerçekleştiriyor. alpha kısmı ise aramanın ağırlığını belirtiyor. Artırdıkça vector aramasının ağırlığı, azalttıkça ise kelime aramasının ağırlığı artıyor. limit kısmında ise dönen data sayısını belirtiyoruz. data kısmında ise dönmesini istediğimi property ismini belirtiyoruz. score kısmı ise arama sonuçları için belirlenen skorları gösteriyor.\nSonuç Weaviate gibi vektör veritabanları, verileri depolama, erişme ve anlama şeklimizde önemli bir ilerlemeyi temsil eder. Anlamsal ilişkileri yakalayarak ve benzerlik tabanlı aramayı mümkün kılarak, geleneksel veritabanı sistemleriyle daha önce pratik olmayan yeni yeteneklerin kilidini açarlar.\nAI yazılım geliştirmeyi dönüştürmeye devam ederken, vektör veritabanları dil modellerini, arama sistemlerini ve kullanıcı arayüzlerini birbirine bağlamada giderek daha merkezi bir rol oynayacaktır. Yeteneklerini, mimarisini ve uygulama stratejilerini anlamak, AI destekli uygulamalarla çalışan geliştiriciler için temel bir beceri haline gelmektedir.\nTakip eden uygulama bölümünde, bir Weaviate sunucusu kurma, veri içe aktarma ve güçlü anlamsal arama yeteneklerini uygulama için somut kod örnekleri sunacağım. Bu örnekler, teoriden pratiğe geçmenize yardımcı olacak ve kendi vektör destekli uygulamalarınızı oluşturmanıza olanak tanıyacaktır.\n",
    "tags": ["vectordb","weaviate","anlamsal-arama","gömme"],
    "categories": ["AI","Veritabanları"],
    "lang": "tr"
} 