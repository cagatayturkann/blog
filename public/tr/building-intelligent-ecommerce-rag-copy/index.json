{
    "title": "RAG ile Akıllı E-ticaret Deneyimleri Oluşturma",
    "permalink": "/blog/tr/building-intelligent-ecommerce-rag-copy/",
    "summary": "Bu makalede, Retrieval-Augmented Generation (RAG) teknolojisinin e-ticaret uygulamalarını nasıl dönüştürebileceğini inceleyeceğiz. Pratik bir örnek proje üzerinden vektör veritabanları, anlamsal arama, konuşma hafızası ve çok dilli desteğin uygulanmasını tartışacağız.",
    "content": "RAG ile Akıllı E-ticaret Deneyimleri Oluşturma Giriş E-ticaret platformları, daha kişiselleştirilmiş ve verimli alışveriş deneyimleri sunmak için sürekli gelişiyor. Geleneksel arama ve öneri sistemleri, müşteri sorgularının arkasındaki nüanslı niyeti anlamada genellikle yetersiz kalıyor. İşte tam bu noktada Retrieval-Augmented Generation (RAG) devreye giriyor; büyük dil modellerinin gücünü hassas bilgi erişimiyle birleştirerek daha akıllı alışveriş asistanları oluşturuyor.\nBu makalede, aşağıdaki özelliklere sahip bir RAG tabanlı e-ticaret asistanının nasıl uygulanacağını inceleyeceğiz:\nKarmaşık ürün sorgularını anlama ve yanıtlama Takip soruları için konuşma bağlamını koruma Sorunsuz çok dilli destek sağlama Vektör veritabanından doğru ürün bilgilerini getirme Halüsinasyonlardan kaçınarak insan benzeri yanıtlar üretme Bu projenin tüm kodlarına GitHub deposundan erişebilirsiniz. Asistanı buradan test edebilirsiniz.\n1. E-ticaret için RAG\u0026rsquo;ı Anlamak RAG Nedir? Retrieval-Augmented Generation (RAG), büyük dil modellerini (LLM\u0026rsquo;ler) harici bilgi kaynaklarından alınan ilgili bilgilerle geliştiren bir yapay zeka mimarisidir. Geleneksel LLM\u0026rsquo;lerin aksine, RAG sistemleri güncel ve alana özgü bilgilere erişebilir.\nRAG süreci üç ana adımdan oluşur:\nErişim: Kullanıcı bir soru sorduğunda, sistem ilgili bilgileri veritabanında arar Zenginleştirme: Erişilen bilgiler LLM\u0026rsquo;e gönderilen isteme eklenir Üretim: LLM, hem önceden eğitilmiş bilgisine hem de erişilen bilgilere dayanarak bir yanıt üretir RAG Neden E-ticaret İçin Mükemmel? E-ticaret, RAG\u0026rsquo;ı özellikle değerli kılan benzersiz zorluklar sunar:\nÜrün Katalogları Sık Sık Değişir: Yeni ürünler eklenir, fiyatlar değişir ve stok dalgalanır Spesifik Ürün Detayları Önemlidir: Müşteriler özellikler, uyumluluk ve özellikler hakkında doğru bilgiye ihtiyaç duyar Sorgu Niyeti Karmaşıktır: \u0026ldquo;1000 doların altında oyun için iyi bir laptop göster\u0026rdquo; gibi sorgular birden çok kısıt içerir Takip Soruları Yaygındır: \u0026ldquo;Arkadan aydınlatmalı klavyesi var mı?\u0026rdquo; gibi sorular önceki sorulardan bağlam gerektirir Geleneksel arama sistemleri anahtar kelimeleri eşleştirir ancak anlamsal anlayışta zorlanır. RAG, semantik arama ile LLM\u0026rsquo;lerin konuşma yeteneklerini birleştirerek bu boşluğu doldurur.\nE-ticarette RAG vs Geleneksel Arama Özellik Geleneksel Arama RAG Tabanlı Arama Sorgu Anlama Anahtar kelime eşleştirme Anlamsal anlama Sonuç İlgisi Metin benzerliğine dayalı Anlam ve bağlama dayalı Belirsizlik Yönetimi Sınırlı Güçlü Takip Soruları Yeni arama gerektirir Bağlamı korur Yanıt Formatı Ürün listesi Ürün detaylarıyla konuşma Ürün Bilgisi İndekslenen alanlarla sınırlı Tüm ürün detaylarını içerebilir 2. Vektör Veritabanları ve Gömme İşlemleri Vektör Veritabanlarının Rolü Vektör veritabanları, yüksek boyutlu vektörleri (gömmeleri) verimli bir şekilde depolamak ve sorgulamak için tasarlanmış özel depolama sistemleridir. E-ticaret RAG sistemimizde, anlamsal aramanın temelini oluştururlar.\nVektör veritabanlarının temel özellikleri şunlardır:\nBenzerlik Araması: Bir sorgu vektörüne anlamsal olarak benzer vektörleri bulma Verimli İndeksleme: Hızlı erişim için HNSW (Hierarchical Navigable Small World) gibi algoritmalar Hibrit Arama: Vektör benzerliğini geleneksel filtrelerle birleştirme Metadata Depolama: Vektörlerin yanında ürün bilgilerini tutma E-ticaret RAG projemiz için, güçlü özellikleri, GraphQL API\u0026rsquo;si ve hibrit arama yetenekleri nedeniyle Weaviate\u0026rsquo;i vektör veritabanı olarak seçtik.\nÜrün Gömmelerini Oluşturma Gömmeler, anlamsal anlamı yakalayan metinlerin sayısal temsilleridir. Sistemimizde, ürün bilgileri için gömmeleri Google\u0026rsquo;ın text-embedding-004 modelini kullanarak oluşturuyoruz.\nİşte projemizdeki gömme oluşturma uygulaması:\nconst { GoogleGenerativeAI } = require(\u0026#39;@google/generative-ai\u0026#39;); require(\u0026#39;dotenv\u0026#39;).config(); // Get API key from environment variables const GEMINI_API_KEY = process.env.GEMINI_API_KEY; // Initialize API client const genAI = GEMINI_API_KEY ? new GoogleGenerativeAI(GEMINI_API_KEY) : null; /** * Generates an embedding vector for the given text * @param {String} text - Text to generate embedding for * @returns {Array} - Embedding vector */ async function getEmbedding(text) { const model = genAI.getGenerativeModel({ model: \u0026#39;text-embedding-004\u0026#39; }); const result = await model.embedContent(text); return result.embedding.values; } Bu gömmeler, ürün açıklamalarını, başlıklarını ve özelliklerini anlamsal benzerlik için karşılaştırılabilecek vektörlere dönüştürmemizi sağlar.\nVektör Aramasını Uygulama Ürünlerimiz vektör veritabanına gömüldükten sonra, artık anlamsal arama yapabiliriz. Aşağıdaki kod, bir kullanıcı sorgusuna dayalı olarak ilgili ürünlerin nasıl alınacağını gösterir:\n/** * Retrieves product information from Weaviate vector database * @param {String} query - Search query * @returns {Array} - Product information */ const getProductInfo = async (query) =\u0026gt; { try { const embedding = await getEmbedding(query); // Use fixed alpha value for vector search const alpha = 0.5; // Clean query text for GraphQL - make it safe const cleanQuery = query .substring(0, 100) // Keep query at reasonable length .replace(/[^\\w\\s]/gi, \u0026#39;\u0026#39;) // Remove non-alphanumeric characters .replace(/\u0026#34;/g, \u0026#39;\u0026#39;) // Remove double quotes .trim(); const data = JSON.stringify({ query: `{ Get { Ecommerce ( hybrid: { query: \u0026#34;${cleanQuery}\u0026#34; alpha: ${alpha}, vector: ${JSON.stringify(embedding)}, } limit: 3 ) { data _additional { score } } } }`, }); const config = { method: \u0026#39;post\u0026#39;, url: process.env.WEAVIATE_URL + \u0026#39;/v1/graphql\u0026#39;, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;, Authorization: `Bearer ${process.env.WEAVIATE_API_KEY}`, }, data: data, }; const response = await axios.request(config); return response.data.data.Get.Ecommerce.map((item) =\u0026gt; item.data); } catch (error) { console.error(\u0026#39;Error during Weaviate query:\u0026#39;, error); return []; } }; Sorgumuzdaki hybrid parametresi, vektör aramasını (anlamsal benzerlik) anahtar kelime eşleştirmesiyle birleştirmemizi sağlar. alpha değeri (0.5), her iki yaklaşıma da eşit ağırlık vererek anlamsal anlama ile anahtar kelime ilgisi arasında bir denge sağlar.\n3. Konuşma Yönetimi ve Bağlam Konuşma Geçmişini Koruma Etkili bir e-ticaret asistanı oluşturmadaki temel zorluklardan biri, konuşma bağlamını korumaktır. Kullanıcılar genellikle önceki sorguları veya yanıtları referans alan takip soruları sorarlar.\nProjemizde, konuşma geçmişini saklamak için MongoDB kullanıyoruz. Her konuşma, mesaj dizisi içeren bir belge olarak saklanır:\n/** * Creates a new conversation * @param {String} title - Conversation title (optional) * @returns {Promise\u0026lt;Object\u0026gt;} - Created conversation */ const createConversation = async (title = null) =\u0026gt; { try { // Assign default title if null const conversationTitle = title || \u0026#39;New Conversation\u0026#39;; const conversation = new Conversation({ title: conversationTitle, messages: [] }); await conversation.save(); return conversation; } catch (error) { console.error(\u0026#39;Error creating conversation:\u0026#39;, error); throw error; } }; /** * Adds a message to a conversation * @param {String} conversationId - Conversation ID * @param {String} role - Message role (user/assistant) * @param {String} content - Message content * @returns {Promise\u0026lt;Object\u0026gt;} - Updated conversation */ const addMessageToConversation = async (conversationId, role, content) =\u0026gt; { try { const conversation = await Conversation.findById(conversationId); if (!conversation) { throw new Error(`Conversation not found with ID: ${conversationId}`); } conversation.messages.push({ role, content, timestamp: new Date() }); conversation.updatedAt = new Date(); await conversation.save(); return conversation; } catch (error) { console.error(\u0026#39;Error adding message to conversation:\u0026#39;, error); throw error; } }; Takip Sorularını Tespit Etme Sorunsuz bir konuşma deneyimi sağlamak için, sistemimizin bir kullanıcının ne zaman takip sorusu sorduğunu tespit etmesi gerekir. Bu amaçla özel bir sınıflandırıcı ajan kullanıyoruz:\n/** * Determines if a message is a follow-up question based on conversation history * @param {Array} conversationHistory - Array of previous conversation messages * @returns {String} - JSON string indicating if message is a follow-up (true/false) */ const classifierAgent = async (conversationHistory) =\u0026gt; { try { // Format conversation history for the AI model const formattedHistory = conversationHistory .map((msg) =\u0026gt; `${msg.role === \u0026#39;user\u0026#39; ? \u0026#39;User\u0026#39; : \u0026#39;Assistant\u0026#39;}: ${msg.content}`) .join(\u0026#39;\\n\u0026#39;); const response = await axios({ method: \u0026#39;post\u0026#39;, url: \u0026#39;https://openrouter.ai/api/v1/chat/completions\u0026#39;, headers: { Authorization: `Bearer ${process.env.OPENROUTER_API_KEY}`, \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;, }, data: { model: \u0026#39;google/gemini-2.0-flash-001\u0026#39;, messages: [ { role: \u0026#39;system\u0026#39;, content: `You are a sophisticated AI agent specializing in determining if a user\u0026#39;s message is a follow-up question to a previous conversation. A follow-up question is a question that refers to or builds upon a previous question or response in the conversation. For example, if a user asks about a product and then asks about its price, the second question is a follow-up question. Analyze the conversation history and determine if the last user message is a follow-up question. Return only a JSON boolean value (true or false) as plain text.`, }, { role: \u0026#39;user\u0026#39;, content: `Here is the conversation history:\\n${formattedHistory}\\n\\nIs the last user message a follow-up question?`, }, ], }, }); return response.data.choices[0].message.content.replace(/\\n+$/, \u0026#39;\u0026#39;); } catch (error) { console.error(\u0026#39;OpenRouter API error:\u0026#39;, error); return \u0026#39;false\u0026#39;; } }; Bir takip sorusu tespit edildiğinde, arama sorgusunu önceki mesajlardan gelen bağlamı içerecek şekilde genişletiyoruz:\n// If it\u0026#39;s a follow-up question, include previous user questions if (isFollowUp \u0026amp;\u0026amp; conversationHistory.length \u0026gt;= 3) { // Find previous user messages (last 2 user messages) const userMessages = conversationHistory.filter((msg) =\u0026gt; msg.role === \u0026#39;user\u0026#39;).slice(-2); if (userMessages.length \u0026gt;= 2) { const previousUserMessage = userMessages[0].content; // Previous user message searchQuery = `${await translatorAgent(previousUserMessage)} ${translatedMessage}`; console.log(`Expanded search query (follow-up): \u0026#34;${searchQuery}\u0026#34;`); } } Bu yaklaşım, bir kullanıcı belirli bir dizüstü bilgisayar hakkında soru sorduktan sonra \u0026ldquo;Peki ya pil ömrü nasıl?\u0026rdquo; gibi bir soru sorduğunda, sistemimizin bağlamı anlamasını ve ilgili bilgileri sağlamasını sağlar.\n4. Çok Dilli Destek Otomatik Dil Algılama ve Çeviri E-ticaret asistanımızı küresel bir kitleye erişilebilir kılmak için otomatik dil algılama ve çeviri özelliklerini uyguladık. Bu, kullanıcıların anlamsal arama yeteneklerini korurken sistem ile tercih ettikleri dilde etkileşime girmelerini sağlar.\nKullanıcı sorgularını işleme için İngilizce\u0026rsquo;ye çevirmek üzere bir çevirmen ajan kullanıyoruz:\n/** * Translates user messages to English * @param {String} message - User message to translate * @returns {String} - Translated message in English */ const translatorAgent = async (message) =\u0026gt; { try { const response = await axios({ method: \u0026#39;post\u0026#39;, url: \u0026#39;https://openrouter.ai/api/v1/chat/completions\u0026#39;, headers: { Authorization: `Bearer ${process.env.OPENROUTER_API_KEY}`, \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;, }, data: { model: \u0026#39;google/gemini-2.0-flash-001\u0026#39;, messages: [ { role: \u0026#39;system\u0026#39;, content: `You are a sophisticated AI agent specializing in translating user queries from multiple languages into English. Before translating, you identify and correct typos, grammatical errors, and punctuation mistakes in the source text to ensure clarity and readability. Your translations should maintain the original context and be culturally nuanced. Return only the translated text as plain text.`, }, { role: \u0026#39;user\u0026#39;, content: message, }, ], }, }); return response.data.choices[0].message.content.replace(/\\n+$/, \u0026#39;\u0026#39;); } catch (error) { console.error(\u0026#39;OpenRouter API error:\u0026#39;, error); return message; // Fallback to original message } }; Sistem daha sonra kullanıcının sorgusuyla aynı dilde yanıt verir. Bu, kullanıcının dilini eşleştirmesi için talimat verilen AI servisimiz tarafından yönetilir:\nconst messageContent = ` You are a helpful shopping assistant that can answer questions about products. Based on the user\u0026#39;s question \u0026#34;${prompt}\u0026#34;, analyze the product information in the context: ${context} and return information only about the most relevant matching product(s). Answer questions related to the ${category} of the product(s). Answer as humanly as possible and in the same language as the ${prompt}, but be careful with special names such as brand, model, etc. - don\u0026#39;t translate those. // ... additional instructions ... `; Dil Duyarlı Ürün Bilgileri Ürün bilgilerini görüntülerken, sistemin kullanıcının dil tercihini korumasını sağlıyoruz. AI, marka adları, model numaraları ve teknik özellikleri korurken açıklamaları kullanıcının dilinde oluşturur.\nÖrneğin, bir kullanıcı Türkçe olarak \u0026ldquo;Oyun için iyi bir laptop önerir misiniz?\u0026rdquo; diye sorduğunda, sistem:\nSorguyu İngilizce\u0026rsquo;ye çevirir: \u0026ldquo;Can you recommend a good laptop for gaming?\u0026rdquo; İngilizce sorgu kullanarak anlamsal arama gerçekleştirir Vektör veritabanından ilgili oyun dizüstü bilgisayarlarını getirir Teknik terimleri koruyarak oyun dizüstü bilgisayarlarını Türkçe olarak açıklayan bir yanıt oluşturur Bu yaklaşım, her dil için ayrı ürün veritabanları gerektirmeden sorunsuz bir çok dilli deneyim sağlar.\n5. AI Yanıt Üretimi Bağlamsal Yanıt Üretimi İlgili ürün bilgilerini aldıktan sonra, yardımcı ve bağlamsal bir yanıt üretmemiz gerekiyor. Bu amaçla Gemini API\u0026rsquo;sini kullanıyoruz ve gerekirse OpenRouter\u0026rsquo;a yedekleme yapıyoruz:\n/** * Generates a response using Gemini or falls back to OpenRouter API * @param {String} prompt - User message * @param {String} context - Product information or other context * @param {String} category - Message category * @param {Array} conversationHistory - Conversation history * @returns {String} - AI response */ const generateGeminiResponse = async (prompt, context, category, conversationHistory = []) =\u0026gt; { try { // Format conversation history for the AI model const formattedHistory = conversationHistory .map((msg) =\u0026gt; `${msg.role === \u0026#39;user\u0026#39; ? \u0026#39;User\u0026#39; : \u0026#39;Assistant\u0026#39;}: ${msg.content}`) .join(\u0026#39;\\n\u0026#39;); const messageContent = ` You are a helpful shopping assistant that can answer questions about products. Based on the user\u0026#39;s question \u0026#34;${prompt}\u0026#34;, analyze the product information in the context: ${context} and return information only about the most relevant matching product(s). Answer questions related to the ${category} of the product(s). Answer as humanly as possible and in the same language as the ${prompt}, but be careful with special names such as brand, model, etc. - don\u0026#39;t translate those. If the category is [PRODUCT_INFO] and the question is about general product information (like price, features, specifications etc), include [SHOW_PRODUCT_INFO] at the end of your response so that product information can be formatted and displayed to the user. If the question is specifically about product reviews, ratings or customer feedback, do not include [SHOW_PRODUCT_INFO]. Instead, focus on providing a summary of the reviews and ratings from the available data. Also consider follow up questions. If the user asks a follow up question about a product mentioned earlier, your answer should be about the SAME product. Do not switch to a different product unless the user explicitly asks about a new product. At the end of your response, include a JSON object with an array of product IDs that you referenced in your answer, in the format: [PRODUCT_IDS]{\u0026#34;ids\u0026#34;:[\u0026#34;id1\u0026#34;,\u0026#34;id2\u0026#34;]}[/PRODUCT_IDS] Here is the conversation history so far: ${formattedHistory} User: ${prompt} Assistant: `; try { // Use Gemini API const model = genAI.getGenerativeModel({ model: \u0026#39;gemini-2.0-flash\u0026#39;, systemInstruction: messageContent, }); const res = await model.generateContent(prompt); return res.response.text(); } catch (geminiError) { // Fall back to OpenRouter API if Gemini fails console.log(\u0026#39;Gemini API failed, trying OpenRouter API...\u0026#39;); const openRouterResponse = await axios.post( \u0026#39;https://openrouter.ai/api/v1/chat/completions\u0026#39;, { model: \u0026#39;anthropic/claude-3-opus:beta\u0026#39;, messages: [{ role: \u0026#39;user\u0026#39;, content: messageContent }], }, { headers: { Authorization: `Bearer ${process.env.OPENROUTER_API_KEY}`, \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;, }, } ); return openRouterResponse.data.choices[0].message.content; } } catch (error) { console.error(\u0026#39;Error generating AI response:\u0026#39;, error); return \u0026#39;Sorry, an error occurred while generating a response: \u0026#39; + error.message; } }; Ürün Bilgisi Görüntüleme Kullanıcı deneyimini geliştirmek için ürün bilgilerini görsel olarak çekici bir şekilde biçimlendiriyoruz. AI yanıtı, ürün detaylarının görüntülenmesi gerektiğinde özel bir etiket [SHOW_PRODUCT_INFO] içerir:\n/** * Formats product information into HTML for display * @param {Array} products - Array of product objects * @returns {String} - HTML formatted product information */ const formatProductInfo = (products) =\u0026gt; { if (!products || products.length === 0) { return \u0026#39;İlgili ürün bilgisi bulunamadı.\u0026#39;; } if (products.error) { return products.message; } let productsHTML = \u0026#39;\u0026lt;div class=\u0026#34;products-container\u0026#34;\u0026gt;\u0026#39;; products.forEach((product) =\u0026gt; { const parsedProduct = typeof product === \u0026#39;string\u0026#39; ? JSON.parse(product) : product; productsHTML += ` \u0026lt;div class=\u0026#34;product-card\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;product-image\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;${parsedProduct.thumbnail || parsedProduct.images?.[0]}\u0026#34; alt=\u0026#34;${parsedProduct.title || \u0026#39;Ürün Görseli\u0026#39;}\u0026#34; loading=\u0026#34;lazy\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;product-info\u0026#34;\u0026gt; \u0026lt;h3 class=\u0026#34;product-title\u0026#34;\u0026gt;${parsedProduct.title || \u0026#39;İsim belirtilmemiş\u0026#39;}\u0026lt;/h3\u0026gt; \u0026lt;p class=\u0026#34;product-description\u0026#34;\u0026gt;${parsedProduct.description || \u0026#39;Açıklama belirtilmemiş\u0026#39;}\u0026lt;/p\u0026gt; \u0026lt;div class=\u0026#34;product-price-container\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;product-price\u0026#34;\u0026gt;$${parsedProduct.price || \u0026#39;Fiyat belirtilmemiş\u0026#39;}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;a href=\u0026#34;/product/${parsedProduct.id}\u0026#34; class=\u0026#34;product-detail-button\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt; Detaylar \u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; `; }); productsHTML += \u0026#39;\u0026lt;/div\u0026gt;\u0026#39;; return productsHTML; }; AI ayrıca yanıtında ürün ID\u0026rsquo;lerini belirterek hangi ürünlerin görüntüleneceğini de belirleyebilir:\n// Extract product IDs from AI response const productIdsMatch = response.match(/\\[PRODUCT_IDS\\](.*?)\\[\\/PRODUCT_IDS\\]/); let productsToShow; if (productIdsMatch) { // Get product IDs specified by AI const productIds = JSON.parse(productIdsMatch[1]).ids; // Filter products to only show those with specified IDs productsToShow = products.filter((product) =\u0026gt; { const parsedProduct = typeof product === \u0026#39;string\u0026#39; ? JSON.parse(product) : product; return productIds.includes(parsedProduct.id.toString()); }); // Remove ID tags from response response = response.replace(/\\[PRODUCT_IDS\\].*?\\[\\/PRODUCT_IDS\\]/, \u0026#39;\u0026#39;); } else { // Show all products if no IDs specified productsToShow = products; } // Format product information and add to response const productInfo = productService.formatProductInfo(productsToShow); response = response + productInfo; Bu yaklaşım, AI\u0026rsquo;nin konuşma tarzında bir yanıt sağlarken aynı zamanda uygun olduğunda yapılandırılmış ürün bilgilerini de görüntülemesine olanak tanır.\n6. Mesaj Kategorizasyonu Kullanıcı Niyetini Anlama Daha ilgili yanıtlar sağlamak için, kullanıcı mesajlarını niyetlerine göre kategorize ediyoruz. Bu, sistemin nasıl yanıt vereceğini ve hangi bilgileri dahil edeceğini belirlemesine yardımcı olur:\n/** * Categorizes user messages into predefined categories * @param {String} message - User message to categorize * @returns {String} - Category of the message */ const categorizerAgent = async (message) =\u0026gt; { try { const response = await axios({ method: \u0026#39;post\u0026#39;, url: \u0026#39;https://openrouter.ai/api/v1/chat/completions\u0026#39;, headers: { Authorization: `Bearer ${process.env.OPENROUTER_API_KEY}`, \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;, }, data: { model: \u0026#39;google/gemini-2.0-flash-001\u0026#39;, messages: [ { role: \u0026#39;system\u0026#39;, content: `You are a sophisticated AI agent specializing in categorizing user queries into one of the following categories: [PRODUCT_INFO] - Questions about product information, features, specifications, price, etc. [PRODUCT_COMPARISON] - Questions comparing multiple products [PRODUCT_RECOMMENDATION] - Questions asking for product recommendations [PRODUCT_AVAILABILITY] - Questions about product availability [PRODUCT_REVIEWS] - Questions about product reviews or ratings [GENERAL_INQUIRY] - General questions not related to specific products [CUSTOMER_SERVICE] - Questions about customer service, shipping, returns, etc. [OTHER] - Any other type of question Return only the category as plain text.`, }, { role: \u0026#39;user\u0026#39;, content: message, }, ], }, }); return response.data.choices[0].message.content.replace(/\\n+$/, \u0026#39;\u0026#39;); } catch (error) { console.error(\u0026#39;OpenRouter API error:\u0026#39;, error); return \u0026#39;[GENERAL_INQUIRY]\u0026#39;; } }; Kategoriye Göre Yanıt Özelleştirme Farklı soru kategorileri farklı türde yanıtlar gerektirir. Sistemimiz tespit edilen kategoriye göre davranışını ayarlar:\n[PRODUCT_INFO]: Detaylı ürün özellikleri içerir ve ürün kartlarını görüntüler [PRODUCT_COMPARISON]: Ürünler arasındaki farkları vurgular [PRODUCT_RECOMMENDATION]: Kullanıcı kriterlerine göre ürünler önerir [PRODUCT_REVIEWS]: Müşteri geri bildirimleri ve değerlendirmelerine odaklanır [GENERAL_INQUIRY]: Belirli ürün detayları olmadan genel bilgi sağlar Bu kategorizasyon, sistemin çok çeşitli kullanıcı sorgularına daha ilgili ve yardımcı yanıtlar sağlamasına yardımcı olur.\n7. Sistem Mimarisi ve Uygulama Temiz Mimari Tasarımı EcommerceRAG projemiz, net bir sorumluluk ayrımı ile temiz mimari desenini takip eder:\nControllers: HTTP isteklerini ve yanıtlarını yönetir Services: İş mantığını ve harici API etkileşimlerini içerir Routes: API uç noktalarını tanımlar Utils: Yardımcı fonksiyonları sağlar Config: Yapılandırma ayarlarını yönetir Middlewares: Ara yazılım fonksiyonlarını uygular Bu modüler tasarım, kod tabanını daha bakımı kolay, test edilebilir ve ölçeklenebilir hale getirir.\nAna Bileşenler Sistemimizin ana bileşenleri şunları içerir:\nChat Controller: Kullanıcı mesajlarını işler ve yanıt üretimini koordine eder Vector Service: Weaviate vektör veritabanı ile etkileşimleri yönetir AI Service: AI model etkileşimlerini yönetir (Gemini ve OpenAI) Product Service: Ürünle ilgili servisleri sağlar Conversation Service: Konuşma kalıcılığını ve erişimini yönetir Agent Controller: Çeviri, kategorizasyon ve sınıflandırma için ajan mantığını içerir İşlem Akışı Sistemimizde ana işlem akışı processChat fonksiyonu tarafından yönetilir:\n/** * Processes chat messages and generates AI responses * @param {Object} req - Express request object * @param {Object} res - Express response object */ const processChat = async (req, res) =\u0026gt; { try { let { message, conversationId } = req.body; if (!message) { return res.status(400).json({ error: \u0026#39;Message is required\u0026#39; }); } // Categorize the message const category = await categorizerAgent(message); // Get existing conversation or create new one let conversation; try { if (conversationId) { conversation = await conversationService.getConversationById(conversationId); } else { conversation = await conversationService.createConversation(); } } catch (error) { // Create a new conversation in case of error conversation = await conversationService.createConversation(); } // Add user message to conversation await conversationService.addMessageToConversation(conversation._id, \u0026#39;user\u0026#39;, message); // Get conversation history (last 4 messages) const conversationHistory = await conversationService.getConversationMessages(conversation._id, 4); // Translate message to English let translatedMessage = await translatorAgent(message); // Determine if message is a follow-up question let isFollowUp = false; if (conversationHistory.length \u0026gt;= 3) { // Use classifierAgent to determine if it\u0026#39;s a follow-up const response = await classifierAgent(conversationHistory); const parsedResponse = JSON.parse(response); isFollowUp = parsedResponse; } // Prepare search query let searchQuery = translatedMessage; if (isFollowUp \u0026amp;\u0026amp; conversationHistory.length \u0026gt;= 3) { // Find previous user messages (last 2 user messages) const userMessages = conversationHistory.filter((msg) =\u0026gt; msg.role === \u0026#39;user\u0026#39;).slice(-2); if (userMessages.length \u0026gt;= 2) { const previousUserMessage = userMessages[0].content; // Previous user message searchQuery = `${await translatorAgent(previousUserMessage)} ${translatedMessage}`; } } // Get product information from Weaviate const products = await vectorService.getProductInfo(searchQuery); // Process response based on product information let response; if (products \u0026amp;\u0026amp; products.length \u0026gt; 0) { // Send product information to AI in JSON format const productContext = JSON.stringify(products); // Send category and conversation history to AI response = await aiService.generateGeminiResponse(message, productContext, category, conversationHistory); // Clean [SHOW_PRODUCT_INFO] tag const cleanedResponse = response.replace(\u0026#39;[SHOW_PRODUCT_INFO]\u0026#39;, \u0026#39;\u0026#39;); await conversationService.addMessageToConversation(conversation._id, \u0026#39;assistant\u0026#39;, cleanedResponse); // Check if product information should be displayed if (response.includes(\u0026#39;[SHOW_PRODUCT_INFO]\u0026#39;)) { // Process and display product information // ... (code omitted for brevity) } } else { // If no product information found const productInfo = JSON.stringify({ message: \u0026#39;İlgili ürün bilgisi bulunamadı.\u0026#39; }); response = await aiService.generateGeminiResponse(message, productInfo, category, conversationHistory); const cleanedResponse = response.replace(\u0026#39;[SHOW_PRODUCT_INFO]\u0026#39;, \u0026#39;\u0026#39;); await conversationService.addMessageToConversation(conversation._id, \u0026#39;assistant\u0026#39;, cleanedResponse); } // Return response res.json({ response: response, conversationId: conversation._id.toString(), timestamp: new Date().toISOString(), }); } catch (error) { console.error(\u0026#39;Chat processing error:\u0026#39;, error); res.status(500).json({ error: \u0026#39;Mesaj işlenirken bir hata oluştu: \u0026#39; + error.message }); } }; Bu fonksiyon, kullanıcı mesajını almaktan AI tarafından oluşturulan yanıtı döndürmeye kadar tüm süreci orkestra eder.\n8. Frontend Entegrasyonu Sohbet Widget\u0026rsquo;ı Uygulaması RAG sistemimizi kullanıcılara erişilebilir kılmak için, herhangi bir e-ticaret web sitesine kolayca entegre edilebilen bir sohbet widget\u0026rsquo;ı uyguladık. Widget, vanilla JavaScript ile oluşturulmuştur ve herhangi bir sayfaya basit bir script etiketi ile eklenebilir:\n\u0026lt;script src=\u0026#34;https://your-domain.com/js/widget.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; Widget, kullanıcıların AI asistanımızla etkileşime girmesi için temiz, sezgisel bir arayüz sağlar:\n// Widget initialization function initWidget() { // Create widget HTML const widgetContainer = document.createElement(\u0026#39;div\u0026#39;); widgetContainer.innerHTML = createWidgetHTML(); document.body.appendChild(widgetContainer); // Set up event listeners const chatForm = document.getElementById(\u0026#39;chachaForm\u0026#39;); const messageInput = document.getElementById(\u0026#39;chachaMessageInput\u0026#39;); const chatMessages = document.getElementById(\u0026#39;chachaMessages\u0026#39;); // Initialize conversationId as null (no longer using localStorage) let conversationId = null; // Add welcome message addMessage(\u0026#39;Merhaba! Alışverişinizde size nasıl yardımcı olabilirim?\u0026#39;, \u0026#39;bot\u0026#39;); // Form submission handler chatForm.addEventListener(\u0026#39;submit\u0026#39;, async (e) =\u0026gt; { e.preventDefault(); const message = messageInput.value.trim(); if (!message) return; // Add user message to chat addMessage(message, \u0026#39;user\u0026#39;); messageInput.value = \u0026#39;\u0026#39;; messageInput.style.height = \u0026#39;auto\u0026#39;; // Add loading indicator const loadingMessage = addLoadingMessage(); try { // Send message to API const response = await fetch(\u0026#39;/api/chat\u0026#39;, { method: \u0026#39;POST\u0026#39;, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;, }, body: JSON.stringify({ message, conversationId, }), }); // Remove loading indicator loadingMessage.remove(); if (response.ok) { const data = await response.json(); // Add AI response to chat if (data.response) { addMessage(data.response, \u0026#39;bot\u0026#39;, true); } else if (data.data \u0026amp;\u0026amp; data.data.message) { addMessage(data.data.message, \u0026#39;bot\u0026#39;, true); } else if (data.message) { addMessage(data.message, \u0026#39;bot\u0026#39;, true); } else { addMessage(\u0026#39;Üzgünüm, bir hata oluştu. Lütfen tekrar deneyin.\u0026#39;, \u0026#39;bot\u0026#39;); } // Store conversation ID for future messages if (data.conversationId) { conversationId = data.conversationId; } } else { addMessage(\u0026#39;Üzgünüm, bir hata oluştu. Lütfen tekrar deneyin.\u0026#39;, \u0026#39;bot\u0026#39;); } } catch (error) { console.error(\u0026#39;Error:\u0026#39;, error); loadingMessage.remove(); addMessage(\u0026#39;Üzgünüm, bir hata oluştu. Lütfen tekrar deneyin.\u0026#39;, \u0026#39;bot\u0026#39;); } }); } ### Duyarlı Tasarım Sohbet widget\u0026#39;ı hem masaüstü hem de mobil cihazlarda iyi çalışacak şekilde duyarlı olarak tasarlanmıştır: ```javascript // Mobile device detection const isMobile = window.matchMedia(\u0026#39;(max-width: 480px)\u0026#39;).matches; // Chat toggle functionality chatToggle.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { chatContainer.classList.toggle(\u0026#39;collapsed\u0026#39;); // Prevent body scroll when chat is open on mobile if (isMobile \u0026amp;\u0026amp; !chatContainer.classList.contains(\u0026#39;collapsed\u0026#39;)) { document.body.style.overflow = \u0026#39;hidden\u0026#39;; } else if (isMobile) { document.body.style.overflow = \u0026#39;\u0026#39;; } }); // Window resize handler window.addEventListener(\u0026#39;resize\u0026#39;, () =\u0026gt; { const isMobileNow = window.matchMedia(\u0026#39;(max-width: 480px)\u0026#39;).matches; // Update body scroll behavior on resize if (isMobileNow \u0026amp;\u0026amp; !chatContainer.classList.contains(\u0026#39;collapsed\u0026#39;)) { document.body.style.overflow = \u0026#39;hidden\u0026#39;; } else if (isMobileNow) { document.body.style.overflow = \u0026#39;\u0026#39;; } }); HTML Oluşturma ve Stil Widget, temiz, modern bir görünüm için CSS stilleri içerir:\n.chacha-widget { position: fixed; bottom: 20px; right: 20px; z-index: 1000; font-family: \u0026#39;Segoe UI\u0026#39;, Tahoma, Geneva, Verdana, sans-serif; } .chat-toggle { width: 60px; height: 60px; border-radius: 50%; background-color: #2563EB; color: white; border: none; cursor: pointer; display: flex; align-items: center; justify-content: center; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15); transition: all 0.3s ease; } .chat-container { position: absolute; bottom: 80px; right: 0; width: 350px; height: 500px; background-color: white; border-radius: 12px; box-shadow: 0 5px 25px rgba(0, 0, 0, 0.2); display: flex; flex-direction: column; transition: all 0.3s ease; overflow: hidden; } /* Additional styles omitted for brevity */ Widget, mesajlar ve ürün kartları için HTML\u0026rsquo;i dinamik olarak oluşturarak zengin bir kullanıcı deneyimi sağlar.\n9. Test ve Değerlendirme Postman ile API Testi Sistemimizin doğru çalıştığından emin olmak için, tüm uç noktaları test etmek üzere kapsamlı bir Postman koleksiyonu oluşturduk:\n{ \u0026#34;info\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;ecommerceRAG API\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;A collection for testing the ecommerceRAG API endpoints\u0026#34;, \u0026#34;schema\u0026#34;: \u0026#34;https://schema.getpostman.com/json/collection/v2.1.0/collection.json\u0026#34; }, \u0026#34;item\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Chat\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Endpoints for chat functionality\u0026#34;, \u0026#34;item\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Process Chat Message\u0026#34;, \u0026#34;request\u0026#34;: { \u0026#34;method\u0026#34;: \u0026#34;POST\u0026#34;, \u0026#34;header\u0026#34;: [ { \u0026#34;key\u0026#34;: \u0026#34;Content-Type\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;application/json\u0026#34; } ], \u0026#34;body\u0026#34;: { \u0026#34;mode\u0026#34;: \u0026#34;raw\u0026#34;, \u0026#34;raw\u0026#34;: \u0026#34;{\\n \\\u0026#34;message\\\u0026#34;: \\\u0026#34;What laptops do you have?\\\u0026#34;,\\n \\\u0026#34;conversationId\\\u0026#34;: null\\n}\u0026#34; }, \u0026#34;url\u0026#34;: { \u0026#34;raw\u0026#34;: \u0026#34;{{baseUrl}}/api/chat\u0026#34;, \u0026#34;host\u0026#34;: [ \u0026#34;{{baseUrl}}\u0026#34; ], \u0026#34;path\u0026#34;: [ \u0026#34;api\u0026#34;, \u0026#34;chat\u0026#34; ] }, \u0026#34;description\u0026#34;: \u0026#34;Process a chat message and get a response from the AI\u0026#34; } }, { \u0026#34;name\u0026#34;: \u0026#34;Process Follow-up Message\u0026#34;, \u0026#34;request\u0026#34;: { \u0026#34;method\u0026#34;: \u0026#34;POST\u0026#34;, \u0026#34;header\u0026#34;: [ { \u0026#34;key\u0026#34;: \u0026#34;Content-Type\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;application/json\u0026#34; } ], \u0026#34;body\u0026#34;: { \u0026#34;mode\u0026#34;: \u0026#34;raw\u0026#34;, \u0026#34;raw\u0026#34;: \u0026#34;{\\n \\\u0026#34;message\\\u0026#34;: \\\u0026#34;What is the price range?\\\u0026#34;,\\n \\\u0026#34;conversationId\\\u0026#34;: \\\u0026#34;{{conversationId}}\\\u0026#34;\\n}\u0026#34; }, \u0026#34;url\u0026#34;: { \u0026#34;raw\u0026#34;: \u0026#34;{{baseUrl}}/api/chat\u0026#34;, \u0026#34;host\u0026#34;: [ \u0026#34;{{baseUrl}}\u0026#34; ], \u0026#34;path\u0026#34;: [ \u0026#34;api\u0026#34;, \u0026#34;chat\u0026#34; ] }, \u0026#34;description\u0026#34;: \u0026#34;Process a follow-up message in an existing conversation\u0026#34; } } ] }, { \u0026#34;name\u0026#34;: \u0026#34;Conversations\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Endpoints for managing conversations\u0026#34;, \u0026#34;item\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Get All Conversations\u0026#34;, \u0026#34;request\u0026#34;: { \u0026#34;method\u0026#34;: \u0026#34;GET\u0026#34;, \u0026#34;url\u0026#34;: { \u0026#34;raw\u0026#34;: \u0026#34;{{baseUrl}}/api/conversations\u0026#34;, \u0026#34;host\u0026#34;: [ \u0026#34;{{baseUrl}}\u0026#34; ], \u0026#34;path\u0026#34;: [ \u0026#34;api\u0026#34;, \u0026#34;conversations\u0026#34; ] }, \u0026#34;description\u0026#34;: \u0026#34;Get a list of all conversations\u0026#34; } } // Additional endpoints omitted for brevity ] }, { \u0026#34;name\u0026#34;: \u0026#34;Products\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Endpoints for product information\u0026#34;, \u0026#34;item\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Get Product Detail\u0026#34;, \u0026#34;request\u0026#34;: { \u0026#34;method\u0026#34;: \u0026#34;GET\u0026#34;, \u0026#34;url\u0026#34;: { \u0026#34;raw\u0026#34;: \u0026#34;{{baseUrl}}/product/{{productId}}\u0026#34;, \u0026#34;host\u0026#34;: [ \u0026#34;{{baseUrl}}\u0026#34; ], \u0026#34;path\u0026#34;: [ \u0026#34;product\u0026#34;, \u0026#34;{{productId}}\u0026#34; ] }, \u0026#34;description\u0026#34;: \u0026#34;Get detailed information about a specific product\u0026#34; } } ] } ] } Performans Değerlendirmesi Sistemimizi birkaç temel metrik üzerinde değerlendirdik:\nYanıt Süresi: Yanıt üretmek için gereken ortalama süre İlgililik: Getirilen ürünlerin kullanıcı sorgusuna ne kadar iyi eşleştiği Konuşma Tutarlılığı: Sistemin takip sorularında bağlamı ne kadar iyi koruduğu Dil Desteği: Farklı dillerdeki yanıtların doğruluğu Testimiz, sistemin bu metrikler genelinde iyi performans gösterdiğini, özellikle konuşma bağlamını koruma ve ilgili ürün bilgilerini sağlama konularında güçlü sonuçlar elde ettiğini gösterdi.\n10. Gelecek İyileştirmeler Kişiselleştirme Gelecek versiyonlar, daha kişiselleştirilmiş öneriler sağlamak için kullanıcı tercihlerini ve satın alma geçmişini dahil edebilir. Bu şunları içerecektir:\nKullanıcı etkileşimlerini ve tercihlerini takip etme RAG sürecine kullanıcı profil bilgilerini dahil etme Ürün sıralamalarını kullanıcı geçmişine göre ayarlama Gelişmiş Ürün Karşılaştırması Sistemin ürünleri karşılaştırma yeteneğini şu şekilde geliştirebiliriz:\nYapılandırılmış ürün özelliği çıkarımı uygulama Karşılaştırma sorguları için özelleştirilmiş istemler oluşturma Görsel karşılaştırma gösterimleri geliştirme Ses Arayüzü Özellikle mobil kullanıcılar için sistemi daha erişilebilir ve kullanışlı hale getirmek için ses girişi ve çıkışı ekleme:\nKullanıcı sorguları için konuşmadan metne dönüştürme AI yanıtları için metinden konuşmaya dönüştürme Sese özel etkileşim kalıplarını destekleme Analitik ve Geri Bildirim Döngüsü Sistemin zamanla iyileşmesine yardımcı olmak için analitik uygulaması:\nBaşarılı ve başarısız etkileşimleri takip etme Yaygın kullanıcı sorgularını ve sorun noktalarını analiz etme RAG sürecini ince ayarlamak için geri bildirimi kullanma Sonuç Bu makalede, Retrieval-Augmented Generation (RAG) teknolojisinin daha akıllı, bağlama duyarlı ürün araması ve önerileri sağlayarak e-ticaret uygulamalarını nasıl dönüştürebileceğini inceledik. Vektör veritabanlarını, anlamsal aramayı, konuşma hafızasını ve çok dilli desteği birleştiren eksiksiz bir RAG sistemi uyguladık.\nSistemimizin temel bileşenleri şunları içerir:\nVektör Veritabanı: Anlamsal arama için ürün gömmelerini depolama Konuşma Yönetimi: Takip soruları için bağlamı koruma Çok Dilli Destek: Kullanıcıların tercih ettikleri dilde etkileşime girmesine olanak sağlama AI Yanıt Üretimi: Yardımcı, bağlamsal yanıtlar oluşturma Mesaj Kategorizasyonu: Kullanıcı niyetini anlama Temiz Mimari: Bakım yapılabilirlik ve ölçeklenebilirliği sağlama Bu bileşenleri birleştirerek, karmaşık ürün sorgularını anlayabilen, konuşma bağlamını koruyabilen ve birden çok dilde doğru, yardımcı yanıtlar sağlayabilen bir sistem oluşturduk.\nBu projenin tüm kodlarına GitHub deposundan erişebilir ve kendi RAG tabanlı uygulamalarınız için bir başlangıç noktası olarak kullanabilirsiniz.\n",
    "tags": ["rag","vectordb","nodejs","ai"],
    "categories": ["AI"],
    "lang": "tr"
} 