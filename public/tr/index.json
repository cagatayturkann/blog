[{
        "title": "Modern AI Teknolojileri ve Node.js Entegrasyonu",
        "permalink": "/blog/tr/modern-ai-teknolojileri-nodejs-entegrasyonu/",
        "summary": "Bu makalede, yapay zeka teknolojilerinin JavaScript ekosistemindeki uygulamalarını inceleyeceğiz. AI agent\u0026rsquo;lar, tool calling, conversation memory, context yönetimi gibi temel kavramların Node.js uygulamalarında nasıl hayata geçirileceğini örnek projeler üzerinden ele alacağız.",
        "content": "Modern AI Teknolojileri ve Node.js Entegrasyonu Giriş Yapay zeka teknolojileri, özellikle dil modelleri, yazılım geliştirme dünyasını hızla dönüştürüyor. Node.js gibi popüler bir platform ile AI teknolojilerini entegre etmek, JavaScript ekosisteminde çalışan geliştiricilere inanılmaz fırsatlar sunuyor. Bu makalede, modern AI konseptlerini Node.js çerçevesinde nasıl uygulayabileceğimizi inceleyeceğiz.\nBu yazı size şunları kazandıracak:\nAI terminolojisini ve temel kavramlarını anlama Node.js ile LLM (Large Language Model) entegrasyonu AI agent\u0026rsquo;lar oluşturma ve araç çağırma (tool calling) yeteneğini anlama Açık kaynak AI teknolojilerini (Ollama, LiteLLM, LlamaCPP) Node.js uygulamalarında kullanma Otomatik iş akışları için N8n ile AI entegrasyonu Projelerin tam kodlarına GitHub repository adresinden erişebilirsiniz.\n1. AI Agent\u0026rsquo;lar: Akıllı Asistanlar Geliştirme AI Agent Nedir? AI agent, LLM\u0026rsquo;leri (Large Language Models) kullanarak belirli görevleri gerçekleştirmek üzere tasarlanmış yazılım sistemleridir. Bu ajanlar, insan benzeri düşünme, karar verme ve çevresiyle etkileşim kurma yeteneklerine sahiptir. AI agent\u0026rsquo;ı, belirli görevleri yerine getirmek üzere tasarlanmış otonom bir yazılım bileşenidir. Bu agentlar:\nVeri alır (input): Örneğin, kullanıcıdan gelen sorgular veya sistemden gelen veriler. İşlem yapar (processing): Bu veriler üzerinde analiz yapar, karar verir veya model çalıştırır. Çıktı verir (output): Sonuçları veya eylemleri gerçekleştirir. Modern AI agent\u0026rsquo;lar tipik olarak şu bileşenleri içerir:\nLLM (Beyin): Doğal dil anlama ve üretme yeteneği Bellek (Memory): Geçmiş etkileşimleri hatırlama Araçlar (Tools): API\u0026rsquo;ler, veritabanları ve diğer sistemlerle etkileşime geçme yeteneği Planlama: Karmaşık görevleri alt görevlere bölebilme AI Agent\u0026rsquo;lar reaktif yani herhangi bir kullanıcı tetikleyicisi olmadan kendi başına veri toplama, çevri analizi vs işlemler yapmayan basit agentlar olabileceği gibi daha yaygın olarak otonom da olabilir. Otonom bir agent; örneğin, bir akıllı ev sisteminde olduğu gibi, ortamı sürekli izleyebilir, belirli durumları algılayıp kendi kararlarını verebilir. Bu tarz bir agent; sürekli sensör vb kaynaklardan veri toplar, bu verileri analiz eder ve bu analize göre kendi başına belirli görevler başlatır veya ayarlar.\nNode.js ile AI Agent Oluşturma Node.js ve OpenAI API kullanarak basit bir otonom agent örneği yapalım. Bu örnekte, ajan belirli aralıklarla \u0026ldquo;sensör verisi\u0026rdquo; üretip, bu veriye göre OpenAI\u0026rsquo;dan aldığı karara göre hareket ediyor. Öncelikle gerekli paketi indiriyoruz.\nnpm install openai Daha sonra ise kodumuz aşağıdaki şekilde.\nconst { OpenAI } = require(\u0026#39;openai\u0026#39;); // OpenAI yapılandırması: API anahtarınızı buraya ekleyin. const openai = new OpenAI({ apiKey: \u0026#39;your-api-key\u0026#39;, }); // Otonom ajan fonksiyonu async function autonomousAgent() { console.log(\u0026#39;Ajan çalışmaya başladı...\u0026#39;); // 1. Adım: Sensör verisini simüle et (örneğin, rastgele bir sayı) const sensorData = Math.random() * 100; console.log(\u0026#39;Sensör verisi:\u0026#39;, sensorData); // 2. Adım: Sensör verisine dayalı karar vermek için OpenAI\u0026#39;ya prompt gönder const prompt = `Sensör verisi: ${sensorData}. Eğer veri 50\u0026#39;den büyükse \u0026#34;Alarm\u0026#34;, 50 veya daha düşükse \u0026#34;Normal\u0026#34; sonucunu tek kelime olarak ver.`; try { const response = await openai.chat.completions.create({ model: \u0026#39;gpt-4o-mini\u0026#39;, messages: [{ role: \u0026#39;user\u0026#39;, content: prompt }], max_tokens: 10, temperature: 0.3, }); const decision = response.choices[0].message.content.trim(); console.log(\u0026#39;Ajan Kararı:\u0026#39;, decision); // 3. Adım: OpenAI\u0026#39;dan gelen karara göre hareket et if (decision === \u0026#39;Alarm\u0026#39;) { console.log(\u0026#39;Alarm durumu tespit edildi, gerekli işlemleri başlatıyor...\u0026#39;); // Burada alarmı tetiklemek veya bildirim göndermek gibi işlemler yapılabilir. } else if (decision === \u0026#39;Normal\u0026#39;) { console.log(\u0026#39;Durum normal, bekleme modunda...\u0026#39;); // Normal durumda yapılacak başka işlemler eklenebilir. } else { console.log(\u0026#39;Bilinmeyen karar, tekrar kontrol ediliyor...\u0026#39;); // Beklenmeyen durumlarda hata yönetimi yapılabilir. } } catch (error) { console.error(\u0026#39;Hata oluştu:\u0026#39;, error); } } // Ajanı her 30 saniyede bir otomatik olarak çalıştır. setInterval(autonomousAgent, 10000); // Program başladığında hemen bir kere çalıştır. autonomousAgent(); Bu kod parçasını daha detaylı açıklayacak olursak\nSensör Verisi Üretimi: Agent, her çalıştığında rastgele bir sayı üretiyor. Bu sayı, örnek bir sensör verisi olarak düşünülüyor. Karar Süreci: Üretilen sensör verisi, bir prompt içerisinde OpenAI API\u0026rsquo;ya gönderiliyor. Bu prompt, veriye göre \u0026ldquo;Alarm\u0026rdquo; veya \u0026ldquo;Normal\u0026rdquo; kelimesi döndürmesini istiyor. Eylem: OpenAI\u0026rsquo;dan gelen yanıt, agentın kararını belirliyor. Eğer yanıt \u0026ldquo;Alarm\u0026rdquo; ise, agent alarm durumunu tetikleyen işlemleri gerçekleştiriyor; \u0026ldquo;Normal\u0026rdquo; ise, bekleme modunda kalıyor. Otonomluk: Agent, kullanıcı müdahalesi olmadan belirli aralıklarla (burada her 30 saniyede bir) kendi başına çalışarak, sensör verisini değerlendiriyor ve otomatik olarak karar veriyor. Bu örnek, otonom agent kavramını, sadece kullanıcı girdisine bağlı olmayan, kendi kendini tetikleyen ve belirli şartlara göre karar veren bir yapı olarak göstermektedir. Böylece, sistem belirli bir zaman döngüsünde bağımsız çalışarak çevresel veriye göre eylem alabiliyor.\nAI Agent Çalışma Prensibi AI agent\u0026rsquo;lar genellikle şu adımları izler:\nDüşünme: İstenen görev için bir plan oluşturma Aracı Seçme: Görevi tamamlamak için hangi aracı kullanacağına karar verme Eylem: Seçilen aracı kullanarak belirli bir eylemi gerçekleştirme Gözlemleme: Eylemin sonucunu inceleme İlerleme: Sonuca göre yeni bir düşünme-eylem döngüsü başlatma Bu yaklaşım ReAct (Reasoning and Acting) olarak bilinir ve LLM\u0026rsquo;in düşünmeyle eylemi birleştirmesini sağlar.\nNeden Bu Özellik Önemli? Otomatikleştirilebilir işlemleri akıllı asistanlara devredebilirsiniz İnsan kullanıcılara daha doğal bir arayüz sunabilirsiniz Karmaşık iş akışlarını modüler araçlarla basitleştirebilirsiniz 2. Embedding, RAG, VectorDB Embedding Embedding, metin veya diğer veri türlerini sayısal vektörlere dönüştürme işlemidir. Bu vektörler, verinin anlamsal özelliklerini sayısal formatta temsil eder. Örneğin, \u0026ldquo;köpek\u0026rdquo; ve \u0026ldquo;kedi\u0026rdquo; kelimeleri birbirine yakın vektörlerle temsil edilirken, \u0026ldquo;araba\u0026rdquo; daha uzak bir vektörle temsil edilir.\nEmbeddingler şu amaçlarla kullanılır:\nMetin benzerliği hesaplama Doküman sınıflandırma Semantik arama Öneriler oluşturma Duygu analizi Metin özetleme Doğal dil işleme görevleri Embedding\u0026rsquo;lerin çalışma prensibi şu şekildedir:\nTokenization: Metin önce daha küçük parçalara (token) ayrılır Vektör Dönüşümü: Her token, yüzlerce veya binlerce boyutlu bir vektöre dönüştürülür Normalizasyon: Vektörler normalize edilerek karşılaştırılabilir hale getirilir Embedding\u0026rsquo;lerin en önemli özelliği, benzer anlamlara sahip içeriklerin vektör uzayında birbirine yakın konumlanmasıdır. Bu sayede, metin tabanlı aramalarda kelime eşleştirmeden ziyade anlam bazlı sonuçlar elde edilebilir. Örneğin, \u0026ldquo;mutlu\u0026rdquo; ve \u0026ldquo;sevinçli\u0026rdquo; kelimeleri vektör uzayında birbirine yakın konumlanırken, \u0026ldquo;üzgün\u0026rdquo; kelimesi uzak bir noktada yer alır.\nRAG (Retrieval Augmented Generation) RAG, büyük dil modellerinin (LLM) mevcut bilgi tabanını harici kaynaklarla zenginleştiren bir tekniktir. RAG sistemi şu şekilde çalışır:\nRetrieval (Getirme):\nKullanıcı sorusu ile ilgili dokümanlar veya bilgiler veritabanından çekilir Semantic search kullanılarak en alakalı içerikler bulunur Embedding benzerliği ile dokümanlar sıralanır Augmentation (Zenginleştirme):\nBulunan bilgiler LLM\u0026rsquo;e gönderilen prompt\u0026rsquo;a eklenir Bilgiler önem sırasına göre düzenlenir Bağlam penceresi optimize edilir Generation (Üretim):\nLLM, zenginleştirilmiş bağlamı kullanarak yanıt üretir Yanıt, verilen kaynaklara referans verebilir Güvenilirlik skoru hesaplanabilir RAG\u0026rsquo;ın avantajları:\nGüncel bilgi kullanımı Doğruluk oranının artması Özelleştirilmiş yanıtlar Hallüsinasyonların azalması Kaynakların takip edilebilirliği Dinamik bilgi güncelleme imkanı Domain-specific bilgi entegrasyonu Vector DB Vector veritabanları, embedding vektörlerini depolamak ve bu vektörler üzerinde benzerlik araması yapmak için özelleştirilmiş veritabanı sistemleridir. Geleneksel veritabanlarından farklı olarak, vektörler arasındaki benzerliği hızlı bir şekilde hesaplayabilirler.\nVector DB\u0026rsquo;lerin temel özellikleri:\nYüksek boyutlu vektörleri verimli şekilde depolama Benzerlik bazlı arama (cosine similarity, euclidean distance) Hızlı yakın komşu (nearest neighbor) sorguları Ölçeklenebilirlik CRUD operasyonları Metadata filtreleme Batch işlem desteği Vektör indeksleme Vector DB\u0026rsquo;ler özellikle şu alanlarda kullanılır:\nSemantik doküman araması Öneri sistemleri Görüntü ve ses benzerliği analizi Doğal dil işleme uygulamaları Yüz tanıma sistemleri Anomali tespiti Çapraz modal arama (text-to-image, image-to-text) Popüler Vector DB çözümleri:\nPinecone: Tam yönetilen, ölçeklenebilir çözüm Weaviate: Açık kaynak, self-hosted seçeneği Milvus: Yüksek performanslı, dağıtık mimari Qdrant: Rust tabanlı, hızlı ve hafif ChromaDB: Python odaklı, başlangıç için ideal 3. Tool Calling: AI\u0026rsquo;a Yeni Yetenekler Kazandırma Tool Calling Nedir? Tool calling (araç çağırma), bir AI modelinin dış fonksiyonları veya API\u0026rsquo;leri çağırabilme yeteneğidir. Bu, AI\u0026rsquo;ın kendi bilgi sınırları dışındaki işlemleri gerçekleştirmesini sağlar.\nModern LLM\u0026rsquo;ler, JSON formatında araç çağrısı yapabilme yeteneğine sahiptir. Bu, modelin gerçekleştirmek istediği eylemi ve gerekli parametreleri tanımlamasını sağlar.\nNode.js ile Tool Calling OpenAI API\u0026rsquo;sini kullanarak tool calling implementasyonu yapalım. Aşağıdaki örnekte, Node.js kullanarak \u0026ldquo;tool calling\u0026rdquo; kavramını gösteren bir agent oluşturuyoruz. Bu agent iki farklı \u0026ldquo;aracı\u0026rdquo; çağırıyor:\nHava Durumu API\u0026rsquo;si (OpenWeatherMap): Agent, belirli bir konum için güncel hava durumu verisini alıyor. - OpenAI API: Aldığı hava durumu verisini kullanarak, günün nasıl geçtiğine dair kısa bir analiz istiyor. Bu iki aracı ardışık şekilde kullanarak, ajanın dış kaynaklardan veri toplayıp bu veriyi işlediğini görebiliriz.\nÖncelikle gerekli kütüphaneleri indiriyoruz\nnpm install axios openai Örnek kodumuz ise aşağıdaki şekilde.\nconst axios = require(\u0026#39;axios\u0026#39;); const { OpenAI } = require(\u0026#39;openai\u0026#39;); // API anahtarlarınızı girin const WEATHER_API_KEY = \u0026#39;\u0026lt;your-api-key\u0026gt;\u0026#39;; // OpenWeatherMap API anahtarınız // Hava durumu sorgulanacak konum const LOCATION = \u0026#39;Istanbul\u0026#39;; // OpenAI yapılandırması const openai = new OpenAI({ apiKey: \u0026#39;\u0026lt;your-api-key\u0026gt;\u0026#39;, }); // 1. Adım: Hava Durumu API\u0026#39;sini çağıran fonksiyon async function getWeatherData(location) { try { const response = await axios.get( `https://api.openweathermap.org/data/2.5/weather?q=${location}\u0026amp;appid=${WEATHER_API_KEY}\u0026amp;units=metric` ); return response.data; } catch (error) { console.error(\u0026#39;Hava durumu API hatası:\u0026#39;, error); return null; } } // 2. Adım: OpenAI API\u0026#39;ye veriyi gönderip analiz yapan fonksiyon async function analyzeWeather(weatherData) { if (!weatherData) return \u0026#39;Hava durumu verisi alınamadı.\u0026#39;; // Hava durumu verisine dayalı prompt oluşturma const prompt = `Şu an ${weatherData.name}\u0026#39;de hava ${weatherData.weather[0].description} ve sıcaklık ${weatherData.main.temp}°C. Bu hava durumuna göre, gün nasıl geçiyor ve ne tür bir aktivite önerirsiniz? Kısa bir özet ver.`; try { const response = await openai.chat.completions.create({ model: \u0026#39;gpt-4o-mini\u0026#39;, messages: [{ role: \u0026#39;user\u0026#39;, content: prompt }], max_tokens: 60, temperature: 0.7, }); return response.choices[0].message.content.trim(); } catch (error) { console.error(\u0026#39;OpenAI API hatası:\u0026#39;, error); return \u0026#39;Hava durumu analiz edilemedi.\u0026#39;; } } // Ana fonksiyon: Araçları sırasıyla çağırır async function main() { console.log(\u0026#39;Tool Calling Ajanı başlatılıyor...\u0026#39;); // Hava durumu verisini almak için aracı çağırma const weatherData = await getWeatherData(LOCATION); console.log(\u0026#39;Alınan Hava Durumu Verisi:\u0026#39;, weatherData); // OpenAI API\u0026#39;ye veriyi gönderip analiz alıyoruz const analysis = await analyzeWeather(weatherData); console.log(\u0026#39;Analiz Sonucu:\u0026#39;, analysis); } main(); Bu örnekte, agent \u0026ldquo;tool calling\u0026rdquo; yaparak iki farklı dış kaynağı (OpenWeatherMap ve OpenAI) kullanıyor. Öncelikle hava durumu verisi toplanıyor; ardından bu veri, bir analiz için OpenAI API\u0026rsquo;sine gönderiliyor. Böylece, ajanın kendi yeteneklerinin ötesinde dış kaynaklardan faydalanması sağlanıyor.\nFarklı Araç Türleri AI sistemlerinize entegre edebileceğiniz bazı araç türleri:\nVeritabanı İşlemleri: Veri sorgulama, ekleme, güncelleme API Çağrıları: Harici servislere bağlanma (hava durumu, borsa, haberler) Dosya İşlemleri: Dosya okuma, yazma, dönüştürme Hesaplamalar: Karmaşık matematiksel işlemler Takvim/Zamanlama: Etkinlik oluşturma, hatırlatıcı ayarlama Tool Calling Best Practices Açık Tanımlamalar: Araçlarınızı açık ve net tanımlayın, parametreleri dokumentasyon içerisinde detaylandırın Güvenlik Kontrolleri: Kullanıcı girdilerini doğrulayın Graceful Failure: Araçlar hata verdiğinde zarif bir şekilde geri dönüş yapın Aşamalı Geliştirme: Önce basit araçlarla başlayın, sonra karmaşıklığı artırın 4. Conversation Memory: AI\u0026rsquo;ya Hafıza Kazandırma Conversation Memory Nedir? Conversation memory, bir AI sisteminin önceki etkileşimleri hatırlama ve buna göre yanıt verme yeteneğidir. Bu özellik, sohbetin tutarlı ve bağlamsal olmasını sağlar.\nNeden Önemli? Bağlamsal tutarlılık sağlar. Kullanıcılar her seferinde bağlam vermek zorunda kalmaz. Yani diyalog sırasında, agent önceki mesajları \u0026lsquo;hatırlar\u0026rsquo;. Böylece, örneğin bir sohbet başlangıcından verilen bilgiler, sonraki yanıtların daha anlamlı ve tutarlı olmasını sağlar. AI, önceki isteklere referans verebilir Daha doğal ve insana benzer etkileşimler sağlar Conversation memory için örnek bir kullanımdan şu şekilde bahsedebiliriz. Bir chatbot, kullanıcının adını, ilgili alanlarını ya da daha önce sorduğu soruları belleğinde tutarak, sonraki yanıtlarda bu bilgileri referans alır. Böylece, her mesaj birbirine bağlı hale gelir ve sohbet bir doğal bir akış kazanır. Bu bellek genellikle, önceki mesajların belirli bir kısmını saklayarak gerçekleştirilir. Dil modelleri, bu geçmiş bilgiyi input olarak kullanarak, daha iyi bir bağlam anlayışı ile yanıt üretir. Konuşma belleğinin etkin kullanımı, bellek boyutu ve uzun diyaloglarda bilgilerin güncelliğini koruma gibi zorlukları da beraberinde getirir. Sonuç olarak, konuşma belleği yani conversation memory, AI Agent\u0026rsquo;larının daha \u0026lsquo;akıılı\u0026rsquo; ve bağlamsal yanıtlar üretebilmesi için kritik bir bileşendir. Bu özellik, uzun ve anlamlı sohbetler kurulmasına olanak tanır.\nNode.js ile Conversation Memory Aşağıdaki örnek; conversation memory tutan bir chatbot örneği. Bu örnekte her kullanıcının sohbet geçmişi MongoDB\u0026rsquo;de tutuluyor ve yeni bir mesaj geldiğinde geçmişi prpmpt olarak OpenAI\u0026rsquo;ya gönderiyoruz.\nÖnce gerekli kütüphaneleri yükleyelim:\nnpm install mongodb express openai Örnek kodumuz ise aşağıdaki şekilde:\nconst express = require(\u0026#39;express\u0026#39;); const { MongoClient } = require(\u0026#39;mongodb\u0026#39;); const { OpenAI } = require(\u0026#39;openai\u0026#39;); const app = express(); app.use(express.json()); const OPENAI_API_KEY = \u0026#39;\u0026lt;your-api-key\u0026gt;\u0026#39;; const MONGO_URI = \u0026#39;mongodb://localhost:27017\u0026#39;; const DATABASE_NAME = \u0026#39;conversationDB\u0026#39;; const COLLECTION_NAME = \u0026#39;conversations\u0026#39;; // OpenAI yapılandırması const openai = new OpenAI({ apiKey: OPENAI_API_KEY, }); // MongoDB bağlantısı const client = new MongoClient(MONGO_URI, { useUnifiedTopology: true }); let conversationCollection; client .connect() .then(() =\u0026gt; { const db = client.db(DATABASE_NAME); conversationCollection = db.collection(COLLECTION_NAME); console.log(\u0026#34;MongoDB\u0026#39;ye bağlanıldı.\u0026#34;); }) .catch((err) =\u0026gt; console.error(\u0026#39;MongoDB bağlantı hatası:\u0026#39;, err)); // Chat endpoint\u0026#39;i app.post(\u0026#39;/chat\u0026#39;, async (req, res) =\u0026gt; { const { userId, message } = req.body; if (!userId || !message) { return res.status(400).send({ error: \u0026#39;userId ve message gerekli.\u0026#39; }); } try { // Kullanıcının önceki sohbet geçmişini al let conversation = await conversationCollection.findOne({ userId }); if (!conversation) { conversation = { userId, messages: [] }; } // Kullanıcı mesajını geçmişe ekle conversation.messages.push({ role: \u0026#39;user\u0026#39;, content: message }); // Konuşma geçmişini prompt\u0026#39;a dönüştür let prompt = \u0026#39;\u0026#39;; conversation.messages.forEach((msg) =\u0026gt; { prompt += (msg.role === \u0026#39;user\u0026#39; ? \u0026#39;Kullanıcı\u0026#39; : \u0026#39;Ajan\u0026#39;) + `: ${msg.content}\\n`; }); prompt += \u0026#39;Ajan:\u0026#39;; // Ajanın yanıt vermesi için // OpenAI API çağrısı const response = await openai.chat.completions.create({ model: \u0026#39;gpt-4o-mini\u0026#39;, messages: [{ role: \u0026#39;user\u0026#39;, content: prompt }], max_tokens: 100, temperature: 0.7, }); const agentReply = response.choices[0].message.content.trim(); // Ajan yanıtını geçmişe ekle conversation.messages.push({ role: \u0026#39;agent\u0026#39;, content: agentReply }); // Güncellenmiş sohbeti MongoDB\u0026#39;ye kaydet (upsert) await conversationCollection.updateOne({ userId }, { $set: { messages: conversation.messages } }, { upsert: true }); res.send({ reply: agentReply }); } catch (error) { console.error(\u0026#39;Sohbet işlenirken hata:\u0026#39;, error); res.status(500).send({ error: \u0026#39;Sunucu hatası\u0026#39; }); } }); app.listen(3000, () =\u0026gt; { console.log(\u0026#39;Sunucu 3000 portunda çalışıyor.\u0026#39;); }); Bu örnek kodda, her kullanıcının sohbet geçmişi userId ile MongoDB\u0026rsquo;de saklanıyor. Yeni bir mesaj geldiğinde, bu geçmiş alınarak OpenAI prompt\u0026rsquo;una dahil ediliyor. Böylece, model önceki konuşmayı da göz önünde bulundarak yanıt üretiyor.\nÖrnek cURL isteği:\ncurl --location \u0026#39;http://localhost:3000/chat\u0026#39; \\ --header \u0026#39;Content-Type: application/json\u0026#39; \\ --data \u0026#39;{ \u0026#34;userId\u0026#34;: \u0026#34;123\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;istanbul\u0026#39;da hava kaç derece\u0026#34; }\u0026#39; Örnek senaryo ise şu şekilde gelişebilir: User =\u0026gt; bugün İstanbul\u0026rsquo;da hava kaç derece Agent =\u0026gt; İstanbul\u0026rsquo;da hava 23 derece ve güneşli User =\u0026gt; peki ya İzmir? Agent=\u0026gt; İzmir\u0026rsquo;de hava 26 derece ve güneşli.\nAgent burada geçmişi tuttuğu için ikinci soruda \u0026lsquo;hava durumu\u0026rsquo; vb. kelimeler geçmemesine rağmen sadece \u0026lsquo;peki ya İzmir\u0026rsquo; seçeneğinden sohbet gemmişini tuttuğu için hava durumuu bilgisini alacak ve ona göre cevabı verecektir.\n5. Model Context Protocol: LLM Bağlamını Yönetme Model Context Protocol yani MCP; bir dil modeline (örneğin GPT-4, Claude 3.7 Sonnet) hangi bilgilerin, hangi formatta ve nasıl sağlanacağına dair belirli kuralları ve yapılandırmaları ifade eder. Bu kavramı daha iyi anlamak için aşağıdaki başlıklara da değinelim.\nBağlamın Tanımlanması ve Formatlanması Bağlam Nedir =\u0026gt; Dil modelleri, yanıt üretirken sadece kendilerine gönderilen girdiye (prompt) dayanır. Bu girdi, sohbetin geçmişi, sistem yönergeleri, kullanıcı soruları ve hatta araç çağrılarından elde edilen veriler gibi çeşitli unsurları içerebilir. Protokol Nedir =\u0026gt; Protokol ifadesi, bu bilgilerin nasıl düzenleneceğini, sıralanacağını ve formatlanacağını belirleyen kuralları ifade eder. Örneğin OpenAI\u0026rsquo;nın ChatGPT modeli, sohbet geçmişini \u0026lsquo;system\u0026rsquo;, \u0026lsquo;user\u0026rsquo; ve \u0026lsquo;assistant\u0026rsquo; rolleriyle ayırır. Bu yapı, modelin hangi bilgileri öncelikli olarak dikkate alacağını belirler. Konuşma Belleği ve Bağlam Yönetimi Konuşma Belleği =\u0026gt; Konuşma belleği, önceki mesajların hatırlanmasını sağlayan bir mekanizmadır. Ancak model, durum bilgisini doğrudan saklamaz; her seferinde önceki mesajlar prompt\u0026rsquo;a eklenerek bağlam sağlanır. Token Sınırı =\u0026gt; Modellerin işleyebileceği toplam token sayısı sınırlıdır. Bu nedenle, hangi geçmiş mesajların dahil edileceği, hangi bilgilerin özetleneceği gibi kararlar \u0026ldquo;model context protocol\u0026rdquo; kapsamında ele alınır. Bu, modelin en alakalı bilgiyi görmesini sağlar. Dinamik ve Statik Bilgiler Dinamik Bilgiler =\u0026gt; Sohbet sırasında sürekli güncellenen bilgiler (örneğin, kullanıcı mesajları, araçlardan gelen yanıtlar) dinamik bağlamın bir parçası olarak prompt\u0026rsquo;a eklenir. Statik Bilgiler =\u0026gt; Bazı sistem yönergeleri, modelin nasıl davranması gerektiğini belirten sabit komutlar veya bilgiler de olabilir. Örneğin, modelin belirli bir ton veya dilde yanıt vermesini istemek gibi. Uygulama Örneği Diyelim ki bir chatbot oluşturuyoruz. MCP bu chatbot projesinde şu mantıkla çalışabilir Sistem Mesajı =\u0026gt; \u0026ldquo;Bu bir müşteri destek sohbetidir. Cevaplarını nazik ve yardımcı bir üslupla ver.\u0026rdquo; Kullanıcı Mesajları =\u0026gt; \u0026ldquo;Merhaba, hesabımda sorun var\u0026rdquo; gibi geçmiş mesajlar. Araç Çağrıları =\u0026gt; Eğer dış API\u0026rsquo;lerden veri alınıyorsa, bu verilerde uygun şekilde prompt\u0026rsquo;a dahil edilir. Prompt Oluşturma =\u0026gt; Tüm bu bilgiler belirli bir sırayla ve formatla (örneğin, Kullanıcı: \u0026hellip;, Agent: \u0026hellip;) birleştirilir ve modelin yanıt üretmesi için gönderilir. Özetleyecek olursak MCP, dil modeline hangi bilgilerin verileceğini, bu bilgilerin nasıl yapılandırılacağını ve modelin nasıl daha etkili yanıtlar üreteceğini belirleyen bir rehber gibidir. Doğru bir protokol oluşturmak, modelin bağlamı daha iyi anlamasına ve daha tutarlı, alakalı cevaplar vermesine yardımcı olur. Bu kavram, özellikle uzun ve karmaşık diyaloglarda, doğru bilgiyi modelin anlayabileceği sınır dahilinde tutmak için kritik bir öneme sahiptir.\n6. Fine-tuning: LLM\u0026rsquo;leri Özelleştirme Fine-tuning, önceden eğitilmiş bir dil modelini (LLM) belirli bir görev veya domain için özelleştirme sürecidir. Bu süreç, modelin belirli bir kullanım senaryosu için daha doğru ve tutarlı yanıtlar üretmesini sağlar.\nFine-tuning Ne Zaman Kullanılmalı? Fine-tuning şu durumlarda özellikle faydalıdır:\nÖzel domain bilgisi gerektiren görevler Tutarlı format veya stil gerektiren çıktılar Marka sesi ve ton uyumu gereken durumlar Teknik terminoloji kullanımı Çok sayıda benzer görev tekrarı Fine-tuning Avantajları Daha İyi Performans:\nDomain-specific görevlerde daha doğru yanıtlar Daha tutarlı çıktı formatı Azaltılmış hallüsinasyonlar Maliyet Optimizasyonu:\nDaha kısa promptlar kullanabilme Daha az token tüketimi Daha hızlı yanıt süreleri Özelleştirilmiş Davranış:\nMarka diline uygun yanıtlar Tutarlı ton ve üslup Özel kuralları öğrenebilme Fine-tuning Süreci Veri Hazırlama:\nEğitim verisi toplama Veri temizleme ve formatlama Prompt-completion çiftleri oluşturma Model Seçimi:\nBase model belirleme Model parametrelerini ayarlama Eğitim stratejisi seçimi Eğitim:\nHiperparametre optimizasyonu Eğitim metriklerini izleme Cross-validation kontrolleri Değerlendirme:\nModel performans analizi A/B testleri İnsan değerlendirmesi Fine-tuning Best Practices Veri Kalitesi:\nYüksek kaliteli eğitim verisi kullanın Veri çeşitliliğini sağlayın Dengeli veri dağılımı oluşturun Model Seçimi:\nGörev için uygun boyutta model seçin Maliyet-performans dengesini gözetin Base model performansını değerlendirin Eğitim Stratejisi:\nKademeli fine-tuning uygulayın Overfitting\u0026rsquo;i önleyin Düzenli değerlendirme yapın Deployment:\nModel versiyonlaması yapın Performans izleme mekanizmaları kurun Geri bildirim döngüsü oluşturun 7. Ollama, LiteLLM, LlamaCPP: Açık Kaynak AI Çözümleri Açık kaynaklı LLM\u0026rsquo;ler ve araçlar, AI geliştirme süreçlerini daha erişilebilir hale getiriyor. Bu bölümde, Node.js uygulamalarınızda kullanabileceğiniz popüler açık kaynak AI çözümlerini inceleyeceğiz.\nOllama: Ollama, kullanıcıların büyük dil modellerini (ör. LLaMA, GPT türevi modeller) kendi makinelerinde çalıştırmasını sağlayan, genellikle kullanıcı dostu bir arayüz sunan platformlardır. Bu tür uygulamalar, modelin kurulumu, güncellemeleri ve entegrasyonunu kolaylaştırmak amacıyla tasarlanır; böylece, kullanıcının internet bağlantısına bağımlı olmadan yerel olarak güvenli ve hızlı erişim sağlanabilir. LiteLLM: Litellm, \u0026ldquo;lightweight\u0026rdquo; yani hafif anlamına gelen bir yaklaşımla geliştirilmiş, büyük dil modelleriyle çalışmayı kolaylaştıran bir kütüphane ya da araçtır. Genellikle minimal kaynak kullanımı, esneklik ve hızlı prototipleme imkanı sunar. Bu tür araçlar, model eğitiminden ziyade, var olan büyük modellerin daha az kaynakla çalıştırılmasına odaklanır. LlamaCpp: LlamaCpp, Meta\u0026rsquo;nın LLaMA modeli gibi büyük dil modellerinin C++ ile optimize edilmiş bir implementasyonudur. Bu kütüphane, özellikle quantized (azaltılmış hassasiyetli) modelleri CPU üzerinde verimli bir şekilde çalıştırmayı hedefler. Böylece, güçlü GPU\u0026rsquo;lara ihtiyaç duymadan, yerel makinede LLM çalıştırmak mümkün hale gelir. Açık Kaynak AI Çözümleri Karşılaştırması Özellik Ollama LiteLLM LlamaCPP Kurulum Kolaylığı ★★★★★ ★★★★☆ ★★☆☆☆ Performans ★★★★☆ ★★★★☆ ★★★★★ API Uyumluluğu ★★★☆☆ ★★★★★ ★★☆☆☆ Kaynak Kullanımı ★★★☆☆ ★★★★☆ ★★★★★ Çoklu Model Desteği ★★★★☆ ★★★★★ ★★★☆☆ Maliyet Ücretsiz Ücretsiz* Ücretsiz Özetle, hepsi büyük dil modellerinin yerel veya optimize edilmiş ortamlarda kullanımını kolaylaştırmaya yönelik araçlar olsa da;\nOllama daha kapsamlı bir platform olarak, kullanımı basitleştirip entegre çözümler sunarken, Litellm hafif ve modüler yapısıyla geliştiricilere esneklik sağlamak istiyor, LlamaCpp ise özellikle performans ve düşük kaynak kullanımı açısından C++ ile optimize edilmiş bir çözüm sunuyor. Bu araçlar, hangi donanım ve kullanım senaryosunda çalıştırılacağına göre tercih edilebilir. Böylece, örneğin geliştirici ortamınızda hızlı prototipleme yapmak için litellm kullanabilir, performans odaklı yerel uygulamalarda ise llamaCpp tercih edilebilir; Ollama ise daha kapsamlı bir kullanıcı deneyimi arayanlara hitap edebilir.\n8. N8n: AI İş Akışları Otomasyonu N8n, kod yazmadan veya minimum kod ile iş akışlarını otomatikleştirmenize olanak tanıyan açık kaynaklı bir otomasyon aracıdır. N8n\u0026rsquo;in esnek yapısı, AI hizmetlerini diğer uygulamalarla kolayca entegre etmenizi sağlar. N8N, tamamen açık kaynaklıdır; bu sayede kaynak koduna erişebilir, özelleştirebilir ve kendi ihtiyaçlarınıza göre uyarlayabilirsiniz. Sürükle bırak arayüzü sayesinde, her biri belirli bir işlemi yapan \u0026ldquo;node\u0026quot;lardan oluşan akışlar tasarlayabilirsiniz. Bu sayede, teknik bilgisi az olan kullanıcılar bile karmaşık iş akışları oluşturabilir.\nN8N, çok sayıda API ve servisle enteagrasyon sağlayarak, örneğin e-posta, veritabanı, sosyal medya, dosya depolama gibi farklı sistemler arasında veri transferi veya otomatik işlemler yapmanıza olanak tanır. N8N\u0026rsquo;i kendi sunucularınızda barındırabilirsiniz. Bu, verilerin kontrolünün tamamen sizde olmasını sağlar ve özellikle gizlilik veya compliance konularında avantaj sunar.\nÖrneğin, bir müşteri destek sürecinde, e-posta aldığında otomatik olarak bir veritabanına kayıt eklemek, ardından Slack üzerinden bildirim göndermek istiyorsan, n8n ile bu adımları görsel olarak düzenleyip otomatik hale getirebilirsin.\nN8n ile Yapılabilecek AI İş Akışları Belge İşleme ve Özetleme\nGelen e-posta eklerini otomatik olarak özetleme PDF belgeleri analiz edip veri çıkarma Müşteri Destek Otomasyonu\nGelen müşteri sorularını analiz edip sınıflandırma Basit sorulara otomatik yanıt oluşturma, karmaşık soruları yönlendirme Sosyal Medya Yönetimi\nBelirli konularda otomatik içerik üretme Yorumları duygu analizi ile sınıflandırma ve yanıtlama Veri Analizi ve Raporlama\nPeriyodik verileri analiz etme ve özetleme Veri anormalliklerini tespit edip uyarı gönderme N8n ve AI Entegrasyonunun Avantajları Kod Yazmadan Otomasyon: Teknik olmayan ekip üyeleri bile komplex AI iş akışları oluşturabilir Çoklu Servis Entegrasyonu: 200+ entegrasyon ile AI\u0026rsquo;ı tüm iş süreçlerinize dahil edebilirsiniz Self-Hosting: Hassas veriler içeren AI işlemleri için kendi altyapınızda çalıştırabilirsiniz Esnek Tetikleyiciler: Zamanlayıcı, webhook, olay bazlı tetikleyiciler ile AI işlemlerini başlatabilirsiniz Son Söz AI teknolojileri hızla gelişiyor ve bu teknolojilerin Node.js ekosistemindeki entegrasyonu giderek kolaylaşıyor. Bu makalede gördüğümüz teknikler, AI destekli uygulamalar geliştirmek için sağlam bir temel oluşturuyor.\nAI agent\u0026rsquo;lar, tool calling, conversation memory ve bağlam yönetimi gibi temel kavramların yanı sıra, embedding\u0026rsquo;ler, RAG (Retrieval Augmented Generation) ve vector veritabanları gibi modern AI teknolojilerini kullanarak daha güçlü ve akıllı uygulamalar geliştirebilirsiniz. Fine-tuning ile modellerinizi özelleştirerek, domain-specific görevlerde daha başarılı sonuçlar elde edebilirsiniz.\nAçık kaynak modeller ve N8n gibi otomasyon araçlarıyla birlikte, bu teknolojileri kullanarak:\nDaha doğru ve bağlama duyarlı yanıtlar üreten chatbot\u0026rsquo;lar Akıllı doküman işleme ve analiz sistemleri Semantik arama ve öneri motorları Otomatikleştirilmiş iş akışları Domain-specific AI asistanları gibi çözümler geliştirebilirsiniz.\nBu makalede gösterilen tüm kod örneklerine ve daha fazlasına GitHub Repository adresinden erişebilirsiniz.\nYapay zeka yolculuğunuzda başarılar dilerim!\n",
        "tags": ["ai","nodejs"],
        "categories": ["AI","Node.js","JavaScript"],
        "lang": "tr"
    },{
        "title": "TypeScript'i Anlamak - Bölüm 9: Örnek Proje",
        "permalink": "/blog/tr/typescript-serisi/typescripti-anlamak-bolum9/",
        "summary": "Bu makalede, TypeScript ve Node.js kullanarak JWT ve Google OAuth kimlik doğrulaması içeren bir Todo uygulaması geliştirme sürecini inceleyeceğiz. TypeScript\u0026rsquo;in tip güvenliği, MongoDB entegrasyonu ve clean architecture prensiplerini uygulayarak modern bir REST API tasarlama deneyimini ele alacağız.",
        "content": "TypeScript ile Node.js Authentication API Geliştirme: Kapsamlı Rehber Giriş Modern web uygulamaları geliştirirken tip güvenliği ve kod kalitesi giderek daha önemli hale geliyor. Bu eğitimde, TypeScript\u0026rsquo;in sunduğu güçlü özellikleri gerçek bir proje üzerinde öğreneceğiz. JWT ve Google OAuth kimlik doğrulaması içeren bir Todo uygulaması geliştirirken, TypeScript\u0026rsquo;in temel kavramlarını ve best practice\u0026rsquo;lerini uygulayacağız. Uygulamanın tüm haline GitHub repository adresinden ulaşabilirsiniz.\nBu proje size şunları kazandıracak:\nTypeScript ile güvenli kod yazma pratiği Modern bir REST API tasarlama deneyimi Authentication ve Authorization implementasyonu MongoDB ile TypeScript kullanımı Clean Architecture prensiplerini uygulama TypeScript Özellikleri ve Proje Yapısı Bu projede TypeScript\u0026rsquo;in temel özelliklerini kullanarak güvenli ve ölçeklenebilir bir API geliştireceğiz. Her özelliği gerçek proje kodlarımızdan örneklerle açıklayalım:\n1. TypeScript Temelleri (Basics) TypeScript\u0026rsquo;in temel yapı taşlarını projemizde şu şekilde kullanıyoruz:\n// src/config/env.ts\u0026#39;de Tip Tanımlamaları const PORT: number = Number(process.env.PORT) || 3000; const JWT_EXPIRES_IN: string = \u0026#39;1d\u0026#39;; // src/middleware/auth.middleware.ts\u0026#39;de Type Assertion const decoded = jwt.verify(token, JWT_SECRET) as IJwtPayload; // Burada JWT\u0026#39;den gelen veriyi IJwtPayload tipine dönüştürüyoruz // src/interfaces/user.interface.ts\u0026#39;de Literal Types type UserRole = \u0026#39;user\u0026#39; | \u0026#39;admin\u0026#39;; // User modelinde kullanıcı rollerini sadece bu iki değerle sınırlıyoruz Projedeki Kullanım Örnekleri:\nPORT tanımı src/index.ts\u0026lsquo;de server başlatırken kullanılıyor Type assertion auth.middleware.ts\u0026lsquo;de JWT doğrulamasında kullanılıyor UserRole tipi IUser interface\u0026rsquo;inde kullanıcı rolünü kısıtlamak için kullanılıyor 2. Fonksiyonlar (Functions) TypeScript\u0026rsquo;te fonksiyonları tip güvenli şekilde tanımlıyoruz:\n// src/services/auth.service.ts\u0026#39;de Method Signatures interface IAuthService { login(credentials: IUserLogin): Promise\u0026lt;{ user: IUser; token: string }\u0026gt;; register(userData: IUserRegistration): Promise\u0026lt;IUser\u0026gt;; } // src/controllers/auth.controller.ts\u0026#39;de Implementation public async login(req: Request, res: Response): Promise\u0026lt;void\u0026gt; { const { email, password } = req.body; const result = await this.authService.login({ email, password }); // ... } Projedeki Kullanım Örnekleri:\nIAuthService interface\u0026rsquo;i auth.service.ts\u0026lsquo;de servis implementasyonunu tanımlıyor Controller\u0026rsquo;lardaki tüm handler fonksiyonları Request ve Response tiplerini kullanıyor Tüm async fonksiyonlar Promise return type\u0026rsquo;ı ile tanımlanıyor 3. Nesne Tipleri (Object Types) Projemizde karmaşık veri yapılarını nesne tipleriyle modelliyoruz:\n// src/config/database.ts\u0026#39;de Configuration Types type DatabaseConfig = { uri: string; options: { useNewUrlParser: boolean; useUnifiedTopology: boolean; }; }; // src/controllers/todo.controller.ts\u0026#39;de Request Types interface ITodoCreate { title: string; description?: string; // Optional property örneği } Projedeki Kullanım Örnekleri:\nDatabaseConfig tipi MongoDB bağlantı ayarlarını tanımlıyor ITodoCreate interface\u0026rsquo;i todo oluşturma endpoint\u0026rsquo;inde request body validasyonu için kullanılıyor Optional property\u0026rsquo;ler todo güncellemelerinde kısmi güncellemeye izin veriyor 4. Interfaces Interface\u0026rsquo;leri projemizde hem tip tanımı hem de sözleşme olarak kullanıyoruz:\n// src/interfaces/base.interface.ts\u0026#39;de Base Interface interface IBaseEntity { _id: string; createdAt: Date; updatedAt: Date; } // src/interfaces/user.interface.ts\u0026#39;de Interface Extension interface IUser extends IBaseEntity { email: string; password?: string; name: string; role: UserRole; } Projedeki Kullanım Örnekleri:\nIBaseEntity tüm MongoDB modellerimizin temel alanlarını tanımlıyor IUser interface\u0026rsquo;i User modelinin şemasını ve metodlarını tanımlıyor Interface\u0026rsquo;ler mongoose model tanımlarında tip güvenliği sağlıyor 5. TypeScript Compiler TypeScript derleyicisini projemiz için özel olarak yapılandırıyoruz:\n{ \u0026#34;compilerOptions\u0026#34;: { \u0026#34;target\u0026#34;: \u0026#34;es2016\u0026#34;, \u0026#34;module\u0026#34;: \u0026#34;commonjs\u0026#34;, \u0026#34;strict\u0026#34;: true, \u0026#34;esModuleInterop\u0026#34;: true, \u0026#34;skipLibCheck\u0026#34;: true, \u0026#34;forceConsistentCasingInFileNames\u0026#34;: true, \u0026#34;outDir\u0026#34;: \u0026#34;./dist\u0026#34;, \u0026#34;rootDir\u0026#34;: \u0026#34;./src\u0026#34; } } Compiler Ayarlarının Önemi:\nstrict: Katı tip kontrolü sağlıyor target: Modern JavaScript özelliklerini kullanmamızı sağlıyor module: Node.js ile uyumlu modül sistemi kullanıyoruz 6. Classes OOP prensiplerini TypeScript classes ile uyguluyoruz:\n// src/services/base.service.ts\u0026#39;de Abstract Base Class abstract class BaseService\u0026lt;T extends IBaseEntity\u0026gt; { constructor(protected model: Model\u0026lt;T\u0026gt;) {} abstract create(data: Partial\u0026lt;T\u0026gt;): Promise\u0026lt;T\u0026gt;; async findById(id: string): Promise\u0026lt;T | null\u0026gt; { return this.model.findById(id); } } // src/services/todo.service.ts\u0026#39;de Class Implementation class TodoService extends BaseService\u0026lt;ITodo\u0026gt; { async create(data: ICreateTodo): Promise\u0026lt;ITodo\u0026gt; { return this.model.create(data); } async markAsCompleted(id: string): Promise\u0026lt;ITodo | null\u0026gt; { return this.model.findByIdAndUpdate(id, { completed: true }); } } Neden Bu Özellik?\nAbstract class\u0026rsquo;lar ile ortak davranışları zorunlu kılıyoruz Inheritance ile kod tekrarını önlüyoruz Service katmanını organize ediyoruz Projedeki Kullanım Örnekleri:\nBaseService tüm servisler için temel CRUD operasyonlarını tanımlıyor TodoService ve AuthService bu base class\u0026rsquo;ı extend ederek kendi özel metodlarını ekliyor Abstract metodlar sayesinde her servisin kendi create metodunu implemente etmesi zorunlu 7. Generics Generic tipleri projemizde şu şekilde kullanıyoruz:\n// src/services/base.service.ts\u0026#39;de Generic Service class CrudService\u0026lt;T extends IBaseEntity\u0026gt; { async findOne(filter: FilterQuery\u0026lt;T\u0026gt;): Promise\u0026lt;T | null\u0026gt; { return this.model.findOne(filter); } } // src/utils/response.ts\u0026#39;de Generic Response Handler function createResponse\u0026lt;T\u0026gt;(success: boolean, message: string, data?: T): IApiResponse\u0026lt;T\u0026gt; { return { success, message, data }; } // src/utils/error.ts\u0026#39;de Generic Error Handler class ApiError\u0026lt;T = unknown\u0026gt; extends Error { constructor(public statusCode: number, message: string, public data?: T) { super(message); } } Neden Bu Özellik?\nTip güvenliğini koruyarak yeniden kullanılabilir kod yazıyoruz Farklı veri tipleriyle çalışabilen fonksiyonlar oluşturuyoruz Tip parametreleri ile esnek yapılar kuruyoruz Projedeki Kullanım Örnekleri:\nCrudService farklı model tipleriyle çalışabiliyor (User, Todo vb.) createResponse her türlü veri yapısı için tutarlı API yanıtları oluşturuyor ApiError farklı hata tipleri için özelleştirilebilir error handling sağlıyor 8. Type Narrowing Runtime\u0026rsquo;da tip kontrolü ve daraltma işlemlerini güvenli şekilde yapıyoruz:\n// src/utils/error.ts\u0026#39;de Type Guards function isError(error: unknown): error is Error { return error instanceof Error; } // src/middleware/error.middleware.ts\u0026#39;de Error Handling function handleError(error: unknown): IApiResponse\u0026lt;null\u0026gt; { if (isError(error)) { return createResponse(false, error.message); } if (typeof error === \u0026#39;string\u0026#39;) { return createResponse(false, error); } return createResponse(false, \u0026#39;Unknown error occurred\u0026#39;); } // src/types/error.types.ts\u0026#39;de Discriminated Unions type ValidationError = { type: \u0026#39;validation\u0026#39;; fields: { [key: string]: string }; }; type AuthError = { type: \u0026#39;auth\u0026#39;; message: string; }; type AppError = ValidationError | AuthError; // src/utils/error-handler.ts\u0026#39;de Error Type Handling function handleAppError(error: AppError) { switch (error.type) { case \u0026#39;validation\u0026#39;: return error.fields; case \u0026#39;auth\u0026#39;: return error.message; } } Neden Bu Özellik?\nRuntime\u0026rsquo;da tip güvenliğini sağlıyoruz Hata yönetimini daha güvenli yapıyoruz Union type\u0026rsquo;ları doğru şekilde işliyoruz Projedeki Kullanım Örnekleri:\nisError type guard\u0026rsquo;ı middleware\u0026rsquo;lerde hata tipini doğru şekilde belirlememizi sağlıyor Error handling middleware\u0026rsquo;de farklı hata tiplerini ayırt edebiliyoruz Discriminated union\u0026rsquo;lar ile validation ve auth hatalarını ayrı ayrı işleyebiliyoruz Proje Özeti Geliştireceğimiz API aşağıdaki özellikleri içerecek:\nKullanıcı Yönetimi\nKayıt ve Giriş JWT Authentication Google OAuth Entegrasyonu Rol tabanlı yetkilendirme Todo İşlemleri\nTodo oluşturma, okuma, güncelleme, silme Kullanıcıya özel todo\u0026rsquo;lar Todo durumu değiştirme Güvenlik ve Validasyon\nInput validasyonu Route koruması Error handling Proje Yapısı Projemiz şu şekilde organize edilmiştir:\nsrc/ ├── config/ # Konfigürasyon dosyaları ├── controllers/ # HTTP request handlers ├── interfaces/ # TypeScript interfaces ├── middleware/ # Express middleware ├── models/ # Mongoose modelleri ├── routes/ # API routes ├── services/ # İş mantığı ├── utils/ # Yardımcı fonksiyonlar └── index.ts # Uygulama giriş noktası TypeScript ile Proje Geliştirme 1. Proje Kurulumu ve TypeScript Konfigürasyonu İlk adım olarak TypeScript\u0026rsquo;i projemize entegre edelim:\nmkdir nodejs-typescript-auth cd nodejs-typescript-auth npm init -y npm install typescript ts-node @types/node --save-dev Bağımlılıklar Projemiz için gerekli paketleri yükleyelim:\n# Ana bağımlılıklar npm install express mongoose dotenv jsonwebtoken bcrypt passport passport-google-oauth20 passport-jwt cors # Tip tanımlamaları npm install @types/express @types/mongoose @types/jsonwebtoken @types/bcrypt @types/passport @types/passport-google-oauth20 @types/passport-jwt @types/cors --save-dev TypeScript Konfigürasyonu { \u0026#34;compilerOptions\u0026#34;: { \u0026#34;target\u0026#34;: \u0026#34;es2016\u0026#34;, \u0026#34;module\u0026#34;: \u0026#34;commonjs\u0026#34;, \u0026#34;outDir\u0026#34;: \u0026#34;./dist\u0026#34;, \u0026#34;rootDir\u0026#34;: \u0026#34;./src\u0026#34;, \u0026#34;strict\u0026#34;: true, \u0026#34;esModuleInterop\u0026#34;: true, \u0026#34;skipLibCheck\u0026#34;: true, \u0026#34;forceConsistentCasingInFileNames\u0026#34;: true } } 2. Veri Modellerini Tanımlama User Modeli TypeScript interface\u0026rsquo;leri ile kullanıcı modelimizi tanımlayalım:\n// src/interfaces/user.interface.ts // Base interface - temel kullanıcı özellikleri interface IBaseUser { email: string; name: string; } // Ana kullanıcı interface\u0026#39;i - tüm özellikleri içerir interface IUser extends IBaseUser { password?: string; // Optional: Google OAuth kullanıcıları için şifre olmayabilir googleId?: string; // Optional: Sadece Google ile giriş yapanlar için role: \u0026#39;user\u0026#39; | \u0026#39;admin\u0026#39;; // Union type ile rol kısıtlaması comparePassword(candidatePassword: string): Promise\u0026lt;boolean\u0026gt;; } // Kayıt için gerekli alanlar interface IUserRegistration { email: string; password: string; name: string; } // Giriş için gerekli alanlar interface IUserLogin { email: string; password: string; } Todo Modeli Todo işlemleri için gerekli interface\u0026rsquo;leri tanımlayalım:\n// src/interfaces/todo.interface.ts interface ITodo { title: string; description?: string; completed: boolean; user: string; // Referans: User ID createdAt: Date; updatedAt: Date; } // Todo oluşturma için gerekli alanlar interface ICreateTodo { title: string; description?: string; } // Todo güncelleme için opsiyonel alanlar interface IUpdateTodo { title?: string; description?: string; completed?: boolean; } 3. Servis Katmanı Implementasyonu Base Service Generic bir base service oluşturarak kod tekrarını önleyelim:\n// src/services/base.service.ts abstract class BaseService\u0026lt;T\u0026gt; { constructor(protected model: Model\u0026lt;T\u0026gt;) {} async findById(id: string): Promise\u0026lt;T | null\u0026gt; { return this.model.findById(id); } async findOne(filter: FilterQuery\u0026lt;T\u0026gt;): Promise\u0026lt;T | null\u0026gt; { return this.model.findOne(filter); } async find(filter: FilterQuery\u0026lt;T\u0026gt;): Promise\u0026lt;T[]\u0026gt; { return this.model.find(filter); } } Auth Service Kimlik doğrulama işlemlerini yöneten servis:\n// src/services/auth.service.ts class AuthService extends BaseService\u0026lt;IUser\u0026gt; { public async register(userData: IUserRegistration): Promise\u0026lt;IUser\u0026gt; { const existingUser = await this.findOne({ email: userData.email }); if (existingUser) { throw new Error(\u0026#39;Bu email adresi zaten kullanımda\u0026#39;); } const user = await this.model.create(userData); return user; } public async login(loginData: IUserLogin): Promise\u0026lt;{ user: IUser; token: string }\u0026gt; { const user = await this.findOne({ email: loginData.email }); if (!user || !(await user.comparePassword(loginData.password))) { throw new Error(\u0026#39;Geçersiz kimlik bilgileri\u0026#39;); } return { user, token: this.generateToken(user), }; } private generateToken(user: IUser): string { return jwt.sign({ id: user._id, email: user.email, role: user.role }, process.env.JWT_SECRET!, { expiresIn: \u0026#39;1d\u0026#39; }); } } Todo Service Todo işlemlerini yöneten servis:\n// src/services/todo.service.ts class TodoService extends BaseService\u0026lt;ITodo\u0026gt; { public async getAllTodos(userId: string): Promise\u0026lt;ITodo[]\u0026gt; { return this.find({ user: userId }); } public async createTodo(todoData: ICreateTodo, userId: string): Promise\u0026lt;ITodo\u0026gt; { return this.model.create({ ...todoData, user: userId, completed: false, }); } public async updateTodo(todoId: string, todoData: Partial\u0026lt;ITodo\u0026gt;, userId: string): Promise\u0026lt;ITodo | null\u0026gt; { return this.model.findOneAndUpdate({ _id: todoId, user: userId }, todoData, { new: true }); } } 4. Middleware Implementasyonu TypeScript ile güvenli middleware yazımı:\n// src/middleware/auth.middleware.ts // Request tipini genişletme declare global { namespace Express { interface Request { user?: IUser; } } } export const isAuthenticated = async (req: Request, res: Response, next: NextFunction): Promise\u0026lt;void\u0026gt; =\u0026gt; { try { const token = req.headers.authorization?.split(\u0026#39; \u0026#39;)[1]; if (!token) { throw new Error(\u0026#39;Token bulunamadı\u0026#39;); } const decoded = jwt.verify(token, process.env.JWT_SECRET!) as IJwtPayload; const user = await UserModel.findById(decoded.id); if (!user) { throw new Error(\u0026#39;Kullanıcı bulunamadı\u0026#39;); } req.user = user; next(); } catch (error) { res.status(401).json({ success: false, message: \u0026#39;Yetkilendirme hatası\u0026#39;, error: error instanceof Error ? error.message : \u0026#39;Bilinmeyen hata\u0026#39;, }); } }; 5. Controller Katmanı TypeScript ile tip güvenli controller\u0026rsquo;lar:\n// src/controllers/todo.controller.ts class TodoController { constructor(private todoService: TodoService) {} public async getAllTodos(req: Request, res: Response): Promise\u0026lt;void\u0026gt; { try { const todos = await this.todoService.getAllTodos(req.user!._id); res.status(200).json({ success: true, message: \u0026#39;Todolar başarıyla getirildi\u0026#39;, data: todos, }); } catch (error) { res.status(500).json({ success: false, message: \u0026#39;Todolar getirilirken hata oluştu\u0026#39;, error: error instanceof Error ? error.message : \u0026#39;Bilinmeyen hata\u0026#39;, }); } } } API Endpoint\u0026rsquo;leri Auth Endpoints POST /api/auth/register - Request Body: { email: string, password: string, name: string } - Response: { success: boolean, message: string, data: { user: IUser, token: string } } POST /api/auth/login - Request Body: { email: string, password: string } - Response: { success: boolean, message: string, data: { user: IUser, token: string } } GET /api/auth/google - Google OAuth başlatma endpoint\u0026#39;i GET /api/auth/google/callback - Google OAuth callback endpoint\u0026#39;i Todo Endpoints GET /api/todos - Headers: { Authorization: \u0026#34;Bearer ${token}\u0026#34; } - Response: { success: boolean, message: string, data: ITodo[] } POST /api/todos - Headers: { Authorization: \u0026#34;Bearer ${token}\u0026#34; } - Request Body: { title: string, description?: string } - Response: { success: boolean, message: string, data: ITodo } PUT /api/todos/:id - Headers: { Authorization: \u0026#34;Bearer ${token}\u0026#34; } - Request Body: { title?: string, description?: string, completed?: boolean } - Response: { success: boolean, message: string, data: ITodo } DELETE /api/todos/:id - Headers: { Authorization: \u0026#34;Bearer ${token}\u0026#34; } - Response: { success: boolean, message: string } Best Practices Tip Güvenliği\nHer zaman spesifik tipler kullanın any tipinden kaçının Union types ile değer kümelerini sınırlayın Generic tipler ile yeniden kullanılabilir kod yazın Kod Organizasyonu\nHer bir katman için ayrı klasör kullanın Interface\u0026rsquo;leri ilgili domain klasöründe tutun Servis katmanını abstract class\u0026rsquo;lar ile genelleştirin Error Handling\nCustom error sınıfları oluşturun Global error handler kullanın Hata mesajlarını standardize edin Güvenlik\nHassas bilgileri environment variable\u0026rsquo;larda saklayın Input validasyonu yapın Rate limiting uygulayın CORS politikalarını doğru yapılandırın Sonuç Bu projede:\nTypeScript\u0026rsquo;in tip sistemi ile güvenli kod yazmayı OOP prensiplerini TypeScript ile uygulamayı Modern bir API mimarisi tasarlamayı Authentication ve authorization implementasyonunu öğrendik. TypeScript, projemize:\nDerleme zamanında hata yakalama Daha iyi IDE desteği Self-documenting kod Maintainability gibi önemli avantajlar sağladı. ",
        "tags": ["typescript","nodejs","microservices"],
        "categories": ["TypeScript","Node.js","Backend"],
        "lang": "tr"
    },{
        "title": "TypeScript'i Anlamak - Bölüm 8: Type Narrowing",
        "permalink": "/blog/tr/typescript-serisi/typescripti-anlamak-bolum8/",
        "summary": "Bu makalede, TypeScript\u0026rsquo;te type narrowing (tip daraltma) tekniklerini inceleyeceğiz. typeof, instanceof, type predicates gibi tip kontrol yöntemlerini ve discriminated unions yapısını ele alacağız.",
        "content": "Merhaba! TypeScript serimizin bu bölümünde, tip sisteminin en güçlü özelliklerinden biri olan type narrowing (tip daraltma) konusunu inceleyeceğiz. Type narrowing, bir değişkenin tipini daha spesifik bir tipe daraltmamızı sağlayan tekniklerin genel adıdır. Bu teknikler sayesinde, union type\u0026rsquo;lar ve karmaşık tip yapıları ile daha güvenli bir şekilde çalışabiliriz.\nType Narrowing Nedir? Type narrowing, TypeScript\u0026rsquo;in bir değişkenin tipini bağlam içinde daha spesifik bir tipe daraltma yeteneğidir. Bu özellik, özellikle union type\u0026rsquo;lar ile çalışırken çok kullanışlıdır. Örneğin, bir değişken string veya number olabilir, ancak belirli bir kod bloğunda bu değişkenin kesinlikle string olduğunu biliyorsak, TypeScript bu bilgiyi kullanarak tip güvenliğini artırır.\ntypeof Type Guards typeof operatörü, TypeScript\u0026rsquo;te en temel type narrowing yöntemlerinden biridir:\nconst isTeenager = (age: number | string) =\u0026gt; { if (typeof age === \u0026#39;string\u0026#39;) { // Bu blokta age kesinlikle string return age.charAt(0) === \u0026#39;1\u0026#39;; } else { // Bu blokta age kesinlikle number return age \u0026gt; 12 \u0026amp;\u0026amp; age \u0026lt; 20; } }; isTeenager(\u0026#39;20\u0026#39;); // false isTeenager(13); // true typeof type guard kullanmanın avantajları:\nTip güvenliği sağlar IDE desteği ve kod tamamlama özelliklerini iyileştirir Runtime hataları önler Kodun okunabilirliğini artırır Truthiness Type Guards JavaScript\u0026rsquo;in truthiness özelliğini kullanarak da type narrowing yapabiliriz:\nconst printLetters = (word: string | null) =\u0026gt; { if (!word) { console.log(\u0026#39;No word was provided.\u0026#39;); return; } // Bu noktada word kesinlikle string word.split(\u0026#39;\u0026#39;).forEach((letter) =\u0026gt; console.log(letter)); }; printLetters(\u0026#39;Hello\u0026#39;); // H, e, l, l, o printLetters(null); // No word was provided. Truthiness kontrolü şu değerleri false olarak değerlendirir:\nfalse 0 \u0026quot;\u0026quot; null undefined NaN Equality Type Narrowing Eşitlik karşılaştırmaları da TypeScript\u0026rsquo;te type narrowing için kullanılır:\nconst someFunc = (x: string | boolean, y: string | number) =\u0026gt; { if (x === y) { // Bu blokta x ve y kesinlikle string console.log(x.toUpperCase()); console.log(y.toLowerCase()); } else { // x: string | boolean // y: string | number console.log(x); console.log(y); } }; in Operator Type Guards JavaScript\u0026rsquo;in in operatörü, bir özelliğin bir objede var olup olmadığını kontrol eder. TypeScript bu kontrolü type narrowing için kullanır:\ntype Cat = { meow: () =\u0026gt; void }; type Dog = { bark: () =\u0026gt; void }; const talk = (creature: Cat | Dog) =\u0026gt; { if (\u0026#39;meow\u0026#39; in creature) { // Bu blokta creature kesinlikle Cat creature.meow(); } else { // Bu blokta creature kesinlikle Dog creature.bark(); } }; const kitty: Cat = { meow: () =\u0026gt; console.log(\u0026#39;MEOWWW\u0026#39;) }; talk(kitty); // MEOWWW instanceof Narrowing instanceof operatörü, bir değişkenin belirli bir sınıfın örneği olup olmadığını kontrol eder:\nconst printFullDate = (date: Date | string) =\u0026gt; { if (date instanceof Date) { // Bu blokta date kesinlikle Date return date.toUTCString(); } else { // Bu blokta date kesinlikle string return new Date(date).toUTCString(); } }; console.log(printFullDate(new Date())); console.log(printFullDate(\u0026#39;2025-02-21\u0026#39;)); Type Predicates TypeScript\u0026rsquo;te özel type guard fonksiyonları yazabilirsiniz. Bu fonksiyonlar, parameterName is Type formatında bir dönüş tipine sahiptir:\ninterface Cat { meow: () =\u0026gt; void; } interface Dog { bark: () =\u0026gt; void; } // Type predicate function function isCat(pet: Cat | Dog): pet is Cat { return (pet as Cat).meow !== undefined; } let pet = getAnimal(); if (isCat(pet)) { // Bu blokta pet kesinlikle Cat pet.meow(); } else { // Bu blokta pet kesinlikle Dog pet.bark(); } Type predicate\u0026rsquo;lerin avantajları:\nÖzel type guard mantığı yazabilirsiniz Kod tekrarını önler Tip kontrollerini merkezileştirir Okunabilirliği artırır Discriminated Unions Discriminated unions, ortak bir literal özellik kullanarak birbiriyle ilişkili tipleri ayırt etme tekniğidir:\ninterface Circle { kind: \u0026#39;circle\u0026#39;; radius: number; } interface Square { kind: \u0026#39;square\u0026#39;; sideLength: number; } type Shape = Circle | Square; function getArea(shape: Shape) { switch (shape.kind) { case \u0026#39;circle\u0026#39;: // Bu blokta shape kesinlikle Circle return Math.PI * shape.radius ** 2; case \u0026#39;square\u0026#39;: // Bu blokta shape kesinlikle Square return shape.sideLength ** 2; } } Discriminated unions\u0026rsquo;ın avantajları:\nTip güvenliği sağlar Switch case ile kullanımı kolaydır IDE desteği mükemmeldir Yeni tip eklemek kolaydır Eksik case\u0026rsquo;leri derleme zamanında yakalar Best Practices Doğru Type Guard Seçimi\n// Basit tipler için typeof function processValue(value: string | number) { if (typeof value === \u0026#39;string\u0026#39;) { return value.toUpperCase(); } return value.toFixed(2); } // Sınıflar için instanceof function processDate(date: Date | string) { if (date instanceof Date) { return date.toISOString(); } return new Date(date).toISOString(); } Type Predicate\u0026rsquo;leri Etkili Kullanma\ninterface User { id: number; name: string; } interface Admin extends User { role: \u0026#39;admin\u0026#39;; permissions: string[]; } function isAdmin(user: User): user is Admin { return \u0026#39;role\u0026#39; in user \u0026amp;\u0026amp; user.role === \u0026#39;admin\u0026#39;; } Discriminated Unions\u0026rsquo;ı Düzgün Yapılandırma\ninterface ApiSuccess { status: \u0026#39;success\u0026#39;; data: any; } interface ApiError { status: \u0026#39;error\u0026#39;; error: string; } type ApiResponse = ApiSuccess | ApiError; function handleResponse(response: ApiResponse) { if (response.status === \u0026#39;success\u0026#39;) { processData(response.data); } else { handleError(response.error); } } Sonuç Type narrowing, TypeScript\u0026rsquo;in en güçlü özelliklerinden biridir. Bu teknikler sayesinde:\nDaha güvenli kod yazabilirsiniz Runtime hatalarını azaltabilirsiniz IDE desteğinden maksimum fayda sağlayabilirsiniz Karmaşık tip yapılarını daha kolay yönetebilirsiniz Bir sonraki yazımızda TypeScript\u0026rsquo;in diğer ileri seviye özelliklerini incelemeye devam edeceğiz. Görüşmek üzere!\n",
        "tags": ["typescript","type-narrowing","type-guards"],
        "categories": ["TypeScript"],
        "lang": "tr"
    },{
        "title": "TypeScript'i Anlamak - Bölüm 7: Generics",
        "permalink": "/blog/tr/typescript-serisi/typescripti-anlamak-bolum7/",
        "summary": "Bu makalede, TypeScript\u0026rsquo;in en güçlü özelliklerinden biri olan generic yapıları inceleyeceğiz. Tip güvenliğini korurken yeniden kullanılabilir kod yazmanın yollarını öğreneceğiz.",
        "content": "Merhaba! TypeScript serimizin bu bölümünde, kodunuzu daha esnek ve yeniden kullanılabilir hale getiren generic yapıları inceleyeceğiz. Generics, tip güvenliğinden ödün vermeden farklı veri tipleriyle çalışabilen fonksiyonlar ve sınıflar yazmamızı sağlar.\nGeneric Yapılar Nedir? Generics, bir fonksiyon veya sınıfın farklı tiplerle çalışabilmesini sağlayan bir özelliktir. Burada önemli nokta, tip güvenliğini korurken bu esnekliği sağlayabilmesidir. Basit bir örnekle başlayalım:\n// Generic olmayan yaklaşım - Her tip için ayrı fonksiyon function getFirstNumber(arr: number[]): number { return arr[0]; } function getFirstString(arr: string[]): string { return arr[0]; } // Generic yaklaşım - Tek fonksiyon, tüm tipler function getFirst\u0026lt;T\u0026gt;(arr: T[]): T { return arr[0]; } // Kullanım const ilkSayi = getFirst\u0026lt;number\u0026gt;([1, 2, 3]); // number tipinde const ilkMetin = getFirst\u0026lt;string\u0026gt;([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]); // string tipinde Bu örnekte \u0026lt;T\u0026gt; bir tip parametresidir ve fonksiyonun hangi tiplerle çalışacağını belirtir. TypeScript çoğu durumda tip çıkarımı yapabildiği için tip parametresini açıkça belirtmek zorunda değiliz:\nconst ilkSayi = getFirst([1, 2, 3]); // number tipini otomatik çıkarır const ilkMetin = getFirst([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]); // string tipini otomatik çıkarır Built-in Generic Tipler TypeScript\u0026rsquo;te sık kullanılan bazı yerleşik generic tipler vardır:\nArray let sayilar: Array\u0026lt;number\u0026gt; = [1, 2, 3]; // number[] let metinler: Array\u0026lt;string\u0026gt; = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;]; // string[] Promise async function veriGetir(): Promise\u0026lt;User\u0026gt; { const response = await fetch(\u0026#39;/api/user\u0026#39;); return response.json(); } Record\u0026lt;K,V\u0026gt; type KullaniciRolleri = Record\u0026lt;string, string[]\u0026gt;; const roller: KullaniciRolleri = { admin: [\u0026#39;okuma\u0026#39;, \u0026#39;yazma\u0026#39;, \u0026#39;silme\u0026#39;], editor: [\u0026#39;okuma\u0026#39;, \u0026#39;yazma\u0026#39;], user: [\u0026#39;okuma\u0026#39;], }; Generic Fonksiyonlar Yazmak Generic fonksiyonlar yazarken dikkat etmemiz gereken bazı noktalar var:\n// Basit generic fonksiyon function reverse\u0026lt;T\u0026gt;(items: T[]): T[] { return items.reverse(); } // Generic fonksiyon - Ok fonksiyonu syntax const filter = \u0026lt;T\u0026gt;(arr: T[], fn: (item: T) =\u0026gt; boolean): T[] =\u0026gt; { return arr.filter(fn); }; // Kullanım örnekleri const sayilar = reverse\u0026lt;number\u0026gt;([1, 2, 3]); const metinler = reverse([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]); // Tip çıkarımı const filtrelenmisArray = filter([1, 2, 3, 4], (n) =\u0026gt; n % 2 === 0); Çoklu Tip Parametreleri Bazen birden fazla tip parametresine ihtiyaç duyabiliriz:\nfunction cift\u0026lt;T, U\u0026gt;(x: T, y: U): [T, U] { return [x, y]; } const sonuc = cift\u0026lt;string, number\u0026gt;(\u0026#39;merhaba\u0026#39;, 42); const otomatik = cift(\u0026#39;merhaba\u0026#39;, 42); // Tip çıkarımı çalışır Tip Kısıtlamaları (Constraints) Generic tiplerin hangi özelliklere sahip olması gerektiğini belirtmek için tip kısıtlamaları kullanabiliriz:\ninterface Uzunluk { length: number; } function uzunlukGoster\u0026lt;T extends Uzunluk\u0026gt;(arg: T): number { return arg.length; } // Çalışır - string\u0026#39;in length özelliği var uzunlukGoster(\u0026#39;Merhaba\u0026#39;); // Çalışır - array\u0026#39;in length özelliği var uzunlukGoster([1, 2, 3]); // Hata - number\u0026#39;ın length özelliği yok // uzunlukGoster(123); Generic Sınıflar Generic yapıları sınıflarda da kullanabiliriz:\nclass DataContainer\u0026lt;T\u0026gt; { private data: T[]; constructor(initialData: T[]) { this.data = initialData; } add(item: T): void { this.data.push(item); } get(index: number): T { return this.data[index]; } getAll(): T[] { return this.data; } } // Kullanım const sayiContainer = new DataContainer\u0026lt;number\u0026gt;([1, 2, 3]); sayiContainer.add(4); console.log(sayiContainer.getAll()); // [1, 2, 3, 4] const metinContainer = new DataContainer\u0026lt;string\u0026gt;([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]); metinContainer.add(\u0026#39;d\u0026#39;); console.log(metinContainer.get(0)); // \u0026#39;a\u0026#39; Varsayılan Tip Parametreleri Generic tiplere varsayılan değerler atayabiliriz:\nclass Queue\u0026lt;T = number\u0026gt; { private data: T[] = []; push(item: T) { this.data.push(item); } pop(): T | undefined { return this.data.shift(); } } // number tipini varsayılan olarak kullanır const sayiKuyrugu = new Queue(); // string tipi için özelleştirilmiş const metinKuyrugu = new Queue\u0026lt;string\u0026gt;(); Generic Interface\u0026rsquo;ler Interface\u0026rsquo;lerde de generic yapıları kullanabiliriz:\ninterface APIResponse\u0026lt;T\u0026gt; { data: T; status: number; message: string; } interface User { id: number; name: string; } // Kullanım function fetchUser(): Promise\u0026lt;APIResponse\u0026lt;User\u0026gt;\u0026gt; { return fetch(\u0026#39;/api/user\u0026#39;).then((res) =\u0026gt; res.json()); } // async/await ile kullanım async function getUser(): Promise\u0026lt;APIResponse\u0026lt;User\u0026gt;\u0026gt; { const response = await fetch(\u0026#39;/api/user\u0026#39;); return response.json(); } Generic Type Inference (Tip Çıkarımı) TypeScript\u0026rsquo;in güçlü tip çıkarım sistemi sayesinde çoğu durumda generic tipleri açıkça belirtmemize gerek kalmaz:\n// Tip parametrelerini açıkça belirtme const x = getFirst\u0026lt;number\u0026gt;([1, 2, 3]); // Tip çıkarımına izin verme const y = getFirst([1, 2, 3]); // number tipini otomatik çıkarır // Generic sınıf için tip çıkarımı const container = new DataContainer([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]); // string[] çıkarımı Best Practices Generic İsimlendirme Kuralları // Yaygın kullanılan generic tip isimleri: // T: Type (Genel tip parametresi) // K: Key (Anahtar tipi) // V: Value (Değer tipi) // E: Element (Eleman tipi) // P: Properties (Özellik tipi) Tip Kısıtlamalarını Doğru Kullanma // İyi kullanım interface HasId { id: number; } function getById\u0026lt;T extends HasId\u0026gt;(items: T[], id: number): T | undefined { return items.find((item) =\u0026gt; item.id === id); } Generic Constraint vs Union Types // Generic constraint kullanımı function process\u0026lt;T extends string | number\u0026gt;(value: T): T { return value; } // Union type kullanımı function process2(value: string | number): string | number { return value; } // Generic constraint daha güvenli ve tip bilgisini korur Generic\u0026rsquo;leri Basit Tutun // Karmaşık function processData\u0026lt;T, U, V, W\u0026gt;( data: T[], transformer: (item: T) =\u0026gt; U, validator: (transformed: U) =\u0026gt; V, formatter: (validated: V) =\u0026gt; W ): W[] { // ... } // Daha iyi - Ara tipler için ayrı interface\u0026#39;ler kullan interface DataProcessor\u0026lt;T, R\u0026gt; { transform(item: T): R; } function processData\u0026lt;T, R\u0026gt;(data: T[], processor: DataProcessor\u0026lt;T, R\u0026gt;): R[] { return data.map((item) =\u0026gt; processor.transform(item)); } Generic\u0026rsquo;lerle Arrow Functions TypeScript\u0026rsquo;te generic\u0026rsquo;leri arrow function\u0026rsquo;larla kullanırken dikkat etmemiz gereken bazı syntax özellikleri vardır:\n// Standart generic arrow function const identity = (arg: T): T =\u0026gt; arg; // React ile kullanırken TSX çakışmasını önlemek için const identity = (arg: T): T =\u0026gt; arg; // Çoklu tip parametreli arrow function const pair = (first: T, second: U): [T, U] =\u0026gt; [first, second]; Generic\u0026rsquo;lerle Asenkron İşlemler Modern web uygulamalarında asenkron işlemler çok yaygın. Generic\u0026rsquo;ler bu konuda da yardımcımız olabilir:\n// Generic async fonksiyon async function fetchData(url: string): Promise { const response = await fetch(url); return response.json(); } // Kullanım interface User { id: number; name: string; email: string; } // Tip güvenli API çağrısı const user = await fetchData(\u0026#39;/api/user/1\u0026#39;); console.log(user.name); // Tip güvenli erişim // Generic error handling interface APIError { code: number; message: string; } async function fetchWithError(): Promise { try { const response = await fetch(\u0026#39;/api/data\u0026#39;); if (!response.ok) { throw (await response.json()) as APIError; } return response.json(); } catch (error) { throw error as APIError; } } Generics ile Utility Types TypeScript\u0026rsquo;in yerleşik utility type\u0026rsquo;ları da generic yapıları kullanır. İşte sık kullanılan örnekler:\n// Partial - Tüm özellikleri opsiyonel yapar interface User { id: number; name: string; email: string; } type PartialUser = Partial; // { id?: number; name?: string; email?: string; } // Pick - Belirli özellikleri seçer type UserBasicInfo = Pick; // { name: string; email: string; } // Omit - Belirli özellikleri çıkarır type UserWithoutId = Omit; // { name: string; email: string; } // Record - Key-value yapısı oluşturur type UserRoles = Record; // { [key: string]: string[] } Generic Tip Çıkarımında İleri Konular TypeScript\u0026rsquo;in tip çıkarım sistemi oldukça gelişmiştir. İşte bazı ileri seviye örnekler:\n// Return type çıkarımı function createPair(first: T) { return { first, second: first, }; } // TypeScript otomatik olarak { first: T, second: T } tipini çıkarır // Generic constraints ile tip çıkarımı interface HasLength { length: number; } function longest(a: T, b: T): T { return a.length \u0026gt;= b.length ? a : b; } // TypeScript string[] ve string için ayrı çıkarımlar yapar const longerArray = longest([1, 2], [1, 2, 3]); // type: number[] const longerString = longest(\u0026#39;123\u0026#39;, \u0026#39;12345\u0026#39;); // type: string Generic Type Alias vs Interface Generic yapıları type alias ve interface ile kullanırken bazı farklılıklar vardır:\n// Generic type alias type Container = { value: T; tag: string; }; // Generic interface interface Box { value: T; tag: string; } // İkisi de benzer şekilde kullanılır const numberContainer: Container = { value: 42, tag: \u0026#39;sayı\u0026#39; }; const stringBox: Box = { value: \u0026#39;test\u0026#39;, tag: \u0026#39;metin\u0026#39; }; // Interface\u0026#39;ler extends edilebilir interface LabeledBox extends Box { label: string; } // Type alias\u0026#39;lar intersection type ile genişletilebilir type LabeledContainer = Container \u0026amp; { label: string; }; Önemli Noktalar ve İpuçları Generic Constraint\u0026rsquo;leri İyi Düşünün\nÇok geniş constraint\u0026rsquo;ler tip güvenliğini azaltır Çok dar constraint\u0026rsquo;ler yeniden kullanılabilirliği azaltır Tip İnference\u0026rsquo;a Güvenin\nTypeScript çoğu durumda doğru tipi çıkarabilir Generic tipleri gereksiz yere açıkça belirtmeyin Okunabilirliği Koruyun\nGeneric tip isimleri anlamlı olsun Çok fazla tip parametresinden kaçının Karmaşık generic yapıları daha küçük parçalara bölün Sonuç Generic\u0026rsquo;ler, TypeScript\u0026rsquo;in en güçlü özelliklerinden biridir. Doğru kullanıldığında:\nKod tekrarını azaltır Tip güvenliğini artırır Yeniden kullanılabilir ve esnek kod yazmanızı sağlar Daha iyi IDE desteği sunar Özellikle büyük projelerde ve kütüphane geliştirirken generic\u0026rsquo;lerin gücünden maksimum fayda sağlayabilirsiniz. Generic\u0026rsquo;leri anlamak ve etkili kullanmak, TypeScript ile geliştirme yaparken vazgeçilmez bir beceridir.\nBir sonraki yazımızda TypeScript\u0026rsquo;in diğer ileri seviye özelliklerini inceleyeceğiz. Görüşmek üzere!\n",
        "tags": ["typescript","generics","type-safety"],
        "categories": ["TypeScript"],
        "lang": "tr"
    },{
        "title": "TypeScript'i Anlamak - Bölüm 6: Sınıflar",
        "permalink": "/blog/tr/typescript-serisi/typescripti-anlamak-bolum6/",
        "summary": "Bu makalede, TypeScript\u0026rsquo;in sınıf yapısını detaylı bir şekilde inceleyeceğiz. Sınıf tanımlamaları, erişim belirleyicileri, getter/setter metodları ve soyut sınıflar gibi konuları ele alacağız.",
        "content": "Merhaba! TypeScript serimizin bu bölümünde, nesne yönelimli programlamanın temel yapı taşlarından biri olan sınıfları inceleyeceğiz. TypeScript\u0026rsquo;in sınıf yapısının JavaScript\u0026rsquo;e göre avantajlarını, tip güvenliğinin nasıl sağlandığını ve kodunuzu daha güvenli hale getirmek için kullanabileceğiniz özellikleri öğreneceğiz.\nTypeScript\u0026rsquo;te Sınıf Kavramı TypeScript sınıfları, JavaScript sınıflarının tüm özelliklerini desteklerken, ek olarak tip güvenliği ve nesne yönelimli programlama için güçlü araçlar sunar. Basit bir örnekle başlayalım:\n// JavaScript\u0026#39;te bir sınıf class JsKullanici { constructor(isim) { this.isim = isim; } } // TypeScript\u0026#39;te aynı sınıf class TsKullanici { isim: string; // Tip tanımı constructor(isim: string) { // Parametre tipi this.isim = isim; } } TypeScript versiyonunda:\nSınıf özelliklerinin tipleri açıkça belirtilir Constructor parametreleri tip güvenliğine sahiptir IDE\u0026rsquo;ler daha iyi kod tamamlama desteği sağlar Temel Sınıf Yapısı Bir TypeScript sınıfı oluştururken kullanabileceğimiz temel yapılar şunlardır:\nclass Kullanici { // Sınıf özellikleri (fields) id: number; isim: string; private email: string; readonly kayitTarihi: Date; // Constructor metodu constructor(id: number, isim: string, email: string) { this.id = id; this.isim = isim; this.email = email; this.kayitTarihi = new Date(); } // Sınıf metodu bilgileriGoster(): string { return `${this.isim} (ID: ${this.id})`; } } // Sınıfı kullanma const kullanici = new Kullanici(1, \u0026#34;Ahmet Yılmaz\u0026#34;, \u0026#34;ahmet@ornek.com\u0026#34;); console.log(kullanici.bilgileriGoster()); // \u0026#34;Ahmet Yılmaz (ID: 1)\u0026#34; Bu örnekte:\nSınıf özellikleri için tip tanımlamaları yaptık Constructor\u0026rsquo;da parametre tiplerini belirttik readonly ile değişmez bir özellik tanımladık private ile erişimi kısıtladık Metod dönüş tipini belirttik Class Fields ve Erişim Belirleyiciler TypeScript\u0026rsquo;te üç tür erişim belirleyici vardır: public, private ve protected. Bunların kullanımını ve JavaScript ile farklarını inceleyelim:\nPublic Erişim Belirleyici Varsayılan erişim düzeyidir ve herhangi bir belirteç kullanmaya gerek yoktur:\nclass Araba { marka: string; // public varsayılan olarak public model: string; // açıkça public olarak belirtilmiş constructor(marka: string, model: string) { this.marka = marka; this.model = model; } } const araba = new Araba(\u0026#34;Toyota\u0026#34;, \u0026#34;Corolla\u0026#34;); console.log(araba.marka); // Erişilebilir console.log(araba.model); // Erişilebilir Private Erişim Belirleyici Private özellikler sadece sınıf içinden erişilebilir. TypeScript\u0026rsquo;te iki farklı yöntemle private özellik tanımlayabiliriz:\nclass Hesap { private _bakiye: number; // TypeScript private #harcamalar: number[]; // JavaScript private field (#) constructor(baslangicBakiye: number) { this._bakiye = baslangicBakiye; this.#harcamalar = []; } paraYatir(miktar: number): void { this._bakiye += miktar; } harcamaEkle(miktar: number): void { this.#harcamalar.push(miktar); this._bakiye -= miktar; } } const hesap = new Hesap(1000); // hesap._bakiye; // Hata: Private özelliğe erişilemez // hesap.#harcamalar; // Hata: Private field\u0026#39;a erişilemez JavaScript ve TypeScript\u0026rsquo;in private uygulamaları arasındaki farklar:\nTypeScript\u0026rsquo;in private belirteci derleme zamanında çalışır JavaScript\u0026rsquo;in # private fields özelliği çalışma zamanında çalışır kullanımı gerçek bir erişim kısıtlaması sağlar private keyword\u0026rsquo;ü sadece TypeScript tarafında koruma sağlar Protected Erişim Belirleyici Protected özellikler, sınıfın kendisi ve alt sınıfları tarafından erişilebilir:\nclass Hayvan { protected tur: string; constructor(tur: string) { this.tur = tur; } } class Kedi extends Hayvan { miyavla(): string { return `Ben bir ${this.tur}, miyav!`; // tur özelliğine erişebilir } } const kedi = new Kedi(\u0026#34;kedi\u0026#34;); // kedi.tur; // Hata: Protected özelliğe dışarıdan erişilemez Readonly ve Parameter Properties Readonly Özellikleri readonly belirteci, bir özelliğin sadece ilk atama sırasında değer alabileceğini ve sonrasında değiştirilemeyeceğini belirtir:\nclass Dokuman { readonly id: string; readonly olusturmaTarihi: Date; baslik: string; constructor(id: string, baslik: string) { this.id = id; // OK this.olusturmaTarihi = new Date(); // OK this.baslik = baslik; } idDegistir(yeniId: string) { this.id = yeniId; // Hata: readonly özellik değiştirilemez } } Parameter Properties TypeScript\u0026rsquo;in sunduğu özel bir kısayol olan parameter properties, constructor parametrelerini otomatik olarak sınıf özelliklerine dönüştürür:\n// Uzun yol class Urun { readonly id: string; private _fiyat: number; public stok: number; constructor(id: string, fiyat: number, stok: number) { this.id = id; this._fiyat = fiyat; this.stok = stok; } } // Parameter properties kullanarak class UrunKisa { constructor( readonly id: string, private _fiyat: number, public stok: number ) {} } Bu özellik sayesinde:\nDaha az kod yazarsınız Özellik tanımları ve atamaları otomatik yapılır Kod daha okunabilir hale gelir Getter ve Setter Metodları TypeScript\u0026rsquo;te get ve set anahtar kelimeleriyle özel erişim metodları tanımlayabilirsiniz:\nclass Urun { private _fiyat: number; constructor(fiyat: number) { this._fiyat = fiyat; } // Getter metodu get fiyat(): number { return this._fiyat; } // Setter metodu set fiyat(yeniFiyat: number) { if (yeniFiyat \u0026lt; 0) { throw new Error(\u0026#34;Fiyat negatif olamaz!\u0026#34;); } this._fiyat = yeniFiyat; } } const urun = new Urun(100); console.log(urun.fiyat); // Getter çağrılır: 100 urun.fiyat = 150; // Setter çağrılır // urun.fiyat = -50; // Hata fırlatır Getter ve setter metodları:\nÖzelliğe erişimi kontrol etmenizi sağlar Değer doğrulama mantığı ekleyebilirsiniz Özellik değişimlerini izleyebilirsiniz Hesaplanmış değerler döndürebilirsiniz Sınıflar ve Interface\u0026rsquo;ler TypeScript\u0026rsquo;te sınıflar bir veya daha fazla interface\u0026rsquo;i implement edebilir:\ninterface CanliVarlik { isim: string; yasiyorMu: boolean; hareket(): void; } interface YiyecekTuketici { beslen(yiyecek: string): void; } class Insan implements CanliVarlik, YiyecekTuketici { constructor(public isim: string) { this.yasiyorMu = true; } yasiyorMu: boolean; hareket(): void { console.log(\u0026#34;İki ayak üzerinde yürüyor\u0026#34;); } beslen(yiyecek: string): void { console.log(`${yiyecek} yiyor`); } } Bu yapı:\nTip güvenliği sağlar Kodun bakımını kolaylaştırır Interface\u0026rsquo;lerin tüm gereksinimlerinin karşılanmasını garanti eder Soyut (Abstract) Sınıflar Soyut sınıflar, doğrudan örneklenemeyen ve alt sınıflar için şablon görevi gören sınıflardır:\nabstract class Sekil { abstract alanHesapla(): number; abstract cevreyiHesapla(): number; bilgileriGoster(): string { return `Alan: ${this.alanHesapla()}, Çevre: ${this.cevreyiHesapla()}`; } } class Dikdortgen extends Sekil { constructor(private genislik: number, private yukseklik: number) { super(); } alanHesapla(): number { return this.genislik * this.yukseklik; } cevreyiHesapla(): number { return 2 * (this.genislik + this.yukseklik); } } // const sekil = new Sekil(); // Hata: Soyut sınıf örneklenemez const dikdortgen = new Dikdortgen(5, 3); console.log(dikdortgen.bilgileriGoster()); // \u0026#34;Alan: 15, Çevre: 16\u0026#34; Soyut sınıfların avantajları:\nOrtak davranışları tek bir yerde tanımlayabilirsiniz Alt sınıfları belirli metodları uygulamaya zorlayabilirsiniz Kodun yeniden kullanılabilirliğini artırır Soyut sınıfların önemli özellikleri:\nHem abstract hem concrete (normal) metodlar içerebilirler Generic tiplerle kullanılabilirler Protected metodlarla alt sınıflara yardımcı fonksiyonlar sağlayabilirler Ortak davranışları tek bir yerde toplayarak kod tekrarını önlerler Soyut sınıflar vs Interface\u0026rsquo;ler:\nAbstract sınıflar implementasyon içerebilirken interface\u0026rsquo;ler sadece yapıyı tanımlar Bir sınıf birden fazla interface implement edebilir ama sadece bir abstract sınıfı extend edebilir Abstract sınıflar constructor içerebilir, interface\u0026rsquo;ler içeremez Abstract sınıflar erişim belirleyicileri kullanabilir (private, protected, public) Best Practices Private Özellikleri Doğru Seçin\nclass KullaniciServisi { // TypeScript private: Sadece derleme zamanı kontrolü private _apiUrl: string; // JavaScript private field: Gerçek erişim kısıtlaması #apiKey: string; } Parameter Properties\u0026rsquo;i Etkili Kullanın\n// Kısa ve net kod için parameter properties class Konfigurasyon { constructor( private readonly apiUrl: string, private readonly timeout: number, public readonly versiyonNo: string ) {} } Interface\u0026rsquo;leri Etkin Kullanın\ninterface VeriDeposu { kaydet(veri: any): Promise\u0026lt;void\u0026gt;; getir(id: string): Promise\u0026lt;any\u0026gt;; } class PostgreSQLDepo implements VeriDeposu { // Interface\u0026#39;in gerektirdiği metodları uygula } class MongoDBDepo implements VeriDeposu { // Aynı interface, farklı implementasyon } Erişim Belirleyicilerini Bilinçli Seçin\nclass BankaHesabi { private _bakiye: number; // Dışarıdan erişim yok protected _hesapNo: string; // Alt sınıflar erişebilir public readonly hesapTuru: string; // Herkes okuyabilir ama değiştiremez } Sonuç TypeScript sınıfları, JavaScript sınıflarının sunduğu tüm özellikleri tip güvenliği ile birleştirerek güçlü bir nesne yönelimli programlama deneyimi sunar. Erişim belirleyicileri, readonly özellikleri, getter/setter metodları ve soyut sınıflar gibi özellikler, kodunuzu daha güvenli ve bakımı kolay hale getirir. Sınıfları kullanırken:\nErişim belirleyicilerini doğru seçerek kod güvenliğini artırabilir Parameter properties ile daha az kod yazabilir Interface\u0026rsquo;ler ile tip güvenliğini sağlayabilir Soyut sınıflar ile kod tekrarını azaltabilirsiniz Bir sonraki yazımızda TypeScript\u0026rsquo;in daha ileri seviye özelliklerini inceleyeceğiz. Görüşmek üzere!\n",
        "tags": ["typescript","classes","oop"],
        "categories": ["TypeScript"],
        "lang": "tr"
    },{
        "title": "TypeScript'i Anlamak - Bölüm 5: TypeScript Derleyicisi",
        "permalink": "/blog/tr/typescript-serisi/typescripti-anlamak-bolum5/",
        "summary": "Bu makalede, TypeScript derleyicisini detaylı bir şekilde inceleyeceğiz. Derleyici ayarları, yapılandırma seçenekleri ve proje yapılandırmasının nasıl yönetileceğini öğreneceğiz.",
        "content": "Merhaba! TypeScript serimizin bu bölümünde, kodlarımızın nasıl JavaScript\u0026rsquo;e dönüştüğünü ve bu süreci nasıl yönetebileceğimizi inceleyeceğiz. TypeScript derleyicisi ve yapılandırma seçenekleri, projelerimizin temelini oluşturan önemli konular arasında yer alıyor.\nTypeScript Derleyicisi Nedir? TypeScript derleyicisi (tsc), yazdığımız TypeScript kodunu tarayıcıların anlayabileceği JavaScript koduna dönüştüren araçtır. Modern TypeScript özelliklerini kullanarak yazdığımız kodları, hedeflediğimiz JavaScript sürümüne uygun hale getirir.\nProjeyi Başlatma: tsc \u0026ndash;init TypeScript projemizi başlatırken ilk adımımız, bir yapılandırma dosyası oluşturmak. Bunu tsc --init komutu ile yapabiliyoruz:\nnpx tsc --init Bu komut, projemizin kök dizininde bir tsconfig.json dosyası oluşturur. Bu dosya, derleyicinin davranışını belirleyen temel ayarları içerir:\n{ \u0026#34;compilerOptions\u0026#34;: { \u0026#34;target\u0026#34;: \u0026#34;es2016\u0026#34;, \u0026#34;module\u0026#34;: \u0026#34;commonjs\u0026#34;, \u0026#34;strict\u0026#34;: true, \u0026#34;esModuleInterop\u0026#34;: true, \u0026#34;skipLibCheck\u0026#34;: true, \u0026#34;forceConsistentCasingInFileNames\u0026#34;: true } } Watch Mode ile Geliştirme Geliştirme sürecinde kodumuzda yaptığımız değişiklikleri anında derlemek için Watch Mode kullanabiliriz:\ntsc --watch # veya tsc -w Watch Mode\u0026rsquo;un sağladığı avantajlar:\nDosya değişikliklerini otomatik algılar Anlık derleme gerçekleştirir Hataları gerçek zamanlı gösterir Geliştirme sürecini hızlandırır // örnek.ts let mesaj = \u0026#39;Merhaba TypeScript!\u0026#39;; console.log(mesaj); // Watch Mode aktifken, dosyayı kaydettiğinizde // otomatik olarak JavaScript dosyası güncellenir Çoklu Dosya Derleme TypeScript derleyicisi, projemizdeki tüm TypeScript dosyalarını tek bir komutla derleyebilir. Proje dizininde tsc komutunu çalıştırdığımızda, tüm .ts dosyaları otomatik olarak derlenir:\n// kullanici.ts export interface Kullanici { id: number; ad: string; } // servis.ts import { Kullanici } from \u0026#39;./kullanici\u0026#39;; export class KullaniciServisi { // servis kodları } // Her iki dosya da tek komutla derlenir tsconfig.json ve Temel Ayarlar Files Seçeneği tsconfig.json dosyasında files seçeneği, derlenecek dosyaları açıkça belirtmemizi sağlar:\n{ \u0026#34;compilerOptions\u0026#34;: { // diğer seçenekler }, \u0026#34;files\u0026#34;: [\u0026#34;src/main.ts\u0026#34;, \u0026#34;src/utils/helpers.ts\u0026#34;, \u0026#34;src/types/index.d.ts\u0026#34;] } Include ve Exclude Seçenekleri Projemizde hangi dosyaların derlenip hangilerinin derlenmeyeceğini belirlemek için include ve exclude seçeneklerini kullanırız:\n{ \u0026#34;compilerOptions\u0026#34;: { // diğer seçenekler }, \u0026#34;include\u0026#34;: [ \u0026#34;src/**/*\u0026#34; // src klasörü altındaki tüm dosyalar ], \u0026#34;exclude\u0026#34;: [ \u0026#34;node_modules\u0026#34;, // node_modules klasörü hariç \u0026#34;**/*.test.ts\u0026#34;, // test dosyaları hariç \u0026#34;src/temp/*\u0026#34; // geçici dosyalar hariç ] } Bu yapılandırma özellikle:\nnode_modules klasörünü derleme dışında tutmak Test dosyalarını üretim kodundan ayırmak Belirli dizinleri veya dosya türlerini hariç tutmak için kullanışlıdır OutDir: Çıktı Dizini Belirleme Derlenmiş JavaScript dosyalarının kaydedileceği yeri outDir seçeneği ile belirleriz:\n{ \u0026#34;compilerOptions\u0026#34;: { \u0026#34;outDir\u0026#34;: \u0026#34;./dist\u0026#34; } } Bu yapılandırma ile:\nTypeScript dosyaları src klasöründe kalır Derlenen JavaScript dosyaları dist klasörüne kaydedilir Proje yapısı daha düzenli hale gelir Örnek proje yapısı:\nproje/ ├── src/ │ ├── index.ts │ └── utils/ │ └── helpers.ts ├── dist/ │ ├── index.js │ └── utils/ │ └── helpers.js └── tsconfig.json Target: JavaScript Sürüm Hedefi target seçeneği, TypeScript kodumuzun hangi JavaScript sürümüne derleneceğini belirler:\n{ \u0026#34;compilerOptions\u0026#34;: { \u0026#34;target\u0026#34;: \u0026#34;es2020\u0026#34; // Diğer seçenekler: \u0026#34;es3\u0026#34;, \u0026#34;es5\u0026#34;, \u0026#34;es6\u0026#34;, \u0026#34;es2016\u0026#34;, \u0026#34;es2017\u0026#34;, \u0026#34;esnext\u0026#34; } } Farklı hedeflerin etkisini gösteren bir örnek:\n// TypeScript kodu class Hayvan { constructor(public isim: string) {} } // target: \u0026#34;es5\u0026#34; için çıktı var Hayvan = /** @class */ (function () { function Hayvan(isim) { this.isim = isim; } return Hayvan; })(); // target: \u0026#34;es2020\u0026#34; için çıktı class Hayvan { constructor(isim) { this.isim = isim; } } Strict Mode ve Null Kontrolleri TypeScript\u0026rsquo;in tip güvenliği özelliklerini en üst düzeyde kullanmak için strict modunu etkinleştirebiliriz:\n{ \u0026#34;compilerOptions\u0026#34;: { \u0026#34;strict\u0026#34;: true, \u0026#34;strictNullChecks\u0026#34;: true } } Bu ayarların etkisi:\n// strict: false let isim: string; isim = null; // Sorun yok // strict: true ve strictNullChecks: true let isim: string; isim = null; // Hata! Type \u0026#39;null\u0026#39; is not assignable to type \u0026#39;string\u0026#39; // Doğru kullanım let isim: string | null; isim = null; // Şimdi çalışır JavaScript Dosyalarını Dahil Etme Bazı projelerde JavaScript ve TypeScript dosyalarını birlikte kullanmamız gerekebilir. allowJs seçeneği bu durumu mümkün kılar:\n{ \u0026#34;compilerOptions\u0026#34;: { \u0026#34;allowJs\u0026#34;: true, \u0026#34;checkJs\u0026#34;: true // JavaScript dosyalarında tip kontrolü yapar } } Bu özellik özellikle:\nMevcut JavaScript projelerini TypeScript\u0026rsquo;e geçirirken Üçüncü parti JavaScript kütüphaneleriyle çalışırken Kademeli TypeScript adaptasyonu yaparken kullanışlıdır Örnek kullanım:\n// utils.js (JavaScript dosyası) export function topla(a, b) { return a + b; } // index.ts (TypeScript dosyası) import { topla } from \u0026#39;./utils.js\u0026#39;; const sonuc = topla(5, 3); // TypeScript tip kontrolü çalışır Best Practices Yapılandırmayı Projeye Göre Ayarlayın\n{ \u0026#34;compilerOptions\u0026#34;: { \u0026#34;target\u0026#34;: \u0026#34;es2020\u0026#34;, // Modern tarayıcılar için \u0026#34;module\u0026#34;: \u0026#34;esnext\u0026#34;, // Modern modül sistemi \u0026#34;strict\u0026#34;: true, // Sıkı tip kontrolü \u0026#34;outDir\u0026#34;: \u0026#34;./dist\u0026#34;, // Çıktı dizini \u0026#34;rootDir\u0026#34;: \u0026#34;./src\u0026#34; // Kaynak dizini } } Watch Mode\u0026rsquo;u Etkin Kullanın\n# package.json { \u0026#34;scripts\u0026#34;: { \u0026#34;dev\u0026#34;: \u0026#34;tsc --watch\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;tsc\u0026#34; } } Proje Yapısını Düzenli Tutun\nproje/ ├── src/ # TypeScript kaynak dosyaları ├── dist/ # Derlenen JavaScript dosyaları ├── tests/ # Test dosyaları ├── tsconfig.json # TypeScript yapılandırması └── package.json Uygun Include/Exclude Yapılandırması\n{ \u0026#34;include\u0026#34;: [\u0026#34;src/**/*\u0026#34;], \u0026#34;exclude\u0026#34;: [\u0026#34;node_modules\u0026#34;, \u0026#34;**/*.test.ts\u0026#34;, \u0026#34;**/*.spec.ts\u0026#34;] } Sonuç TypeScript derleyicisi ve yapılandırma seçenekleri, modern web geliştirme süreçlerinin önemli bir parçasıdır. Doğru yapılandırma ile:\nDaha güvenli kod yazabilir Geliştirme sürecini hızlandırabilir Proje yapısını daha iyi organize edebilir Takım çalışmasını kolaylaştırabilirsiniz Bir sonraki yazımızda TypeScript\u0026rsquo;in daha ileri seviye özelliklerini inceleyeceğiz. Görüşmek üzere!\n",
        "tags": ["typescript","compiler","configuration"],
        "categories": ["TypeScript"],
        "lang": "tr"
    },{
        "title": "TypeScript'i Anlamak - Bölüm 4: Interfaces",
        "permalink": "/blog/tr/typescript-serisi/typescripti-anlamak-bolum4/",
        "summary": "Bu yazıda, TypeScript\u0026rsquo;in önemli özelliklerinden biri olan interface\u0026rsquo;leri detaylı bir şekilde inceleyeceğiz. Type Aliases ile farklarını anlayacak ve pratik kullanım senaryolarını öğreneceğiz.",
        "content": "Merhaba! TypeScript serimizin bu bölümünde, tip sisteminin en güçlü özelliklerinden biri olan interface\u0026rsquo;leri detaylı bir şekilde inceleyeceğiz. Interface\u0026rsquo;lerin ne olduğunu, neden kullanmamız gerektiğini ve gerçek dünya uygulamalarında nasıl fayda sağladığını öğreneceğiz.\nInterface Nedir ve Neden Kullanmalıyız? Interface\u0026rsquo;ler, TypeScript\u0026rsquo;te objelerin yapısını tanımlamamızı sağlayan bir özelliktir. Bilale anlatır gibi söylersek:\n\u0026ldquo;Düşün ki bir inşaat planı çiziyorsun. Bu planda binanın kaç katı olacağı, odaların boyutları, pencerelerin yerleri gibi detaylar var. Interface de aynı bunun gibi - bir objenin \u0026lsquo;planını\u0026rsquo; çiziyor. Hangi özellikleri olacak, bu özellikler hangi tipte olacak, hepsini önceden belirliyoruz.\u0026rdquo;\nİşte basit bir örnek:\n// Basit bir interface tanımı interface Kullanici { // Zorunlu özellikler id: number; // Kullanıcının benzersiz numarası ad: string; // Kullanıcının adı email: string; // E-posta adresi // Opsiyonel özellikler (? işareti ile belirtilir) telefon?: string; // Telefon numarası (opsiyonel) yas?: number; // Yaş bilgisi (opsiyonel) } // Interface\u0026#39;i kullanma const yeniKullanici: Kullanici = { id: 1, ad: \u0026#39;Ahmet Yılmaz\u0026#39;, email: \u0026#39;ahmet@ornek.com\u0026#39;, // telefon ve yas opsiyonel olduğu için yazmak zorunda değiliz }; // TypeScript burada bizi korur const hataliKullanici: Kullanici = { id: \u0026#39;1\u0026#39;, // Hata! string bir değer number tipine atanamaz ad: \u0026#39;Mehmet\u0026#39;, email: true, // Hata! boolean bir değer string tipine atanamaz }; Interface Kullanmanın Avantajları Kod Güvenliği: // Interface ile tanımlanmış fonksiyon function kullaniciGuncelle(id: number, kullanici: Kullanici) { // TypeScript sayesinde kullanici objesinin yapısından eminiz console.log(`${kullanici.ad} güncelleniyor...`); // ... güncelleme işlemleri } // Bu çalışır kullaniciGuncelle(1, { id: 1, ad: \u0026#39;Ahmet\u0026#39;, email: \u0026#39;ahmet@ornek.com\u0026#39;, }); // Bu hata verir - eksik ve yanlış özellikler kullaniciGuncelle(1, { id: 1, isim: \u0026#39;Ahmet\u0026#39;, // Hata! \u0026#39;isim\u0026#39; yerine \u0026#39;ad\u0026#39; olmalı }); Kod Tamamlama: Interface\u0026rsquo;ler IDE\u0026rsquo;nizin kod tamamlama özelliğini güçlendirir. Bir objenin özelliklerine erişirken, IDE size mevcut tüm özellikleri gösterir.\nDokümantasyon: Interface\u0026rsquo;ler aynı zamanda bir dokümantasyon görevi görür. Kodunuzu okuyan diğer geliştiriciler, bir objenin yapısını hızlıca anlayabilir.\nInterface vs Type: Farkları Anlamak Interface ve Type arasındaki farkları gerçek örneklerle inceleyelim:\n1. Declaration Merging (Bildirimleri Birleştirme) // Interface\u0026#39;de bildirim birleştirme mümkün interface Araba { marka: string; } interface Araba { // Aynı isimle yeni özellikler ekleyebiliriz model: string; } const tesla: Araba = { marka: \u0026#39;Tesla\u0026#39;, // Her iki interface\u0026#39;den gelen model: \u0026#39;Model 3\u0026#39;, // özellikler gerekli }; // Type\u0026#39;da bu mümkün değil type Bisiklet = { marka: string; }; // Hata! \u0026#39;Bisiklet\u0026#39; identifier\u0026#39;ı zaten tanımlı type Bisiklet = { model: string; }; Bu özellik özellikle kütüphane geliştirirken çok faydalıdır. Kullanıcılar mevcut interface\u0026rsquo;lere yeni özellikler ekleyebilir.\n2. Extends ve Implements Interface\u0026rsquo;ler, nesne yönelimli programlamada çok kullanışlıdır:\n// Temel interface interface Hayvan { isim: string; tur: string; sesCikar(): void; } // Interface\u0026#39;den türetme interface Kedi extends Hayvan { patiliMi: boolean; tirmanabilir: boolean; } // Class\u0026#39;larda kullanım class TekirkKedisi implements Kedi { // Tüm özellikleri ve metodları implemente etmeliyiz isim: string; tur: string = \u0026#39;Kedi\u0026#39;; patiliMi: boolean = true; tirmanabilir: boolean = true; constructor(isim: string) { this.isim = isim; } sesCikar() { console.log(\u0026#39;Miyav!\u0026#39;); } } Interface Metodları ve Özellikler Interface\u0026rsquo;ler sadece veri yapısını değil, nesnelerin davranışlarını da tanımlayabilir. Gerçek bir örnek üzerinden ilerleyelim:\n// E-ticaret sisteminde ürün yönetimi için interface interface UrunYonetimi { // Temel CRUD operasyonları urunEkle(urun: Urun): Promise\u0026lt;boolean\u0026gt;; urunGuncelle(id: string, urun: Urun): Promise\u0026lt;boolean\u0026gt;; urunSil(id: string): Promise\u0026lt;boolean\u0026gt;; urunGetir(id: string): Promise\u0026lt;Urun | null\u0026gt;; // Stok yönetimi metodları stokGuncelle(urunId: string, miktar: number): Promise\u0026lt;void\u0026gt;; stokKontrol(urunId: string): Promise\u0026lt;number\u0026gt;; // İstatistik metodları satisRaporuOlustur(baslangic: Date, bitis: Date): Promise\u0026lt;SatisRaporu\u0026gt;; } // Bu interface\u0026#39;i kullanan bir class class PostgreSQLUrunYonetimi implements UrunYonetimi { constructor(private db: Database) {} async urunEkle(urun: Urun): Promise\u0026lt;boolean\u0026gt; { try { await this.db.query(\u0026#39;INSERT INTO urunler (id, ad, fiyat, stok) VALUES ($1, $2, $3, $4)\u0026#39;, [ urun.id, urun.ad, urun.fiyat, urun.stok, ]); return true; } catch (error) { console.error(\u0026#39;Ürün eklenirken hata:\u0026#39;, error); return false; } } // Diğer metodların implementasyonu... } Readonly ve Optional Özellikler Interface\u0026rsquo;lerde bazı özellikleri salt okunur (readonly) veya opsiyonel yapabiliriz. İşte gerçek bir senaryo:\n// Kullanıcı profili için interface interface KullaniciProfili { // Salt okunur özellikler (değiştirilemez) readonly id: string; // Kullanıcı ID\u0026#39;si asla değişmez readonly kayitTarihi: Date; // Kayıt tarihi değiştirilemez // Zorunlu özellikler email: string; // E-posta adresi ad: string; // Kullanıcı adı // Opsiyonel özellikler telefon?: string; // Telefon numarası adres?: { // Adres bilgileri sehir: string; ilce: string; postaKodu?: string; }; profilResmi?: string; // Profil resmi URL\u0026#39;i // Sosyal medya bilgileri (hepsi opsiyonel) sosyalMedya?: { twitter?: string; linkedin?: string; github?: string; }; } // Kullanım örneği const yeniProfil: KullaniciProfili = { id: \u0026#39;usr_123\u0026#39;, // readonly olduğu için sadece ilk atamada değer verebiliriz kayitTarihi: new Date(), // readonly olduğu için sadece ilk atamada değer verebiliriz email: \u0026#39;ali@ornek.com\u0026#39;, ad: \u0026#39;Ali Yılmaz\u0026#39;, // Opsiyonel alanları eklemek zorunda değiliz }; // HATALI KULLANIM - readonly özellikleri değiştiremeyiz yeniProfil.id = \u0026#39;usr_456\u0026#39;; // Hata! readonly özellik değiştirilemez yeniProfil.kayitTarihi = new Date(); // Hata! readonly özellik değiştirilemez // Opsiyonel özellikleri sonradan ekleyebiliriz yeniProfil.telefon = \u0026#39;555-0123\u0026#39;; yeniProfil.adres = { sehir: \u0026#39;İstanbul\u0026#39;, ilce: \u0026#39;Kadıköy\u0026#39;, }; Generic Interface\u0026rsquo;ler Generic\u0026rsquo;ler, interface\u0026rsquo;leri daha esnek ve yeniden kullanılabilir hale getirir. Örneğin, bir API yanıt yapısı için generic interface:\n// Generic API yanıt interface\u0026#39;i interface APIResponse\u0026lt;T\u0026gt; { success: boolean; // İşlem başarılı mı? data: T; // Generic veri tipi timestamp: number; // İşlem zamanı statusCode: number; // HTTP durum kodu message?: string; // Opsiyonel mesaj errors?: string[]; // Varsa hata mesajları } // Farklı veri tipleri için kullanım interface Kullanici { id: number; ad: string; email: string; } interface Urun { id: number; ad: string; fiyat: number; } // Kullanıcı listesi için API yanıtı const kullanicilarYanit: APIResponse\u0026lt;Kullanici[]\u0026gt; = { success: true, data: [ { id: 1, ad: \u0026#39;Ahmet\u0026#39;, email: \u0026#39;ahmet@ornek.com\u0026#39; }, { id: 2, ad: \u0026#39;Mehmet\u0026#39;, email: \u0026#39;mehmet@ornek.com\u0026#39; }, ], timestamp: Date.now(), statusCode: 200, }; // Tek bir ürün için API yanıtı const urunYanit: APIResponse\u0026lt;Urun\u0026gt; = { success: false, data: { id: 0, ad: \u0026#39;\u0026#39;, fiyat: 0 }, // Boş ürün timestamp: Date.now(), statusCode: 404, message: \u0026#39;Ürün bulunamadı\u0026#39;, errors: [\u0026#34;Belirtilen ID\u0026#39;ye sahip ürün mevcut değil\u0026#34;], }; Interface Inheritance (Kalıtım) Interface\u0026rsquo;ler birbirinden türeyebilir. Bu özellik, kod tekrarını önler ve modüler bir yapı oluşturmamızı sağlar:\n// Temel varlık özellikleri interface Varlik { id: string; // Benzersiz tanımlayıcı olusturmaTarihi: Date; // Oluşturulma tarihi guncellemeTarihi: Date; // Son güncelleme tarihi silindi: boolean; // Silinme durumu } // Temel kişi bilgileri interface Kisi extends Varlik { ad: string; soyad: string; email: string; telefon?: string; } // Öğrenci bilgileri interface Ogrenci extends Kisi { ogrenciNo: string; bolum: string; sinif: number; dersler: string[]; notOrtalamasi?: number; } // Öğretmen bilgileri interface Ogretmen extends Kisi { sicilNo: string; brans: string; verdigiDersler: string[]; maas: number; } // Kullanım örneği const yeniOgrenci: Ogrenci = { // Varlik\u0026#39;ten gelen özellikler id: \u0026#39;ogr_123\u0026#39;, olusturmaTarihi: new Date(), guncellemeTarihi: new Date(), silindi: false, // Kisi\u0026#39;den gelen özellikler ad: \u0026#39;Ali\u0026#39;, soyad: \u0026#39;Yılmaz\u0026#39;, email: \u0026#39;ali@okul.edu.tr\u0026#39;, // Ogrenci\u0026#39;ye özel özellikler ogrenciNo: \u0026#39;2024001\u0026#39;, bolum: \u0026#39;Bilgisayar Mühendisliği\u0026#39;, sinif: 2, dersler: [\u0026#39;Algoritma\u0026#39;, \u0026#39;Veri Yapıları\u0026#39;, \u0026#39;TypeScript 101\u0026#39;], }; Interface\u0026rsquo;lerin Yaygın Kullanım Alanları Interface\u0026rsquo;ler yazılım geliştirmenin birçok alanında karşımıza çıkar. İşte en yaygın kullanım alanları:\n1. API İletişimi API\u0026rsquo;lerle çalışırken, gelen ve giden veri yapılarını tanımlamak için interface\u0026rsquo;leri kullanırız. Örneğin:\n// API\u0026#39;den gelecek kullanıcı verisinin yapısı interface KullaniciYaniti { id: number; ad: string; email: string; rol: \u0026#39;admin\u0026#39; | \u0026#39;kullanici\u0026#39;; sonGiris?: Date; } // API\u0026#39;ye gönderilecek giriş bilgileri interface GirisBilgileri { email: string; sifre: string; hatirla?: boolean; } 2. Veritabanı İşlemleri Veritabanı işlemlerinde, tablo yapılarını ve sorgu sonuçlarını modellemek için interface\u0026rsquo;leri kullanırız:\ninterface Urun { id: number; // Ürün benzersiz numarası ad: string; // Ürün adı fiyat: number; // Ürün fiyatı stok: number; // Stok miktarı kategori: string; // Ürün kategorisi } 3. Form Yönetimi Form verilerinin yapısını ve doğrulama kurallarını tanımlarken interface\u0026rsquo;ler işimizi kolaylaştırır:\ninterface KayitFormu { email: string; // Kullanıcı e-postası sifre: string; // Şifre sifreTekrar: string; // Şifre tekrarı kullaniciAdi: string; // Kullanıcı adı } 4. Yapılandırma Yönetimi Uygulama ayarlarını ve yapılandırmalarını tanımlarken interface\u0026rsquo;leri kullanırız:\ninterface UygulamaAyarlari { apiUrl: string; // API sunucu adresi maxDeneme: number; // Maximum deneme sayısı timeout: number; // Zaman aşımı süresi debug: boolean; // Debug modu açık/kapalı } 5. Veri Modelleri Uygulamamızdaki temel veri yapılarını tanımlarken interface\u0026rsquo;lerden faydalanırız:\ninterface Siparis { id: string; // Sipariş numarası musteriId: string; // Müşteri numarası urunler: string[]; // Siparişteki ürünler toplamTutar: number; // Toplam tutar durum: \u0026#39;beklemede\u0026#39; | \u0026#39;onaylandi\u0026#39; | \u0026#39;iptal\u0026#39;; // Sipariş durumu } Bu kullanım alanları, interface\u0026rsquo;lerin tip güvenliği ve kod organizasyonu açısından ne kadar önemli olduğunu gösterir. Her bir alanda interface\u0026rsquo;ler, kodumuzun daha güvenli ve bakımı kolay olmasını sağlar.\nBest Practices ve İpuçları TypeScript interface\u0026rsquo;lerini kullanırken dikkat etmemiz gereken bazı önemli noktalar var. Bu pratikleri uygulayarak daha okunabilir ve bakımı kolay kod yazabiliriz.\n1. İsimlendirme Kuralları Interface isimleri, ne iş yaptıklarını açıkça belirtmeli ve bazı standartlara uymalı:\n// ✅ İyi İsimlendirme Örnekleri interface KullaniciServisi { kullaniciGetir(id: string): Promise\u0026lt;Kullanici\u0026gt;; } interface UrunDeposu { stokGuncelle(urunId: string, miktar: number): void; } // ❌ Kaçınılması Gereken İsimlendirmeler interface IKullanici { // \u0026#39;I\u0026#39; öneki kullanmayın // ... } interface veriYoneticisi { // PascalCase kullanın // ... } interface DATA_SERVICE { // BÜYÜK HARF kullanmayın // ... } 2. Tek Sorumluluk Prensibi Her interface tek bir işe odaklanmalı ve o işi iyi yapmalı:\n// ✅ İyi Tasarlanmış Interface\u0026#39;ler interface KimlikBilgileri { id: string; tcKimlikNo: string; pasaportNo?: string; } interface IletisimBilgileri { email: string; telefon?: string; adres?: { il: string; ilce: string; }; } // İhtiyaç halinde birleştirin interface Kullanici extends KimlikBilgileri, IletisimBilgileri { ad: string; soyad: string; } // ❌ Kaçınılması Gereken Durum: Her şeyi tek interface\u0026#39;de toplamak interface KocamanInterface { // Kimlik bilgileri id: string; tcKimlikNo: string; // İletişim bilgileri email: string; telefon: string; // Adres bilgileri il: string; ilce: string; // Kullanıcı bilgileri ad: string; soyad: string; // Diğer bilgiler... // ... ve daha birçok özellik } 3. Açıklayıcı Yorumlar Ekleme Interface\u0026rsquo;lerin nasıl kullanılacağını açıkça belirten yorumlar ekleyin:\n/** * Ödeme işlemi sırasında kullanılacak kart bilgileri. * Bu interface sadece ödeme işlemi sırasında kullanılmalı ve * hassas bilgiler işlem sonrası bellekten temizlenmelidir. */ interface OdemeBilgileri { /** Ödenecek tutar (TL cinsinden, kuruş hassasiyetinde) */ tutar: number; /** 16 haneli kart numarası */ kartNo: string; /** AA/YY formatında son kullanma tarihi (örnek: 12/25) */ sonKullanmaTarihi: string; /** Kartın arkasındaki 3 haneli güvenlik kodu */ guvenlikKodu: string; } 4. Opsiyonel Özellikleri Doğru Kullanma Opsiyonel özellikleri kullanırken dikkatli olun ve belgelendirin:\ninterface KullaniciProfili { // Zorunlu alanlar id: string; ad: string; email: string; // Opsiyonel alanlar - neden opsiyonel olduklarını açıklayın /** Kullanıcı telefon vermek istemeyebilir */ telefon?: string; /** Profil fotoğrafı yüklenmemişse varsayılan kullanılır */ profilFotoUrl?: string; /** Kullanıcı henüz konum izni vermemiş olabilir */ konum?: { lat: number; lng: number; }; } Sonuç Interface\u0026rsquo;ler, TypeScript\u0026rsquo;in en güçlü özelliklerinden biridir ve doğru kullanıldığında:\nKodunuzu daha okunabilir hale getirir Tip güvenliği sağlar Bakımı kolaylaştırır Takım çalışmasını iyileştirir Dokümantasyon görevi görür Bu yazıda gördüğümüz örnekler ve best practice\u0026rsquo;ler, günlük TypeScript geliştirmelerinizde size yol gösterecektir. Bir sonraki yazıda görüşeceğiz.\nSorularınız varsa yorum bırakabilirsiniz. İyi kodlamalar! 🚀\n",
        "tags": ["typescript","interfaces","type-system"],
        "categories": ["TypeScript"],
        "lang": "tr"
    },{
        "title": "TypeScript'i Anlamak - Bölüm 3: Obje Tipleri",
        "permalink": "/blog/tr/typescript-serisi/typescripti-anlamak-bolum3/",
        "summary": "Bu makalede, TypeScript\u0026rsquo;teki obje tiplerini detaylı bir şekilde inceleyeceğiz. Obje tanımlamaları, tip takma adları ve iç içe objelerle çalışmayı öğreneceğiz.",
        "content": "Merhaba! TypeScript serimizin bu bölümünde, object types konusunu detaylı bir şekilde inceleyeceğiz. Özellikle fonksiyonlarda obje tiplerinin nasıl kullanıldığına ve type alias\u0026rsquo;ların neden önemli olduğuna odaklanacağız.\nObject Annotations ile Çalışmak TypeScript\u0026rsquo;te fonksiyonlarda obje parametreleri tanımlarken iki farklı yaklaşım kullanabiliriz. İlk olarak, doğrudan fonksiyon parametresi içinde obje tipini tanımlayabiliriz:\n// Parametre içinde doğrudan obje tipi tanımlama const printName = (name: { first: string; last: string }) =\u0026gt; { return `Name: ${name.first} ${name.last}`; }; // Kullanımı printName({ first: \u0026#39;Will\u0026#39;, last: \u0026#39;Ferrell\u0026#39; }); Bu yaklaşım basit objeler için kullanışlı olsa da, karmaşık obje yapılarında okunabilirliği azaltabilir ve kod tekrarına yol açabilir. Özellikle aynı obje tipini birden fazla yerde kullanacaksanız, bu yaklaşım yerine type alias kullanmanız önerilir.\nSüslü Parantezlerin Kullanımı Fonksiyon parametrelerinde obje tiplerini tanımlarken süslü parantezlerin kullanımı bazen kafa karıştırıcı olabilir:\n// Kafa karıştırıcı olabilecek syntax const printPerson = (person: { name: string; age: number }): { info: string } =\u0026gt; { return { info: `${person.name} is ${person.age} years old` }; }; // Daha okunaklı versiyonu - Type Alias kullanarak type Person = { name: string; age: number; }; type PersonInfo = { info: string; }; const printPerson2 = (person: Person): PersonInfo =\u0026gt; { return { info: `${person.name} is ${person.age} years old` }; }; İkinci yaklaşım daha okunaklıdır çünkü:\nTip tanımlamaları fonksiyon tanımından ayrılmıştır Tipler yeniden kullanılabilir Kod daha düzenli ve bakımı daha kolaydır Type Alias Kullanımı Type alias\u0026rsquo;lar, obje tiplerini ayrı olarak tanımlamamıza ve bu tipleri kodumuzda tekrar tekrar kullanmamıza olanak sağlar:\n// Type alias tanımlama type Person = { name: string; age: number; }; // Fonksiyonda kullanma const sayHappyBirthday = (person: Person) =\u0026gt; { return `Hey ${person.name}, congrats on turning ${person.age}!`; }; // Değişkende kullanma const jerry: Person = { name: \u0026#39;Jerry\u0026#39;, age: 42, }; sayHappyBirthday(jerry); Type alias kullanmanın avantajları:\nKod tekrarını önler Tip tanımlarını merkezi bir yerde tutar Değişiklikleri tek bir yerden yönetmeyi sağlar Kodun okunabilirliğini artırır Nested Objects (İç İçe Objeler) TypeScript\u0026rsquo;te iç içe obje yapıları tanımlamak oldukça yaygındır. İşte bir örnek:\nconst describePerson = (person: { name: string; age: number; parentNames: { mom: string; dad: string; }; }) =\u0026gt; { return `Person: ${name}, Age: ${age}, Parents: ${parentNames.mom}, ${parentNames.dad}`; }; // Kullanımı describePerson({ name: \u0026#39;Jimmy\u0026#39;, age: 10, parentNames: { mom: \u0026#39;Kim\u0026#39;, dad: \u0026#39;Steve\u0026#39;, }, }); Bu yapıyı type alias kullanarak daha düzenli hale getirebiliriz:\ntype ParentNames = { mom: string; dad: string; }; type PersonWithParents = { name: string; age: number; parentNames: ParentNames; }; const describePerson2 = (person: PersonWithParents) =\u0026gt; { const { name, age, parentNames } = person; return `Person: ${name}, Age: ${age}, Parents: ${parentNames.mom}, ${parentNames.dad}`; }; Excess Properties (Fazla Özellikler) TypeScript, bir obje tipinde tanımlanmamış özellikleri kullanmaya çalıştığınızda sizi uyarır:\ntype BasicPerson = { name: string; age: number; }; // Hata verecek const person: BasicPerson = { name: \u0026#39;John\u0026#39;, age: 30, location: \u0026#39;New York\u0026#39;, // Fazla özellik hatası }; // Doğru kullanım const personData = { name: \u0026#39;John\u0026#39;, age: 30, location: \u0026#39;New York\u0026#39;, }; const person2: BasicPerson = personData; // Bu çalışır Optional Properties Bazen obje tipindeki bazı özelliklerin opsiyonel olmasını isteyebiliriz:\ntype OptionalPerson = { name: string; age: number; phone?: string; // Opsiyonel özellik email?: string; // Opsiyonel özellik }; // Her iki kullanım da geçerli const person1: OptionalPerson = { name: \u0026#39;Alice\u0026#39;, age: 25, }; const person2: OptionalPerson = { name: \u0026#39;Bob\u0026#39;, age: 30, phone: \u0026#39;555-0123\u0026#39;, email: \u0026#39;bob@email.com\u0026#39;, }; Readonly Modifier TypeScript\u0026rsquo;te readonly modifier, bir nesnenin özelliklerinin değiştirilmesini engellemek için kullanılır. Bu, veri bütünlüğünü korumak ve istenmeyen değişiklikleri önlemek için oldukça kullanışlıdır:\ntype Person = { readonly name: string; readonly age: number; }; const john: Person = { name: \u0026#39;John\u0026#39;, age: 30, }; // Aşağıdaki satırlar derleme zamanında hata verecektir // john.name = \u0026#34;Johnny\u0026#34;; // Hata: Cannot assign to \u0026#39;name\u0026#39; because it is a read-only property // john.age = 31; // Hata: Cannot assign to \u0026#39;age\u0026#39; because it is a read-only property readonly modifier, nesnenin ilk oluşturulması sırasında değer atamasına izin verir, ancak daha sonra bu özelliklerin değiştirilmesini engeller.\nReadonly Array Diziler için de readonly modifier kullanılabilir. Bu, dizinin içeriğinin değiştirilmesini engeller:\nconst numbers: readonly number[] = [1, 2, 3, 4, 5]; // Aşağıdaki metodlar artık kullanılamaz // numbers.push(6); // Hata // numbers.pop(); // Hata // numbers[2] = 10; // Hata Intersection Types Intersection types, birden fazla tipi birleştirerek yeni bir tip oluşturmamıza olanak sağlar:\ntype Employee = { employeeId: number; department: string; }; type Person = { name: string; age: number; }; // İki tipi birleştiren yeni bir tip type EmployeePerson = Employee \u0026amp; Person; const worker: EmployeePerson = { employeeId: 1234, department: \u0026#39;Engineering\u0026#39;, name: \u0026#39;Alice\u0026#39;, age: 30, }; Intersection types, karmaşık nesne yapıları oluştururken oldukça kullanışlıdır. Birden fazla tipin özelliklerini tek bir tipte birleştirebilirsiniz.\nIntersection Type Örneği Intersection type\u0026rsquo;ların nasıl kullanılabileceğini gösteren basit bir örneğe bakalım:\n// Adres bilgilerini içeren tip type Address = { street: string; city: string; country: string; }; // İletişim bilgilerini içeren tip type Contact = { email: string; phone: string; }; // İki tipi birleştirerek tam bir kullanıcı profili oluşturma type UserProfile = Person \u0026amp; Address \u0026amp; Contact; // Kullanım örneği: const user: UserProfile = { name: \u0026#39;Ahmet\u0026#39;, age: 30, street: \u0026#39;Atatürk Caddesi\u0026#39;, city: \u0026#39;İstanbul\u0026#39;, country: \u0026#39;Türkiye\u0026#39;, email: \u0026#39;ahmet@email.com\u0026#39;, phone: \u0026#39;555-0123\u0026#39; }; // Fonksiyonda kullanım örneği function displayUserInfo(user: UserProfile) { console.log(` Kullanıcı: ${user.name} Yaş: ${user.age} Adres: ${user.street}, ${user.city}, ${user.country} İletişim: ${user.email}, ${user.phone} `); } displayUserInfo(user); Bu örnek, intersection type\u0026rsquo;ların nasıl farklı özellikleri birleştirmek için kullanılabileceğini gösteriyor:\nTip Kompozisyonu: Farklı amaçlar için ayrı tipler tanımlıyoruz (Person, Address, Contact) Intersection Types: Bu tipleri \u0026amp; operatörü ile birleştirerek daha kapsamlı bir tip oluşturuyoruz Modülerlik: Her tip kendi sorumluluğuna sahip ve ayrı ayrı yönetilebilir Yeniden Kullanılabilirlik: Bu tipleri başka yerlerde de kullanabiliriz Bu desen özellikle şunları yapmak istediğinizde kullanışlıdır:\nFarklı veri gruplarını mantıksal olarak ayırmak Kodunuzu daha modüler hale getirmek Tip tanımlarını yeniden kullanmak Karmaşık veri yapılarını organize etmek Array Types TypeScript\u0026rsquo;te dizi tipleri birkaç farklı şekilde tanımlanabilir:\n// Birinci yöntem: Köşeli parantez kullanarak const numbers: number[] = [1, 2, 3, 4, 5]; // İkinci yöntem: Generic Array tipi kullanarak const strings: Array\u0026lt;string\u0026gt; = [\u0026#39;hello\u0026#39;, \u0026#39;world\u0026#39;]; // Karışık tip dizisi const mixed: (number | string)[] = [1, \u0026#39;two\u0026#39;, 3, \u0026#39;four\u0026#39;]; // Tuple (Sabit uzunlukta, farklı tiplerde dizi) const employee: [number, string] = [1, \u0026#39;John Doe\u0026#39;]; // Readonly dizi const readonlyNumbers: readonly number[] = [1, 2, 3]; Dizi Metodları ve Tip Çıkarımı TypeScript, dizi metodlarında akıllı tip çıkarımı yapar:\nconst numbers = [1, 2, 3, 4, 5]; const doubled = numbers.map((x) =\u0026gt; x * 2); // doubled tipi number[] const names = [\u0026#39;Alice\u0026#39;, \u0026#39;Bob\u0026#39;, \u0026#39;Charlie\u0026#39;]; const upperNames = names.map((name) =\u0026gt; name.toUpperCase()); // upperNames tipi string[] Çok Boyutlu Diziler (Multi-Dimensional Arrays) TypeScript\u0026rsquo;te çok boyutlu diziler, iç içe diziler veya matris benzeri veri yapıları oluşturmak için kullanılır:\n// 2 Boyutlu sayı dizisi const matrix: number[][] = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ]; // 3 Boyutlu dizi örneği const threeDimensionalArray: number[][][] = [ [ [1, 2], [3, 4], ], [ [5, 6], [7, 8], ], [ [9, 10], [11, 12], ], ]; // Karışık tipli 2 boyutlu dizi const mixedMatrix: (number | string)[][] = [ [1, \u0026#39;two\u0026#39;, 3], [\u0026#39;four\u0026#39;, 5, \u0026#39;six\u0026#39;], ]; // Çok boyutlu dizi üzerinde işlemler const sumMatrix = (matrix: number[][]): number =\u0026gt; { return matrix.flat().reduce((sum, num) =\u0026gt; sum + num, 0); }; console.log(sumMatrix(matrix)); // Tüm elemanların toplamını verir // Dizi boyutunu kontrol etme const printMatrixInfo = (matrix: number[][]) =\u0026gt; { console.log(`Matris boyutu: ${matrix.length} x ${matrix[0].length}`); }; printMatrixInfo(matrix); // \u0026#34;Matris boyutu: 3 x 3\u0026#34; çıktısı verir Çok boyutlu diziler, özellikle görüntü işleme, oyun geliştirme, bilimsel hesaplamalar gibi alanlarda sıkça kullanılır. TypeScript, bu tür karmaşık dizi yapılarında güçlü tip kontrolü sağlar.\nSonuç TypeScript\u0026rsquo;in object types özellikleri, kodunuzun tip güvenliğini artırır ve daha net, hata ayıklaması kolay kod yazmanıza yardımcı olur. readonly modifier, intersection types, esnek dizi tipleri ve çok boyutlu diziler, TypeScript\u0026rsquo;in güçlü tip sisteminin önemli parçalarıdır.\nBir sonraki yazımızda görüşmek üzere!\n",
        "tags": ["typescript","javascript","object-types"],
        "categories": ["TypeScript"],
        "lang": "tr"
    },{
        "title": "TypeScript'i Anlamak - Bölüm 2: Fonksiyonlar",
        "permalink": "/blog/tr/typescript-serisi/typescripti-anlamak-bolum2/",
        "summary": "Bu makalede, TypeScript fonksiyonlarını detaylı bir şekilde inceleyeceğiz. Parametre tipleri, dönüş tipleri ve TypeScript\u0026rsquo;i benzersiz ve güçlü kılan özel fonksiyon tiplerini ele alacağız.",
        "content": "Merhaba! Önceki yazımızda TypeScript\u0026rsquo;teki temel tipleri incelemiştik. Bugün, fonksiyonları ve TypeScript\u0026rsquo;in onları nasıl daha güçlü ve güvenli hale getirdiğini öğreneceğiz. Basit örneklerle başlayıp, adım adım daha ileri konulara geçeceğiz.\nFonksiyon Parametre Tipleri TypeScript\u0026rsquo;te fonksiyon parametrelerinin tipini belirleyebiliriz. Bu özellik, yanlış tip bir değer gönderildiğinde daha kod çalıştırılmadan hata almamızı sağlar. Basit bir örnekle başlayalım:\n// Tipli parametrelerle fonksiyon oluşturma const ogrenciyiCesaretle = (isim: string) =\u0026gt; { return `Hey, ${isim}, harika gidiyorsun!`; }; // Bu çalışır ogrenciyiCesaretle(\u0026#39;sen\u0026#39;); // Çıktı: \u0026#34;Hey, sen, harika gidiyorsun!\u0026#34; // Bu TypeScript hatası verir ogrenciyiCesaretle(85); // Hata: \u0026#39;number\u0026#39; tipi \u0026#39;string\u0026#39; tipine atanamaz Her parametreden sonra yazdığımız tip açıklaması (örneğin : string), TypeScript\u0026rsquo;e bu fonksiyonun hangi tipte değerler bekleyeceğini söyler. Bu sayede hataları daha kod yazarken yakalayabiliriz.\nÇoklu Parametreler Fonksiyonlar birden fazla parametre alabilir ve her parametrenin kendi tipini belirleyebiliriz:\nfunction kullaniciOlustur(isim: string, yas: number, aktifMi: boolean) { return { isim, yas, aktifMi, }; } // Doğru kullanım kullaniciOlustur(\u0026#39;Ahmet\u0026#39;, 25, true); // TypeScript bu hataları yakalar kullaniciOlustur(\u0026#39;Ahmet\u0026#39;, \u0026#39;25\u0026#39;, true); // Hata: yaş number olmalı kullaniciOlustur(\u0026#39;Ahmet\u0026#39;); // Hata: eksik parametreler kullaniciOlustur(\u0026#39;Ahmet\u0026#39;, 25, \u0026#39;evet\u0026#39;); // Hata: aktifMi boolean olmalı Bu örnekte kullaniciOlustur fonksiyonu üç farklı tipte parametre alıyor. TypeScript, bu parametrelerin doğru tipte ve eksiksiz gönderildiğinden emin olmamızı sağlıyor.\nFonksiyon Dönüş Tipleri TypeScript ile bir fonksiyonun hangi tipte değer döndüreceğini de belirtebiliriz. TypeScript çoğu zaman dönüş tipini otomatik olarak anlayabilse de (buna type inference denir), açıkça belirtmek kodunuzu daha okunabilir ve bakımı kolay hale getirir:\nconst sayilariTopla = (x: number, y: number): number =\u0026gt; { return x + y; }; sayilariTopla(5, 5); // Dönüş: 10 const metinBirlestir = (a: string, b: string): string =\u0026gt; { return a + \u0026#39; \u0026#39; + b; }; metinBirlestir(\u0026#39;Merhaba\u0026#39;, \u0026#39;Dünya\u0026#39;); // Dönüş: \u0026#34;Merhaba Dünya\u0026#34; Bu örneklerde parametre listesinden sonra gelen : number ve : string ifadeleri, fonksiyonların hangi tipte değer döndüreceğini belirtir. Bu sayede:\nFonksiyonun ne döndüreceği konusunda dokümentasyon sağlamış oluruz Yanlış tipte bir değer döndürmeye çalıştığımızda hemen hata alırız Fonksiyonu kullanan diğer geliştiriciler, ne bekleyeceklerini önceden bilirler void Dönüş Tipi Bazen fonksiyonlarımız herhangi bir değer döndürmez, sadece bir işlem yaparlar. TypeScript\u0026rsquo;te bunu belirtmek için void tipini kullanırız:\nconst kullaniciyiUyar = (mesaj: string): void =\u0026gt; { alert(mesaj); // Hiçbir şey döndürmüyoruz }; const logla = (data: any): void =\u0026gt; { console.log(data); // return yazmadık bile }; void dönüş tipi, fonksiyonun bir değer döndürmeyeceğini söyler. Bu özellikle önemlidir çünkü:\nKodunuzu okuyan diğer geliştiriciler fonksiyondan bir değer beklememeleri gerektiğini bilirler Yanlışlıkla bir değer döndürmeye çalışırsanız TypeScript hata verir API\u0026rsquo;lerinizi daha net ve anlaşılır hale getirir Opsiyonel Parametreler ve Varsayılan Değerler TypeScript\u0026rsquo;te parametreleri iki şekilde esnek hale getirebiliriz: opsiyonel parametreler ve varsayılan değerler.\nOpsiyonel Parametreler Bir parametrenin sonuna ? işareti koyarak o parametrenin opsiyonel olduğunu belirtiriz:\nfunction kisiSelam(isim: string, unvan?: string) { if (unvan) { return `Merhaba ${unvan} ${isim}`; } return `Merhaba ${isim}`; } kisiSelam(\u0026#39;Ahmet\u0026#39;); // Çıktı: \u0026#34;Merhaba Ahmet\u0026#34; kisiSelam(\u0026#39;Ahmet\u0026#39;, \u0026#39;Dr.\u0026#39;); // Çıktı: \u0026#34;Merhaba Dr. Ahmet\u0026#34; Varsayılan Değerler Parametrelere varsayılan değerler atayarak, değer gönderilmediğinde ne kullanılacağını belirleyebiliriz:\nfunction kahveSiparis(kahveTuru: string = \u0026#39;Americano\u0026#39;, boyut: string = \u0026#39;orta\u0026#39;, sut: boolean = false) { let siparis = `${boyut} boy ${kahveTuru}`; if (sut) siparis += \u0026#39; sütlü\u0026#39;; return siparis; } kahveSiparis(); // \u0026#34;orta boy Americano\u0026#34; kahveSiparis(\u0026#39;Latte\u0026#39;); // \u0026#34;orta boy Latte\u0026#34; kahveSiparis(\u0026#39;Espresso\u0026#39;, \u0026#39;küçük\u0026#39;); // \u0026#34;küçük boy Espresso\u0026#34; kahveSiparis(\u0026#39;Mocha\u0026#39;, \u0026#39;büyük\u0026#39;, true); // \u0026#34;büyük boy Mocha sütlü\u0026#34; Opsiyonel parametreler ve varsayılan değerler arasındaki farklar:\nOpsiyonel Parametreler (?)\nParametre gönderilmezse undefined olur Fonksiyon içinde kontrol etmeniz gerekir Daha esnek ama daha fazla kontrol gerektirir Varsayılan Değerler (= değer)\nParametre gönderilmezse belirlediğiniz değer kullanılır Ekstra kontrol gerektirmez Daha az esnek ama kullanımı daha kolay Önemli Nokta: Parametre Sırası Hem opsiyonel hem zorunlu parametreler kullanırken, zorunlu parametreler her zaman önce gelmelidir:\n// DOĞRU function dogru(zorunlu: string, opsiyonel?: string) {} // YANLIŞ - TypeScript hata verir function yanlis(opsiyonel?: string, zorunlu: string) {} // Hata! Bu kural varsayılan değerler için de geçerlidir:\n// DOĞRU function dogru2(zorunlu: string, varsayilan: string = \u0026#39;default\u0026#39;) {} // YANLIŞ function yanlis2(varsayilan: string = \u0026#39;default\u0026#39;, zorunlu: string) {} // Hata! Bu kurala uymak, kodunuzun daha mantıklı ve anlaşılır olmasını sağlar. Ayrıca JavaScript\u0026rsquo;in fonksiyon çağrılarını nasıl işlediğiyle de uyumludur.\nAnonim Fonksiyonlar ve Tip Çıkarımı TypeScript\u0026rsquo;in en güçlü özelliklerinden biri, tipleri otomatik olarak çıkarabilme yeteneğidir. Bu özellikle anonim fonksiyonlarda çok kullanışlıdır:\nconst sayilar = [1, 2, 3, 4, 5]; // TypeScript otomatik olarak \u0026#39;sayi\u0026#39; parametresinin number olduğunu anlar sayilar.forEach((sayi) =\u0026gt; { console.log(sayi.toFixed(2)); // TypeScript bunu güvenli buluyor }); // Dizi metotlarında da tip çıkarımı çalışır const kareler = sayilar.map((sayi) =\u0026gt; sayi * sayi); // kareler dizisinin tipi number[] olarak çıkarılır Tip çıkarımı kod yazarken işimizi kolaylaştırır, ancak her zaman tip belirtmemek kodunuzu daha az okunabilir hale getirebilir. Bu yüzden dengeyi iyi kurmak önemlidir.\nnever Tipi never tipi, TypeScript\u0026rsquo;te özel bir tiptir ve asla gerçekleşmeyecek durumları temsil eder. İki ana kullanım senaryosu vardır:\nSonsuz Döngüler: Asla tamamlanmayan fonksiyonlar function sonsuzdDongu(): never { while (true) { console.log(\u0026#39;Bu fonksiyon asla bitmeyecek!\u0026#39;); } } function sonsuzOzyineleme(): never { return sonsuzOzyineleme(); } Her Zaman Hata Fırlatan Fonksiyonlar: function hataFirlat(mesaj: string): never { throw new Error(mesaj); } function hataKontrol(deger: string | number) { if (typeof deger === \u0026#39;string\u0026#39;) { console.log(\u0026#39;Bu bir string:\u0026#39;, deger); } else if (typeof deger === \u0026#39;number\u0026#39;) { console.log(\u0026#39;Bu bir number:\u0026#39;, deger); } else { // Bu noktada deger tipi \u0026#39;never\u0026#39; olur // Çünkü buraya ulaşmak imkansızdır hataFirlat(\u0026#39;Bu asla olmamalı!\u0026#39;); } } never ile void arasındaki farkı anlamak önemlidir:\nvoid: Fonksiyon bir değer döndürmez never: Fonksiyon asla tamamlanmaz veya her zaman bir hata fırlatır Fonksiyon Aşırı Yüklemesi (Function Overloads) TypeScript\u0026rsquo;te bir fonksiyonu farklı parametre tipleriyle kullanmak istediğimizde fonksiyon aşırı yüklemesini kullanabiliriz:\n// Aşırı yükleme imzaları function birlestir(a: string, b: string): string; function birlestir(a: number, b: number): number; // Gerçek implementasyon function birlestir(a: string | number, b: string | number): string | number { if (typeof a === \u0026#39;string\u0026#39; \u0026amp;\u0026amp; typeof b === \u0026#39;string\u0026#39;) { return a.concat(b); } if (typeof a === \u0026#39;number\u0026#39; \u0026amp;\u0026amp; typeof b === \u0026#39;number\u0026#39;) { return a + b; } throw new Error(\u0026#39;Parametreler aynı tipte olmalıdır!\u0026#39;); } console.log(birlestir(\u0026#39;Merhaba, \u0026#39;, \u0026#39;Dünya\u0026#39;)); // \u0026#34;Merhaba, Dünya\u0026#34; console.log(birlestir(5, 10)); // 15 // birlestir(\u0026#34;5\u0026#34;, 10); // Hata! Bu kombinasyon tanımlı değil Fonksiyon aşırı yüklemesi sayesinde:\nAynı fonksiyonu farklı parametre tipleriyle kullanabiliriz Her kombinasyon için doğru dönüş tipini belirleyebiliriz TypeScript hangi kombinasyonların geçerli olduğunu kontrol eder En İyi Uygulamalar TypeScript fonksiyonları yazarken izlemeniz gereken bazı önemli pratikler vardır. İşte bu pratikler ve nedenleri:\nHer Zaman Parametre Tiplerini Belirtin\n// KÖTÜ function kotu(isim) { return `Merhaba ${isim}`; } // İYİ function iyi(isim: string): string { return `Merhaba ${isim}`; } Tip belirtmek kodunuzu daha okunabilir yapar ve hataları önler.\nDönüş Tiplerini Düşünün\n// Otomatik çıkarım bazen yeterlidir const topla = (a: number, b: number) =\u0026gt; a + b; // Ama karmaşık fonksiyonlarda dönüş tipini belirtmek daha iyidir function veriIsle(data: any[]): ProcessedData { // Karmaşık işlemler... return islenmisSonuc; } Opsiyonel Parametreleri Sona Koyun\n// KÖTÜ function kotu(opsiyonel?: string, zorunlu: string) {} // İYİ function iyi(zorunlu: string, opsiyonel?: string) {} any Tipinden Kaçının\n// KÖTÜ function herhangiVeri(data: any) { return data.birsey(); // Tehlikeli! } // İYİ function tipliVeri\u0026lt;T\u0026gt;(data: T) { // Tip güvenli işlemler } Fonksiyon Dokümantasyonu Yazın\n/** * Verilen sayıları toplar ve sonucu döndürür * @param sayilar - Toplanacak sayı dizisi * @returns Toplam değer */ function topla(...sayilar: number[]): number { return sayilar.reduce((a, b) =\u0026gt; a + b, 0); } Hızlı Başvuru İşte TypeScript\u0026rsquo;te en sık kullanılan fonksiyon yapılarının hızlı bir özeti:\n1. Temel Fonksiyon Tanımlamaları // Normal fonksiyon function selamla(isim: string): string { return `Merhaba ${isim}`; } // Ok fonksiyonu const selamla2 = (isim: string): string =\u0026gt; `Merhaba ${isim}`; 2. Parametre Çeşitleri // Opsiyonel parametre function log(mesaj: string, seviye?: string) {} // Varsayılan değerli parametre function baglan(url: string = \u0026#39;localhost\u0026#39;) {} // Rest parametresi function toplam(...sayilar: number[]): number { return sayilar.reduce((a, b) =\u0026gt; a + b, 0); } 3. Dönüş Tipleri // Değer döndüren function topla(a: number, b: number): number { return a + b; } // Void dönüş function logla(mesaj: string): void { console.log(mesaj); } // Never dönüş function hataFirlat(mesaj: string): never { throw new Error(mesaj); } 4. Fonksiyon Tipleri // Fonksiyon tipi tanımlama type MatematikIslemi = (a: number, b: number) =\u0026gt; number; // Fonksiyon tipi kullanma const toplama: MatematikIslemi = (a, b) =\u0026gt; a + b; const cikarma: MatematikIslemi = (a, b) =\u0026gt; a - b; Sonuç TypeScript\u0026rsquo;in fonksiyonlar için sunduğu tip sistemi, JavaScript geliştirmede çok değerli bir araçtır. Tip güvenliği sayesinde:\nHataları erken yakalarsınız Kodunuz daha okunabilir olur IDE desteği daha iyi çalışır Refactoring yapmak kolaylaşır Bu özelliklerin hepsi bir araya geldiğinde, daha güvenilir ve bakımı kolay uygulamalar geliştirmenize yardımcı olur.\n",
        "tags": ["typescript","javascript","fonksiyonlar"],
        "categories": ["TypeScript"],
        "lang": "tr"
    },{
        "title": "TypeScript'i Anlamak - Bölüm 1: Temeller",
        "permalink": "/blog/tr/typescript-serisi/typescripti-anlamak-bolum1/",
        "summary": "TypeScript, JavaScript\u0026rsquo;e statik tip desteği ekleyen güçlü bir üst kümedir. Bu makale serisinde, TypeScript\u0026rsquo;i temellerden ileri seviyeye kadar keşfedeceğiz ve temel tipler ve tip çıkarımı ile başlayacağız.",
        "content": "Merhaba! Yakın zamanda TypeScript\u0026rsquo;i derinlemesine öğrenmeye başlayan bir geliştirici olarak, bu öğrenme yolculuğumu sizlerle paylaşmak istiyorum. Bu seride, TypeScript\u0026rsquo;i en temelinden başlayarak inceleyeceğiz, neden var olduğunu ve JavaScript geliştirme deneyimimizi nasıl daha iyi hale getirebileceğini anlayacağız.\nTypeScript Nedir? TypeScript, en basit tanımıyla tip desteği eklenmiş JavaScript\u0026rsquo;tir. Ancak bu tanım, TypeScript\u0026rsquo;in tüm özelliklerini karşılamıyor. Microsoft tarafından geliştirilen TypeScript, JavaScript\u0026rsquo;e statik tip desteği ekleyen bir üst kümedir (superset). Bu, tüm geçerli JavaScript kodunun aynı zamanda geçerli TypeScript kodu olduğu, ancak TypeScript\u0026rsquo;in daha sağlam ve sürdürülebilir kod yazmamıza yardımcı olan ek özellikler sunduğu anlamına gelir.\nTypeScript\u0026rsquo;in JavaScript\u0026rsquo;ten nasıl farklılaştığına dair basit bir örnek:\n// JavaScript let greeting = \u0026#34;Hello\u0026#34;; greeting = 42; // JavaScript\u0026#39;te çalışır, ancak sorunlara yol açabilir // TypeScript let greeting: string = \u0026#34;Hello\u0026#34;; greeting = 42; // Hata: \u0026#39;number\u0026#39; tipi \u0026#39;string\u0026#39; tipine atanamaz Neden Tipler? TypeScript\u0026rsquo;in tip sistemi birkaç önemli avantaj sağlar:\nHataları bulmamıza yardımcı olur: Tip sistemi, kodumuz çalışmadan önce hataları yakalayabilir Kodumuzu yazarken analiz eder: Editörümüzde gerçek zamanlı geri bildirim sağlar Sadece geliştirme aşamasında vardır: Tipler, kod JavaScript\u0026rsquo;e derlendiğinde kaldırılır Bu özellikler, TypeScript\u0026rsquo;i özellikle büyük kod tabanları ve takım çalışmaları için değerli kılar.\nTypeScript\u0026rsquo;te Temel Tipler Şimdi TypeScript\u0026rsquo;teki temel tipleri inceleyelim:\n1. String (Metin) String\u0026rsquo;ler TypeScript\u0026rsquo;te metin değerlerini temsil eder. İşte nasıl kullanıldıklarına dair bir örnek:\n// String değişkeni tanımlama let myString: string = \u0026#34;Merhaba!!!\u0026#34;; // Farklı bir tipe ATANMAZ myString = 100; // Hata // Aynı tipte bir değere ATANABİLİR myString = \u0026#34;Yeni metin!!!\u0026#34;; // Çalışır Bu örnekte, myString\u0026lsquo;i bir string olarak tanımladıktan sonra, TypeScript sadece string değerler atayabilmemizi sağlar.\n2. Number (Sayı) TypeScript, diğer dillere göre sayı yönetimini basitleştirir:\n// Sayı değişkeni tanımlama let myNumber: number = 42; // Farklı bir tipe ATANMAZ myNumber = \u0026#34;Ben bir string\u0026#39;im!\u0026#34;; // Hata // Aynı tipte bir değere ATANABİLİR myNumber = 60; // Çalışır Bazı programlama dillerinin aksine (float, int vb. gibi birden çok sayı tipi olan), TypeScript (JavaScript gibi) tüm sayısal değerler için sadece number tipini kullanır.\n3. Boolean (Mantıksal) Boolean değerler doğru/yanlış durumlarını temsil eder:\n// Boolean değişkeni tanımlama const myBoolean: boolean = true; // Farklı bir tipe ATANMAZ myBoolean = 87; // Hata // Aynı tipte bir değere ATANABİLİR myBoolean = false; // Çalışır Tip Çıkarımı (Type Inference) TypeScript\u0026rsquo;in en güçlü özelliklerinden biri, tipleri otomatik olarak çıkarabilme yeteneğidir. Bu, her zaman tipleri açıkça belirtmemiz gerekmediği anlamına gelir:\n// Bir değişkeni tip belirtmeden değer ile tanımlama let x = 27; x = \u0026#39;Yirmi yedi\u0026#39;; // Hata - \u0026#39;string\u0026#39; tipi \u0026#39;number\u0026#39; tipine atanamaz Bu örnekte TypeScript, x değişkeninin tipini ilk değerine bakarak otomatik olarak number olarak belirler. Bu özellik, tip güvenliğini korurken daha az kod yazmamızı sağlar.\n\u0026lsquo;any\u0026rsquo; Tipi Bazen katı tip kontrolünden daha fazla esnekliğe ihtiyaç duyarız. İşte bu noktada any tipi devreye girer:\n// \u0026#39;any\u0026#39; tipi ile değişken tanımlama const myComplicatedData: any = \u0026#34;Karmaşık olacağım!\u0026#34;; // Herhangi bir tipe ATANABİLİR - tip kontrolleri kapalı! myComplicatedData = 87; // Çalışır myComplicatedData = \u0026#39;abc...\u0026#39;; // Çalışır myComplicatedData = true; // Çalışır \u0026lsquo;any\u0026rsquo; Ne Zaman Kullanılmalı? Her ne kadar any kullanımından genellikle kaçınmamız gerekse de, meşru kullanım durumları vardır. İşte gerçek bir senaryo:\n// Harici API verisiyle çalışırken function handleAPIResponse(response: any) { // API yanıtının tam yapısını bilmeyebiliriz // özellikle üçüncü taraf API\u0026#39;lerle çalışırken console.log(response.data); // Çalışır console.log(response.status); // Çalışır console.log(response.someField); // Çalışır } // Eski JavaScript koduyla çalışırken declare const oldJavaScriptLibrary: any; // Kütüphaneyi TypeScript hataları olmadan kullanabiliriz oldJavaScriptLibrary.someOldMethod(); any tipinin gerekli olabileceği yaygın senaryolar:\nYanıt yapısının bilinmediği veya dinamik olduğu harici API\u0026rsquo;lerle entegrasyon sırasında JavaScript\u0026rsquo;ten TypeScript\u0026rsquo;e geçiş sürecinde (geçici kullanım) TypeScript tip tanımlamaları olmayan üçüncü taraf kütüphanelerle çalışırken Tipin tahmin edilemeyeceği gerçekten dinamik içeriklerle uğraşırken Ancak unutmayın ki any kullanmak, TypeScript\u0026rsquo;in tip kontrolü avantajlarını ortadan kaldırır. Son çare olarak kullanılmalı ve mümkün olduğunda uygun tipler tanımlanmalıdır.\nPratik Örnek Öğrendiklerimizi birleştiren pratik bir örneğe bakalım:\n// Farklı tiplerle değişkenler oluşturma let kullaniciAdi: string = \u0026#34;Ahmet Yılmaz\u0026#34;; let yas: number = 30; let girisYapildi: boolean = true; // Tip çıkarımı kullanma let sonGirisTarihi = new Date(); // TypeScript Date tipini çıkarır let girisAdedi = 5; // TypeScript number tipini çıkarır // Bu değişkenlerle çalışma function kullaniciBilgileriniGoster() { console.log(`Kullanıcı: ${kullaniciAdi}`); console.log(`Yaş: ${yas}`); console.log(`Giriş Yapıldı: ${girisYapildi}`); console.log(`Son Giriş: ${sonGirisTarihi}`); console.log(`Giriş Sayısı: ${girisAdedi}`); } // TypeScript bu hataları yakalar: kullaniciAdi = 123; // Hata: \u0026#39;number\u0026#39; tipi \u0026#39;string\u0026#39; tipine atanamaz yas = \u0026#34;otuz\u0026#34;; // Hata: \u0026#39;string\u0026#39; tipi \u0026#39;number\u0026#39; tipine atanamaz girisYapildi = \u0026#34;evet\u0026#34;; // Hata: \u0026#39;string\u0026#39; tipi \u0026#39;boolean\u0026#39; tipine atanamaz Bu örnek, TypeScript\u0026rsquo;in gerçek bir uygulama senaryosunda tip güvenliğini nasıl sağladığını ve yaygın tip hatalarını daha oluşmadan nasıl engellediğini gösteriyor.\nBest Practices (En İyi Uygulamalar) Mümkün Olduğunda Tip Çıkarımını Kullanın\nTypeScript tipi doğru çıkarabiliyorsa, tip açıklamaları eklemeyin Bu, kodunuzu daha temiz ve bakımı daha kolay hale getirir \u0026lsquo;any\u0026rsquo; Kullanımından Kaçının\nany kullanmak, TypeScript\u0026rsquo;in tüm avantajlarını ortadan kaldırır Sadece gerçekten gerektiğinde kullanın Gerektiğinde Açık Olun\nTypeScript\u0026rsquo;in çıkarımı yeterli olmadığında tip açıklamaları ekleyin Bu, kod okunabilirliğini artırır ve hataları yakalamaya yardımcı olur Sonuç Bu TypeScript\u0026rsquo;e giriş, tipler ve tip çıkarımının temellerini kapsıyor. TypeScript, JavaScript\u0026rsquo;e güçlü bir tip sistemi ekleyerek daha güvenilir kod yazmamıza yardımcı olur. Başlangıçta ekstra iş gibi görünse de, projeleriniz büyüdükçe ve karmaşıklaştıkça faydaları net bir şekilde ortaya çıkar.\nSerinin 2. bölümünde daha ileri TypeScript konularını inceleyeceğiz. Takipte kalın!\n",
        "tags": ["typescript","javascript"],
        "categories": ["TypeScript"],
        "lang": "tr"
    },{
        "title": "Linux Temel Komutları - Bölüm 1",
        "permalink": "/blog/tr/linux/linux-temel-komutlar%C4%B1/",
        "summary": "Bu makale serisinde, her geliştiricinin bilmesi gereken en sık kullanılan Linux komutlarını inceleyeceğiz. İlk bölümde, Linux sisteminizi etkili bir şekilde yönetmenize yardımcı olacak 20 temel komutu ele alacağız.",
        "content": "Herkese merhaba! Bu makale serisinde, her geliştiricinin bilmesi gereken en sık kullanılan Linux komutlarını açıklayacağım. Bu komutlar, Linux sisteminizi etkili bir şekilde yönetmek ve terminaldeki verimliliğinizi artırmak için gereklidir.\nNeden Linux Komutlarını Öğrenmeliyiz? Linux komutları, terminal aracılığıyla işletim sistemimizle etkileşim kurmamızı sağlayan temel araçlardır. Bu komutları anlamak önemlidir çünkü:\nSistem üzerinde daha fazla kontrol sağlarlar Genellikle grafiksel arayüz kullanmaktan daha hızlıdırlar Birçok sunucu Linux üzerinde çalışır ve grafiksel arayüzleri yoktur Otomasyon ve betik yazımı için gereklidirler DevOps ve sistem yönetiminde yaygın olarak kullanılırlar En Çok Kullanılan Linux Komutları En sık kullanılan 20 Linux komutunu inceleyelim:\nls (Listele) Mevcut dizindeki dosya ve klasörleri listeler Sık kullanılan seçenekler: ls -l: Uzun format listeleme ls -a: Gizli dosyaları göster ls -h: İnsan tarafından okunabilir dosya boyutları user@linux:~$ ls -la total 32 drwxr-xr-x 2 user user 4096 Feb 8 10:00 . drwxr-xr-x 20 user user 4096 Feb 8 10:00 .. -rw-r--r-- 1 user user 220 Feb 8 10:00 .bash_profile -rw-r--r-- 1 user user 3526 Feb 8 10:00 .bashrc drwxr-xr-x 2 user user 4096 Feb 8 10:00 Documents cd (Dizin Değiştir) Bulunduğunuz dizini değiştirir Kullanım örnekleri: cd /path/to/directory: Belirli bir dizine git cd ..: Bir üst dizine git cd ~: Ana dizine git user@linux:~$ pwd /home/user user@linux:~$ cd Documents user@linux:~/Documents$ cd .. user@linux:~$ cd ~ pwd (Çalışma Dizinini Yazdır) Mevcut dizin yolunu gösterir Dosya sisteminde nerede olduğunuzu doğrulamak için kullanışlıdır user@linux:~$ pwd /home/user/Documents/projects mkdir (Dizin Oluştur) Yeni dizinler oluşturur Seçenekler: mkdir -p: Eğer yoksa üst dizinleri oluşturur user@linux:~$ mkdir -p projects/new-project user@linux:~$ ls -l projects/ total 4 drwxr-xr-x 2 user user 4096 Feb 8 10:00 new-project rm (Sil) Dosya ve dizinleri siler Önemli seçenekler: rm -r: Dizinleri özyinelemeli olarak sil rm -f: Onay istemeden zorla sil user@linux:~$ ls file1.txt file2.txt test_dir user@linux:~$ rm file1.txt user@linux:~$ rm -r test_dir user@linux:~$ ls file2.txt cp (Kopyala) Dosya ve dizinleri kopyalar Yaygın kullanım: cp file1 file2: file1\u0026rsquo;i file2\u0026rsquo;ye kopyala cp -r dir1 dir2: Dizini özyinelemeli olarak kopyala user@linux:~$ cp file1.txt backup.txt user@linux:~$ cp -r projects/ projects_backup/ user@linux:~$ ls backup.txt file1.txt projects projects_backup mv (Taşı) Dosya ve dizinleri taşır veya yeniden adlandırır Örnekler: mv old.txt new.txt: Dosyayı yeniden adlandır mv file /path/to/dir: Dosyayı dizine taşı user@linux:~$ ls old.txt documents/ user@linux:~$ mv old.txt new.txt user@linux:~$ mv new.txt documents/ user@linux:~$ ls documents/ new.txt cat (Birleştir) Dosya içeriğini görüntüler Ayrıca dosyaları birleştirmek için kullanılır user@linux:~$ cat file.txt Bu file.txt dosyasının içeriğidir user@linux:~$ cat file1.txt file2.txt \u0026gt; combined.txt user@linux:~$ cat combined.txt file1\u0026#39;den içerik file2\u0026#39;den içerik grep (Global Regular Expression Print) Dosyalarda kalıp arar Kullanışlı seçenekler: grep -i: Büyük/küçük harf duyarsız arama grep -r: Özyinelemeli arama user@linux:~$ grep -r \u0026#34;TODO\u0026#34; . ./src/app.js:// TODO: Hata yönetimi eklenecek ./docs/readme.md:TODO: Dokümantasyon güncellenecek user@linux:~$ grep -i \u0026#34;hata\u0026#34; log.txt Hata: Bağlantı başarısız hata: bağlanılamadı HATA: Sistem hatası chmod (İzinleri Değiştir) Dosya izinlerini değiştirir Format: chmod [seçenekler] mod dosya user@linux:~$ ls -l script.sh -rw-r--r-- 1 user user 256 Feb 8 10:00 script.sh user@linux:~$ chmod +x script.sh user@linux:~$ ls -l script.sh -rwxr-xr-x 1 user user 256 Feb 8 10:00 script.sh sudo (Süper Kullanıcı Olarak Yap) Komutları süper kullanıcı yetkileriyle çalıştırır Sistem yönetimi görevleri için önemlidir user@linux:~$ apt update E: Could not open lock file - open (13: Permission denied) user@linux:~$ sudo apt update [sudo] password for user: Reading package lists... Done Building dependency tree... Done top Çalışan işlemleri ve sistem kaynaklarını gösterir Etkileşimli işlem görüntüleyici user@linux:~$ top top - 10:00:00 up 2 days, 3:45, 1 user, load average: 0.52, 0.58, 0.59 Tasks: 180 total, 1 running, 179 sleeping, 0 stopped, 0 zombie %Cpu(s): 5.9 us, 3.1 sy, 0.0 ni, 90.6 id, 0.4 wa, 0.0 hi, 0.0 si MiB Mem : 7861.1 total, 2457.2 free, 3245.5 used, 2158.4 buff/cache ps (İşlem Durumu) Çalışan işlemleri görüntüler Yaygın seçenekler: ps aux: Tüm işlemleri göster user@linux:~$ ps aux USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND user 2345 0.0 0.1 169512 3252 pts/0 Ss 09:30 0:00 bash user 2789 0.0 0.2 170284 6432 pts/0 R+ 10:00 0:00 ps aux df (Disk Boş Alan) Disk alanı kullanımını gösterir Kullanışlı seçenekler: df -h: İnsan tarafından okunabilir boyutlar user@linux:~$ df -h Filesystem Size Used Avail Use% Mounted on /dev/sda1 234G 67G 156G 31% / tmpfs 3.9G 0 3.9G 0% /tmp /dev/sda2 100G 45G 55G 45% /home du (Disk Kullanımı) Dizin alan kullanımını gösterir Yaygın kullanım: du -sh *: Mevcut dizin içeriğinin boyutu user@linux:~$ du -sh * 156M Documents 1.2G Downloads 42M Pictures 890M projects tar Dosya ve dizinleri arşivler Yaygın işlemler: tar -czf: Arşiv oluştur tar -xzf: Arşivi çıkart user@linux:~$ tar -czf archive.tar.gz Documents/ user@linux:~$ ls -lh archive.tar.gz -rw-r--r-- 1 user user 145M Feb 8 10:00 archive.tar.gz user@linux:~$ tar -xzf archive.tar.gz find Dizin hiyerarşisinde dosya arar Örnekler: find . -name \u0026quot;*.txt\u0026quot;: Tüm .txt dosyalarını bul user@linux:~$ find . -name \u0026#34;*.txt\u0026#34; ./documents/notes.txt ./projects/readme.txt ./backup/old.txt user@linux:~$ find . -type d -name \u0026#34;test\u0026#34; ./projects/test ./src/test wget İnternetten dosya indirir Kullanışlı seçenekler: wget -c: Yarıda kalan indirmeye devam et user@linux:~$ wget https://example.com/file.zip --2025-02-08 10:00:00-- https://example.com/file.zip Resolving example.com... 93.184.216.34 Connecting to example.com... connected. HTTP request sent, awaiting response... 200 OK Length: 52890112 (50M) [application/zip] Saving to: \u0026#39;file.zip\u0026#39; systemctl Systemd sistem ve servis yöneticisini kontrol eder Yaygın kullanımlar: systemctl start/stop/restart/status service user@linux:~$ sudo systemctl status nginx ● nginx.service - Yüksek performanslı web sunucusu ve ters proxy sunucusu Loaded: loaded (/lib/systemd/system/nginx.service; enabled; vendor preset: enabled) Active: active (running) since Thu 2025-02-08 09:30:12 UTC; 30min ago history Komut geçmişini gösterir Kullanışlı özellikler: !n: n numaralı komutu çalıştır !!: Son komutu çalıştır user@linux:~$ history 1 pwd 2 cd Documents 3 ls -la 4 mkdir projects 5 cd projects user@linux:~$ !3 ls -la total 32 drwxr-xr-x 2 user user 4096 Feb 8 10:00 . drwxr-xr-x 5 user user 4096 Feb 8 10:00 .. En İyi Uygulamalar Her Zaman Tab Tamamlama Kullanın\nZaman kazandırır ve yazım hatalarını önler Mevcut seçenekleri gösterir Komutları Çalıştırmadan Önce Kontrol Edin\n--help veya man komutunu kullanın rm ve sudo ile ekstra dikkatli olun Komut Geçmişini Kullanın\nÖnceki komutlara göz atmak için yukarı ok tuşuna basın Geriye dönük arama için Ctrl+R kullanın Takma Adlar Oluşturun\nSık kullanılan komutları takma ad olarak kaydedin Bunları .bashrc veya .zshrc dosyanıza ekleyin Sonuç Bu 20 komut, Linux komut satırı kullanımının temelini oluşturur. Bunları anlamak ve ustalaşmak, Linux sistemleriyle çalışırken verimliliğinizi önemli ölçüde artıracaktır. Bu serinin bir sonraki bölümünde, sistem yönetimi ve otomasyon için daha gelişmiş komutları ve teknikleri inceleyeceğiz.\nBu komutlarda ustalaşmanın anahtarının pratik yapmak olduğunu unutmayın. Günlük çalışmalarınızda bunları düzenli olarak kullanmaya çalışın ve güvenli bir ortamda denemekten çekinmeyin.\nDaha gelişmiş Linux komutlarını ele alacağımız 2. Bölüm için takipte kalın!\n",
        "tags": ["linux","komutlar"],
        "categories": ["Linux"],
        "lang": "tr"
    },{
        "title": "Fastify ile RESTful API Oluşturma",
        "permalink": "/blog/tr/fastify-ile-rest-api-olusturma/",
        "summary": "Fastify, Node.js için yüksek performans ve düşük kaynak tüketimi sağlamaya odaklanan modern bir web framework\u0026rsquo;tür. Bu yazıda Fastify\u0026rsquo;ın ne olduğunu, nasıl kullanıldığını ve en iyi uygulama önerilerini detaylı olarak anlatacağım.",
        "content": "Herkese merhabalar! Bu yazımda sizlere Node.js için hızlı ve düşük kaynak tüketen bir web framework olan Fastify\u0026rsquo;ı anlatacağım. Birlikte basit bir TODO API\u0026rsquo;si oluşturacağız ve Fastify\u0026rsquo;ın özelliklerinin geliştirme sürecinizi nasıl daha verimli hale getirebileceğini açıklayacağım.\nBu projenin tüm kaynak koduna GitHub üzerinden ulaşabilirsiniz: fastify-nodejs-restful-api\nFastify Nedir ve Neden Kullanmalıyız? Fastify, Node.js için geliştirilmiş, yüksek performansa ve düşük kaynak kullanımına odaklanan modern bir web framework\u0026rsquo;tür. Node.js geliştiricilerinin çoğu Express.js\u0026rsquo;e aşina olsa da, Fastify bazı önemli avantajlar sunuyor:\nExpress\u0026rsquo;e göre 2 kata kadar daha hızlı Dahili şema doğrulama sistemi Otomatik Swagger dokümantasyonu Plugin tabanlı mimari Projemizi Oluşturalım Öncelikle projemizi kuralım. İlk olarak bazı bağımlılıkları yüklememiz gerekiyor. Yeni bir dizin oluşturun ve şu komutları çalıştırın:\nmkdir fastify-todo-api cd fastify-todo-api npm init -y Şimdi ihtiyacımız olan paketleri yükleyelim:\n{ \u0026#34;dependencies\u0026#34;: { \u0026#34;fastify\u0026#34;: \u0026#34;^3.29.0\u0026#34;, \u0026#34;fastify-swagger\u0026#34;: \u0026#34;^5.2.0\u0026#34;, \u0026#34;uuid\u0026#34;: \u0026#34;^8.3.2\u0026#34; }, \u0026#34;devDependencies\u0026#34;: { \u0026#34;nodemon\u0026#34;: \u0026#34;^2.0.16\u0026#34; } } Proje Yapısı Kodlamaya başlamadan önce proje yapımızı düzenleyelim. Temiz ve bakımı kolay bir yaklaşım izleyeceğiz:\nfastify-todo-api/ ├── app.js # Ana sunucu dosyası ├── items.js # Veri deposu ├── routes/ │ └── todoRouter.js # Route tanımlamaları └── controllers/ └── todoController.js # İstek işleyicileri İlk Fastify Sunucumuzu Oluşturalım Ana sunucu dosyamızla (app.js) başlayalım. İşte temel bir Fastify sunucusunu nasıl kurarız:\nconst fastify = require(\u0026#39;fastify\u0026#39;)({ logger: true }); // Swagger dokümantasyonunu ayarlıyoruz fastify.register(require(\u0026#39;fastify-swagger\u0026#39;), { exposeRoute: true, routePrefix: \u0026#39;/docs\u0026#39;, swagger: { info: { title: \u0026#39;fastify-api\u0026#39; }, }, }); // Route\u0026#39;larımızı kaydediyoruz fastify.register(require(\u0026#39;./routes/todoRouter\u0026#39;)); const PORT = 5000; const start = async () =\u0026gt; { try { await fastify.listen(PORT); } catch (error) { fastify.log.error(error); process.exit(1); } }; start(); Bu kodda neler oluyor?\nLoglama özelliği etkin bir Fastify örneği oluşturuyoruz Swagger dokümantasyonunu ayarlıyoruz (/docs adresinden erişilebilir) Route\u0026rsquo;larımızı Fastify\u0026rsquo;ın plugin sistemi ile kaydediyoruz Sunucuyu 5000 portunda başlatıyoruz Fastify\u0026rsquo;ın Şema Doğrulama Sistemini Anlayalım Fastify\u0026rsquo;ın en güçlü özelliklerinden biri şema doğrulama sistemidir. todoRouter.js dosyasında nasıl kullanacağımıza bakalım:\n// Önce bir TODO öğesinin nasıl görüneceğini tanımlıyoruz const Item = { type: \u0026#39;object\u0026#39;, properties: { id: { type: \u0026#39;string\u0026#39; }, name: { type: \u0026#39;string\u0026#39; }, }, }; // Sonra endpoint\u0026#39;lerimiz için şemalar oluşturuyoruz const getItemsOpts = { schema: { response: { 200: { type: \u0026#39;array\u0026#39;, items: Item, }, }, }, handler: getItems, }; Bu neden özel?\nFastify otomatik olarak tüm gelen ve giden verileri doğrular Bu şemalardan Swagger dokümantasyonu oluşturur Serileştirmeyi optimize ederek performansı artırır Hataları handler\u0026rsquo;lara ulaşmadan yakalar Controller\u0026rsquo;larımızı Oluşturalım Şimdi todoController.js dosyasında istekleri nasıl işleyeceğimize bakalım:\nlet items = require(\u0026#39;../items\u0026#39;); const { v4: uuidv4 } = require(\u0026#39;uuid\u0026#39;); // Tüm öğeleri getir const getItems = (req, reply) =\u0026gt; { reply.send(items); }; // Yeni öğe oluştur const addItem = (req, reply) =\u0026gt; { const { name } = req.body; const item = { id: uuidv4(), name, }; items = [...items, item]; reply.code(201).send(item); }; Fastify\u0026rsquo;ın yanıt işlemeyi nasıl kolaylaştırdığına dikkat edin:\nContent-Type başlıklarını manuel ayarlamaya gerek yok Durum kodları ve yanıt gönderme için method chaining Otomatik yanıt serileştirme API\u0026rsquo;mizi Test Edelim Her şeyi ayarladığımıza göre, API\u0026rsquo;mizi test edelim. curl veya herhangi bir API test aracı kullanabilirsiniz:\n# Tüm öğeleri al curl http://localhost:5000/items # Yeni öğe oluştur curl -X POST \\ http://localhost:5000/items \\ -H \u0026#39;Content-Type: application/json\u0026#39; \\ -d \u0026#39;{\u0026#34;name\u0026#34;:\u0026#34;Fastify Öğren\u0026#34;}\u0026#39; Bilmeniz Gereken Performans Özellikleri Fastify tesadüfen hızlı değil. İşte neden bu kadar iyi performans gösteriyor:\nŞema Tabanlı Serileştirme\nDaha hızlı doğrulama için şemaları önceden derler JSON serileştirmeyi optimize eder İşlem yükünü azaltır Verimli Yönlendirme\nRoute eşleştirme için radix tree kullanır Regex tabanlı yönlendirmeden daha hızlıdır Optimize edilmiş parametre işleme Hafif Çekirdek\nMinimum temel yük Özellik eklemek için plugin sistemi Verimli bellek kullanımı Önerdiğim En İyi Uygulamalar Fastify ile çalıştıktan sonra, işime yarayan bazı pratikler:\nHer Zaman Şema Kullanın\nfastify.get(\u0026#39;/items\u0026#39;, { schema: { response: { 200: itemSchema } } }) Plugin\u0026rsquo;lerle Organize Edin\nfastify.register(require(\u0026#39;./routes/items\u0026#39;)) fastify.register(require(\u0026#39;./routes/users\u0026#39;)) Hataları Düzgün Yönetin\nfastify.setErrorHandler(function (error, request, reply) { reply.status(error.statusCode || 500).send({error: error.message}) }) Sonuç Fastify, yüksek performanslı Node.js API\u0026rsquo;leri oluşturmak için mükemmel bir temel sağlıyor. Şema doğrulama ve swagger dokümantasyonu gibi dahili özellikleri, onu modern web uygulamaları için harika bir seçim haline getiriyor. Gelecek yazılarımda, daha gelişmiş Fastify özelliklerini ve bunları production ortamında nasıl etkili bir şekilde kullanabileceğimizi anlatacağım. Okuduğunuz için teşekkürler!\nTüm bu özellikler hakkında daha detaylı bilgi için Fastify dokümantasyonunu incelemeyi unutmayın.\n",
        "tags": ["nodejs","fastify"],
        "categories": ["Node.js"],
        "lang": "tr"
    },{
        "title": "Git Flow Nedir?",
        "permalink": "/blog/tr/git-flow/",
        "summary": "Git Flow, versiyon kontrol sistemlerinde dal yönetimini sistematikleştiren etkili bir yaklaşımdır. Bu makalede Git Flow\u0026rsquo;un ne olduğunu, nasıl kullanıldığını ve en iyi uygulama önerilerini detaylı olarak açıklayacağım.",
        "content": "\nMerhaba. Bu makalede versiyon kontrol sistemlerinden kısaca bahsedip, Git Flow\u0026rsquo;un ne olduğunu ve nasıl kullanıldığını detaylı olarak anlatacağım. Versiyon kontrol sistemleri, yazılım geliştirme süreçlerinde kod versiyonlarını takip etmek ve yönetmek için kullanılan önemli araçlardır. Git Flow ise bu versiyon kontrol sistemini daha etkili kullanmamızı sağlayan bir dallanma modelidir.\nVersiyon Kontrol Sistemi Nedir? Versiyon kontrol sistemi, bir veya daha fazla dosya, belge (yazılım projesi, ofis belgeleri vb.) üzerinde yaptığımız değişiklikleri adım adım kaydeden, daha sonra belirli bir versiyona geri dönmemizi sağlayan ve istenirse bunu çevrimiçi bir depoda saklayıp yönetmemize olanak tanıyan bir sistemdir. Git, SVN, BitKeeper ve Mercurial versiyon kontrol sistemlerine örnek olarak verilebilir.\nNeden Versiyon Kontrol Sistemleri Kullanırız? Her dosya için uzun vadeli bir değişiklik geçmişi tutulur.\nBu, dosya üzerinde yıllar içinde birden fazla kişi tarafından yapılan her değişikliğin takip edilmesi anlamına gelir. Bu sayede eski ve yeni kodumuzu karşılaştırarak bulunduğumuz noktaya nasıl geldiğimizi anlayabiliriz. Takım üyelerinin aynı kod üzerinde eş zamanlı çalışmasına olanak tanır.\nYazılım üzerinde farklı çalışmalar yürütmek için alt versiyonlar oluşturmak ve daha sonra ana yazılıma entegre etmek mümkündür. Yazılıma yapılan her değişikliğin takip edilmesini ve proje yönetimiyle ilişkilendirilmesini sağlar.\nYazılım sorunlarının versiyonlarla ilişkilendirilmesini ve takibini sağlar. Projede hatalarla karşılaştığımızda eski kod kayıtlarına dönmemizi sağlar.\nVersiyon Kontrol Sistemleri Yerel VKS: En eski versiyon kontrol sistemi yaklaşımıdır. Projemiz ve yaptığımız değişiklikler kullanıcı makinesindeki bir veritabanında saklanır. Her commit bir versiyon olarak saklanır ve her versiyon commit\u0026rsquo;e bir hash değeri atanarak ayırt edilir. Ayrıca versiyon görüntüleme özelliği sunar. Ancak bu sistemde sadece bir kullanıcı etkin olarak çalışabilir.\nMerkezi VKS: Birden fazla kişinin bir proje üzerinde etkin çalışabilmesi için oluşturulmuş bir versiyonlama sistemidir. CVS ve SVN merkezi versiyon kontrol sistemleridir. Bu sistemde proje paylaşılan bir depoda tutulur ve birden fazla geliştirici aynı depo üzerinde checkout ve commit işlemleri gerçekleştirir. Bu yöntem herkesin projeye katkıda bulunmasına olanak sağlarken, bazı ciddi sorunları vardır. Tek merkezi sunucu 1 saat çökerse, kullanıcılar o bir saat boyunca çalışmalarını kaydedemez veya projelerinin versiyonlanmış kopyalarına erişemezler.\nDağıtık VKS: Merkezi versiyon sistemlerinin, geliştiricilerin çevrimdışı çalışamaması ve deponun zarar görmesi durumunda kurtarmanın zor olması gibi kısıtlamalarından dolayı oluşturulmuş bir versiyon sistemidir. Git, Mercurial ve BitKeeper dağıtık versiyon sistemlerine örnektir. Bu sistemlerde merkezi bir depo yoktur ve proje üzerinde çalışan her makine projenin bir kopyasını kendi yerel bilgisayarında tutar. Geliştiriciler proje üzerinde değişiklik yapmak veya proje geçmişini görüntülemek istediklerinde uzak depo ile iletişim kurmaları gerekmez. Bir sunucu çökerse ve o sunucu üzerinde işbirliği yapan sistemler varsa, geliştiricilerden birinin projeyi sunucuya geri yüklemesiyle sistem kurtarılabilir. Özetle, aynı proje üzerinde farklı geliştiricilerin farklı iş akışlarıyla farklı şekillerde çalışmasına olanak tanır.\nGit Flow Nedir? 5 Ocak 2020\u0026rsquo;de nvie, https://nvie.com/posts/a-successful-git-branching-model/ adresindeki bir yazıda git depolarını düzenli tutmak için bir model önerdi. Daha sonra bu modeli kullanmayı kolaylaştıran git uzantılarını içeren Git-Flow adlı bir proje yayınladı. GitFlow modeli temelde git versiyon kontrol sistemi üzerine kurulmuştur. Yani tüm model işlemlerini git komutlarıyla gerçekleştirmek mümkündür.\nGit Flow\u0026rsquo;un Avantajları ve Dezavantajları Avantajları:\nOrganize ve öngörülebilir bir geliştirme süreci sağlar Büyük takımlar için ideal bir yapı sunar Versiyon yönetimini basitleştirir Her dalın net bir amacı vardır Paralel geliştirmeyi destekler Dezavantajları:\nKüçük projeler için fazla karmaşık olabilir Sürekli teslimat için uygun olmayabilir Dal yapısı bazen gereksiz karmaşıklığa yol açabilir Ek araç kurulumu gerektirir Öğrenme eğrisi diğer modellere göre daha yüksektir Git Flow Alternatifleri GitHub Flow: Daha basit bir model, sadece master ve feature dallarını kullanır GitLab Flow: Git Flow ve GitHub Flow arasında denge kurar Trunk Based Development: Ana dal üzerinde geliştirmeye odaklanır Git Flow Çalışma Prensibi Git Flow modelinde 5 ana dal bulunur:\nmaster: Ana dallardan biri olan Master, proje boyunca var olur. Master dalı her zaman üretime çıkabilecek kodu içerir. İdeal olarak master dalına yapılan her commit bir versiyondur ve \u0026ldquo;git tag\u0026rdquo; ile işaretlenmelidir (versiyon numarası verilmelidir). Master dalına direkt commit yapılmaz, sadece hotfix ve release dallarından merge yapılmasına izin verilir.\ndevelop: Develop, proje boyunca var olan diğer ana daldır. Develop dalı bir sonraki versiyon için yapılan değişiklikleri içerir. Tüm feature dalları önce bu dala merge edilir. Bu dal projenin ana geliştirme dalıdır ve sürekli entegrasyon (CI) süreçleri genellikle bu dal üzerinde çalışır.\nhotfix: Hotfix dalı, canlıdaki versiyonda kritik bir hata olduğunda ve bu hatanın hemen düzeltilip deploy edilmesi gerektiğinde kullanılır. Hotfix dalı master dalından oluşturulur ve genellikle \u0026lsquo;hotfix/[versiyon]-[açıklama]\u0026rsquo; formatında isimlendirilir. Hotfix dalında hata düzeltmesi tamamlandığında bu dal hem Developer hem de Master ile merge edilir. Master ile merge edildikten sonra değişiklik yeni bir versiyon numarası ile etiketlenir.\nfeature: Yeni bir özellik eklenirken, bu özellik için bir Feature dalı oluşturulur. Feature dalları her zaman develop dalından oluşturulur ve genellikle \u0026lsquo;feature/[özellik-adı]\u0026rsquo; formatında isimlendirilir. Bunlar özelliklere göre değişiklikler olarak düşünülebilir. Aynı anda birden fazla feature dalı açılabilir. Bu farklı geliştiricilerin farklı özellikler üzerinde çalışabileceği anlamına gelir. Özellikleri ayrı dallarda geliştirmek hem Develop dalının gereksiz commitlerle dolmasını engeller hem de feature dalını silmek suretiyle bir özellikten vazgeçmeyi kolaylaştırır. Özellik tamamlandığında bu dal Develop dalı ile merge edilir ve feature dalı silinir. Yani feature dalları sadece geliştirme süresince yaşar. Tabi bu süreçte kontrol amaçlı arada bir Develop dalından pull almak gerekebilir çünkü başka bir geliştirici feature dalını önce bitirmiş ve Develop dalına version push edilmiş olabilir. Feature dalları master, release, develop veya hotfix içeren isimler içermemelidir.\nrelease: Diyelim ki tüm değişiklikler tamamlandı. Yeni bir versiyon çıkılacağı zaman Develop dalından yeni bir Release dalı oluşturulur. Release dalları genellikle \u0026lsquo;release/[versiyon]\u0026rsquo; formatında isimlendirilir. Versiyondaki son değişiklikler, versiyon numaralarının değiştirilmesi vb. işlemler bu dalda yapılır. Release dalında sadece hata düzeltmeleri yapılmalı, yeni özellikler eklenmemelidir. Gerekli tüm değişiklikler tamamlandığında Release dalında tamamlanan tüm değişiklikler hem Master hem de Develop dallarına merge edilir. Master dalında git tag ile versiyon numarası etiketlenir ve ardından Release dalı silinir.\nGit Flow Örnek Proje /brew install git-flow \u0026gt; git flow init İlk olarak \u0026ldquo;brew install git-flow\u0026rdquo; ile kurulum yapıyoruz. GitFlow git ile birlikte gelmiyor. Ayrıca kurulması gerekiyor. Bu da dezavantajlarından biri olarak görülüyor. Git\u0026rsquo;te projeyi başlatmak için \u0026ldquo;git init\u0026rdquo; komutunu kullanıyorduk. Git-flow için git-flow sürecini başlatmak için \u0026ldquo;git flow init\u0026rdquo; komutunu giriyoruz. Komut çalıştığında eğer repo yoksa önce repo oluşturuyor. Ardından süreç için kullanılacak dal isimlerini kullanıcıya soruyor. Dal isimleri özelleştirilebilir ancak varsayılan değerlerin korunması önerilir.\n/git flow feature start performance Bu komut yeni bir feature dalı oluşturur. Feature ismi performance olduğu için varsayılan olarak feature/performance dalı olacaktır. Aynı işlemi mevcut git komutu ile de yapabiliriz. Bunun için girmemiz gereken komut \u0026ldquo;git checkout -b myFeature feature/performance\u0026rdquo; olacaktır.\n/git flow feature finish performance Bu komut daha önce açılmış bir dalı kapatır. Kapatma işlemi feature dalının develop dalına merge edilmesiyle başlar ve feature dalının silinmesiyle sonlanır. Komut çalıştırıldığında değişiklikler commit edilmemişse hata verecektir. Commit sonrası push yapılmamışsa hata verecektir. Bu işlemi normal git komutlarıyla yapmak için ilgili dalda önce commit yapılır ardından sırasıyla \u0026ldquo;git checkout develop \u0026gt; git merge \u0026ndash;no-ff feature/performance \u0026gt; git branch -D feature/performance\u0026rdquo; komutları çalıştırılır.\n/git flow release start 1.0.0 Bu komut girildiğinde yeni bir versiyon çıkışa hazır hale gelir. Komut çalıştığında Develop dalından yeni bir release/1.0.0 dalı oluşturulur. Bu işlemi mevcut git komutu ile yapmak için \u0026ldquo;git checkout -b release/1.0.0 develop\u0026rdquo; komutu çalıştırılır.\n/git flow release finish 1.0.0 Komut girildiğinde tamamlanan versiyon master dalına alınır. Değişiklikler hem develop hem de master dalları ile merge edilir. Master dalındaki son commit versiyon numarası ile etiketlenir. Ardından release dalı otomatik olarak silinir. Aynı işlemi git komutları ile yapmak için sırasıyla aşağıdaki komutlar çalıştırılır:\ngit checkout master git merge --no-ff release/1.0.0 git tag -a 1.0.0 git checkout develop git merge --no-ff release/1.0.0 git branch -d release/1.0.0 /git flow hotfix start 1.0.1 Bu komut ile yeni bir hotfix başlatılır. Hotfix dalları acil güncellemeler için kullanılır ve master dalından oluşturulur. Komut çalıştığında master dalından dallanan yeni bir hotfix/1.0.1 dalı oluşturulur. İşlemi git komutu ile yapmak için \u0026ldquo;git checkout -b hotfix/1.0.1 master\u0026rdquo; komutu çalıştırılır.\n/git flow hotfix finish 1.0.1 Bu komut ile hotfix tamamlanır. Değişiklikler hem Develop hem de Master dallarına alınır. Master dalı 1.0.1 ile etiketlenir ve hotfix dalı silinir. \u0026ldquo;git tag -l\u0026rdquo; komutu çalıştırıldığında versiyon numaraları görüntülenir. Aynı işlemi mevcut git komutları ile yapmak için sırasıyla aşağıdaki komutlar çalıştırılır:\ngit checkout master git merge --no-ff hotfix/1.0.1 git tag -a 1.0.1 git checkout develop git merge --no-ff hotfix/1.0.1 git branch -d hotfix/1.0.1 Git Flow En İyi Uygulama Önerileri Dal İsimlendirme Kuralları\nFeature dalları için açıklayıcı isimler kullanın (örn. feature/kullanici-dogrulama) Hotfix ve release dalları için semantik versiyonlama kullanın Commit Mesajları\nAçıklayıcı commit mesajları yazın Conventional Commits standardını takip edin Her commit\u0026rsquo;in tek bir amacı olduğundan emin olun Kod İnceleme Süreci\nFeature dallarını merge etmeden önce kod incelemesi yapın Otomatik test süreçlerini kullanın Dokümantasyon güncellemelerini unutmayın Merge Stratejisi\n\u0026ndash;no-ff (no fast-forward) parametresini kullanın Merge çakışmalarını hızlıca çözün Squash commit\u0026rsquo;leri kullanmayı düşünün Sonuç Git Flow, modern yazılım geliştirme süreçlerinde dal yönetimini sistematikleştiren etkili bir yaklaşımdır. Bu iş akışı sayesinde takımlar daha organize çalışabilir, versiyonlamayı daha iyi kontrol edebilir ve kod kalitesini artırabilir. Özellikle büyük projelerde ve takım çalışmalarında, Git Flow\u0026rsquo;un sunduğu yapılandırılmış dal stratejisi geliştirme süreçlerini önemli ölçüde iyileştirir. Yukarıda bahsedilen en iyi uygulamaları takip ederek, Git Flow\u0026rsquo;u projenizde başarıyla uygulayabilir ve yazılım geliştirme süreçlerinizi daha verimli hale getirebilirsiniz.\n",
        "tags": ["git-flow","git"],
        "categories": ["Git"],
        "lang": "tr"
    },{
        "title": "Atomik Alışkanlıklar Kitap Özeti?",
        "permalink": "/blog/tr/atomik-aliskanliklar-kitap-ozeti/",
        "summary": "İlk olarak bir süredir okuduğum ve yeni bitirdiğim James Clear\u0026rsquo;a ait Atomik Alışkanlıklar kitabının özetini, kitabı okurken kendi çizdiğim taraflar ve izlediğim/okuduğum diğer kitap özetlerinden derlediğim notlarla\u0026hellip;",
        "content": "\nSelamlar. İlk kitap özeti yazıma hoşgeldiniz. Kitapları okuduktan sonra unutmaya başladığımı fark ettiğim için ve dönüp tekrar hatırlamak istediğimde bakabileceğim kendime ait bir kaynak olsun istediğim için böyle bir şey denemeye karar verdim. Umarım sizlere de faydası olur. İlk olarak bir süredir okuduğum ve yeni bitirdiğim James Clear\u0026rsquo;a ait Atomik Alışkanlıklar kitabının özetini, kitabı okurken kendi çizdiğim taraflar ve izlediğim/okuduğum diğer kitap özetlerinden derlediğim notlarla-alıntılarla ve büyük çoğunluğu kitaptan parçalarla yazacağım.\nGiriş Alışkanlık kelimesini, düzenli olarak ve pek çok örnekte otomatik bir şekilde gerçekleştirilen bir rutin ve davranıştır şeklinde tanımlıyor James Clear. Kendi yaşadığı bir kazadan ve küçük alışkanlıkların kendisini nasıl hayata tekrar bağladığından bahsettikten sonra ekliyor: \u0026ldquo;Başlangıçta küçük ve önemsiz görünen değişiklikler, sizin onlara yıllarca sadık kalmanız durumunda bir araya gelerek hatırı sayılır sonuçlar yaratıyor. Hepimiz engellerle karşılaşıyoruz ama uzun vadede hayatlarımızın kalitesi, alışkanlıklarımızın kalitesine bağlı oluyor. Aynı alışkanlıklarla sadece aynı sonuçları alabilirsiniz ancak daha iyi alışkanlıklarla her şey mümkün.\u0026rdquo;\nKendi deneyimleri ve sonrasında ise faydalandığı biyoloji, felsefe, nörobilim, psikoloji ve diğer dalların katkısı ile yazdığı bu kitabında, adına Davranış Değişikliğinin Dört Yasası dediği dört adımdan oluşan bu omurga ile nasıl iyi alışkanlıklar edinilebileceğinden ve kötü alışkanlıklardan ise nasıl kurtulunabileceğini anlatıyor.\nAtomik Alışkanlıkların Şaşırtıcı Gücü Dört yasaya geçmeden önce alışkanlıkların gücünden örneklerle bahsediyor. En can alıcı örneklerden biri ise İngiltere Bisiklet Takımı ile ilgili olan. Yaklaşık 100 yıldır olimpiyatlarda kötü performans sergileyen ve bisiklet sporunun en büyük yarışı olan Fransa Bisiklet Turu\u0026rsquo;nu 110 yıldır kazanamayan Büyük Britanya Bisikletçiliği\u0026rsquo;nin (British Cycling) başına 2003 yılında British Cycling\u0026rsquo;i yeniden yola sokmak için göreve David Brailsford getirilmişti. Onu önceki koçlardan farklı kılan özelliği \u0026ldquo;marjinal faydaların bir araya toplanması\u0026rdquo; olarak adlandırdığı ve kısaca yaptığımız her şeyde minik bir iyileşme marjı arama felsefesi olan bir stratejliye amansızca bağlı olmasıydı. Brailsford bunu, \u0026ldquo;Bütün prensip, bisiklet sürmekle ilgili her şeyi küçük parçalara böler ve o parçaları %1 oranında iyileştirirseniz, hepsini bir araya topladığınızda hatırı sayılır bir düzelme sağlarsınız\u0026rdquo; düşüncesine dayanıyor demiştir.\nBrailsford ve ekibi; bisiklet selelerinin daha rahat olması için yeniden tasarlamak, daha iyi tutuş için lastiklere alkol sürmek, biniş sırasında sürücülerin ideal kas ısılarını korumak için binicilere elektrikle ısınan dış şortlar giydirmek vb. bir çok küçük iyileştirme yaptılar. Ekip gözden kaçan ve beklenmedik bir çok alanda %1\u0026rsquo;lik iyileştirmeler yapmaya devam ettiler. Bunlar ve diğer yüzlerce küçük iyileştirme birikirken sonuçlar da kimsenin beklemediği hızla gelmeye başladı. Brailsford\u0026rsquo;un başa geçmesinden sadece beş yıl sonra British Cycling takımı, Pekin\u0026rsquo;de düzenlenen 2008 Olimpiyatları\u0026rsquo;nda şaşırtıcı bir oranla altın madalyaların %60\u0026rsquo;ını kazandı. Dört yıl sonra ise Olimpiyatlar İngiltere\u0026rsquo;ye geldiğinde 9 Olimpiyat 7 dünya rekoru kırarak çıtayı daha da yükselttiler. Aynı yıl ise Bradley Wiggins, Fransa Bisiklet Turu\u0026rsquo;nu kazanan ilk İngiliz bisikletçi oldu. Ertesi yıl ise yarışı takım arkadaşı Chris Froome kazandı ve ertesi yıllarda kazanmaya devam ettiler. Bu örnekten yola çıkarak küçük alışkanlıklar neden büyük farklar yaratır konusuna değiniyor.\nKüçük Alışkanlıklar Neden Büyük Farklar Yaratır? Brailsford\u0026rsquo;un dediği gibi yüzde 1 oranında bir iyileşme doğrudan dikkat çekmese de - bazen hiç fark edilmez bile - özellikle uzun vadede çok daha anlamlıdır. Minik bir ilerlemenin zaman içinde yaratabileceği fark şaşırtıcıdır. Hesap şöyle işliyor, 1 yıl boyunca her gün yüzde 1\u0026rsquo;lik bir iyileşme kaydederseniz, yıl sonu geldiğinde 37 kat daha iyi olursunuz. Tam tersi şekilde 1 yıl boyunca her gün yüzde 1 kötü giderseniz neredeyse 0a kadar inersiniz. Küçük bir kazanç ya da önemsiz bir engel olarak başlayan şey sonunda birikerek çok daha fazlasına dönüşür. İyi alışkanlıkların değeri ve kötü alışkanlıkların maliyeti ancak iki, beş veya on yıl sonra geriye dönüp bakıldığında çarpıcı şekilde belirginleşir.\nÜç gün üst üste spor salonuna giderseniz bir anda forma girmezsiniz. Bu akşam bir saat İngilizce çalışsanız bu dili öğrenmiş olmazsınız. Bir kaç değişiklik yaparız ama sonuçlar hiçbir zaman çok çabuk gelmez ve böylece hızla önceki rutinlerimize döneriz. Ne yazık ki dönüşümün yavaş temposu ayrıca kötü bir alışkanlığın geri gelmesini de kolaylaştırır. Bugün sağlıksız bir öğün yerseniz tartının ibresi çok fazla oynamaz. Bu gece geç saate kadar çalışır ve ailenizi ihmal ederseniz sizi affederler. İşleri sonraya bırakır ve projenizi yarına ertelerseniz genellikle daha sonra tamamlayacak zamanınız olacaktır. Basit bir kararı kafadan uzaklaştırmak kolaydır. Ancak yüzde 1\u0026rsquo;lik hataları kötü kararları kopyalayarak küçük hataları çoğaltarak ve minik bahaneleri makul kılarak günden güne tekrarladığımız zaman küçük tercihlerimiz zehirli sonuçlara dönüşür. Sonunda soruna dönüşen birçok hatalı adımın şunda bunda yüzde 1\u0026rsquo;lik düşüşlerin birikimidir.\nÖnemli olan alışkanlarınızın sizi başarıya yönlendirip yönlendirmediğidir. Mevcut rotanıza, mevcut sonuçlarınızdan daha fazla kafa yormalısınız. Milyonerseniz ve her ay kazandığınızdan daha fazla para harcıyorsanız kötü yoldasınız demektir. Harcama alışkanlıklarınızı değiştirmezseniz bunun sonu iyi olmayacaktır. Tam tersine batak durumdaysanız ama her ay birazcık birikim yapıyorsanız, istediğinizden daha yavaş ilerliyor bile olsanız finansal özgürlük yolundasınız demektir.\nAmaçları Unutun Sistemlere Odaklanın Zaman içinde sonuçların belirlediği hedeflerden çok izlediği sistemlerle alakalı olduğunu fark etmeye başladığından bahsediyor yazar. Sistemler ile hedefler arasındaki fark nedir? Bu ayrımı ilk olarak Dilbert çizgi romanının yaratıcısı karikatürist Scott Adams\u0026rsquo;tan öğrendiğini söylüyor ve devam ediyor. Hedefler, ulaşmak istediğiniz sonuçlarla ilgilidir. Sistemler ise o sonuçlara giden süreçlerle. Daha iyi sonuçlar istiyorsanız hedef koymayı unutun. Onun yerine sisteminize odaklanın.\nSpor koçuysanız hedefiniz bir şampiyonluğu kazanmak olabilir. Sisteminiz ise oyuncu alma, yardımcı koçlarınızı yönetme ve antrenman yapma şeklinizdir. Girişimciyseniz hedefiniz bir milyon dolarlık bir iş kurmak olabilir. Sisteminiz ise ürün fikirlerini test etme, çalışanlarınızı işe alma ve pazarlama kampanyalarını yürütme şeklinizdir. Müzisyenseniz hedefiniz yeni bir parçayı çalmak olabilir. Sisteminiz ise ne kadar sık pratik yaptığınız, farklı ölçüleri nasıl parçalara bölüp çaldığınız ve eğitmeninizden nasıl geri bildirim aldığınızdır. Sisteme odaklanın derken ise hedef koymayın demiyor. Hedefler bir yön belirlemek açısından iyidir ancak ilerleme kaydetme açısından sistemler en iyisidir diyor. Hedefleri düşünmeye çok fazla zaman ayırıp sistemleri tasarlamaya yeterince vakit ayırmadığımızda bir avuç problem doğar. Hedef belirlemek neden problemlidir?\nKazanlarınında kaybedenlerinde hedefleri aynıdır: Olimpiyatlara katılan her sporcu altın madalyayı kazanmak ister. Her aday işi almak ister. Ama başarılı ve başarısız insanlar aynı hedefleri paylaşıyorlarsa kazananları kaybedenlerden ayıran şey hedef olamaz. İngiliz bisikletçileri alanlarının zirvesine taşıyan Fransa Bisiklet Turu\u0026rsquo;nu kazanma hedefi değildi. Tahmin edileceği üzere, diğer bütün profesyonel takımlar gibi yarışı ondan önceki yılarda da kazanmak istemişlerdi. Hedef her zaman oradaydı. Farklı bir sonuca ancak sürekli küçük iyileşmelerden oluşan bir sistem oturttukları zaman ulaştılar. Bir hedefe ulaşmak sadece anlık bir değişikliktir: Bir hedefe ulaşmak hayatınızı sadece şimdilik değiştirir. İlerleme konusunda genel kanıya aykırı olan budur. Sonuçları değiştirmeniz gerektiğini düşürünüz ama sorun sonuçlar değildir. Asıl değiştirmemiz gereken o sonuçlara yol açan sistemlerdir. Hedefler mutluluğunuzu kısıtlar: Her hedefin arkasındaki üstü örtülü varsayım şudur: \u0026ldquo;Hedefime ulaştığım zaman mutlu olacağım\u0026rdquo; Hedefi öne koyan zihniyetin sorunu, mutluluğu sürekli bir sonraki kilometre taşına kadar erteliyor olmanızdır. Dahası hedefler bir \u0026ldquo;ya şunu yaparım ya başarısız olurum\u0026rdquo; çatışması yaratır. Ya hedefinize ulaşır ve başarılı olursunuz ya da çuvallar ve bir hayal kırıklığı olursunuz. Kendinizi zihinsel olarak mutuluğun dar bir versiyonuna hapsedersiniz ve bu yanlıştır. Panzehir ise sistemlere öncelik veren bir zihniyettir. Sonuçtan ziyade sürece aşık olduğunuzda kendinize mutlu olma izni vermek için beklemeniz gerekmez. Sisteminizin işlediği her an tatminkar hissedebilirsiniz. Hedefler uzun vadeli ilerlemeyle pek iyi anlaşamaz: Hedef odaklı bir zihniyet \u0026ldquo;yoyo\u0026rdquo; etkisi yaratabilir. Çoğu koşucu aylarca çok çalışır ama bitiş çizgisini geçtikleri anda antrenmanı bırakır. Onları motive eden yarış artık bitmiştir. Hedef belirlemenin amacı oyunu kazanmaktır. Sistem inşa etmenin amacı ise oyunu oynamaya devam etmektir. Gerçek uzun vadeli düşünme tarzı, hedefsiz düşünmektir. Alışkanlıklar Kimliğinizi Nasıl Biçimlendirir? (ve Tam Tersi) Kötü alışkanlıkları tekrar etmek bu kadar kolayken iyileri oluşturmak neden bu kadar zordur? Genellikle iyi alışkanlıkları bir kaç günden fazla sürdürmek samimi çaba ve zaman zaman yaşanan motivasyon patlamalarıyla bile zor gelir. Egzersiz, meditasyon, günlük tutma ve yemek pişirme gibi alışkanlıklar bir ya da iki gün mantıklı geldikten sonra insanı zorlamaya başlar. Öte yandan alışkanlıklarınız bir kez yer ettiğinde sonsuza dek peşinizi bırakmayacak gibi görünür. Hele istenmeyenler. Ne kadar çaba harcasak da abur cubur yemek, çok fazla televizyon izlemek, işleri ertelemek ve sigara içmek gibi sağlıksız alışkanlıkları aşmak imkansız gelebilir. Alışkanlıklarımızı değiştirmek iki nedenden ötürü zorlayıcıdır. Bir; Yanlış şeyi değiştirmeye çalışırız ve İki; Alışkanlıklarımızı yanlış yönde değiştirmeye çalışırız.\nİlk hatamız yanlış şeyi değiştirmeye çalışmamızdır. Ne demek istediğimi anlamak için değişimin üç katmanda gerçekleşebileceğini göz önünde bulundurun. Bu katmanları bir soğanın katmanları gibi düşünebilirsiniz. İlk katman sonuçlarınızı değiştirmektir. Bu katman sonuçlarınızı değiştirmekle ilgilidir. Kilo vermek, kitap yazmak, şampiyonluk kazanmak gibi. Belirlediğiniz hedeflerin çoğu bu değişim seviyesiyle bağlantılıdır. İkinci katman süreci değiştirmektir. Bu katman alışkanlıklarınızı ve sistemlerinizi değiştirmekle ilgilidir. Spor salonunda yeni bir rutin oturtmak, daha iyi bir iş akılı için masanızdaki dağınıklığı toplamak, bir meditasyon pratiği geliştirmek. İnşa ettiğiniz alışkanlıkların çoğu bu katmanla bağlantılıdır. Üçüncü ve en derin katman ise kimliğinizi değiştirmektir. Bu katman, inançlarınızı değiştirmekle ilgilidir. Dünya görüşünüzü, öz imajınızı, kendinizle ve başkalarıyla ilgili yargılarınızı. Taşıdığınız inançların, varsayımların ve önyargıların çoğu bu katmanla ilgilidir. Çoğu insan alışkanlıklarını değiştirme sürecine ne elede etmek istediğine odaklanarak başlar. Bu bizi sonuca dayalı alışkanlıklara götürür. Alternatifi ise kimliğe dayalı alışkanlıklar inşa etmektir. Bu yaklaşımla işe kim olmak istediğimize odaklanarak başlarız. Sigaraya direnen iki kişi düşünün. Sigara ikram edildiğinde birinci kişi \u0026ldquo;Hayır teşekkürler sigarayı bırakmaya çalışıyorum\u0026rdquo; diyor. Kulağa mantıklı bir cevap geliyor bu ama aslında bu kişi hala başka bir şey olmaya çalışan bir tiryaki olduğunu düşünüyor. Aynı inançları taşırken davranışının değişmesini umuyor. İkinci kişi ise teklifi \u0026ldquo;Hayır, teşekkürler ben sigara içmem\u0026rdquo; diyerek geri çeviriyor. Arada küçük bir fark var ama bu beyan, kimlikte bir kaymayı işaret ediyor. Sigara içmek söz konusu kişinin önceki hayatının bir parçasıydı şimdikinin değil. Bu kişi kendini artık sigara içen biri olarak tanımlamıyor. Kişinin özüyle uyuşmayan bir davranış kalıcı olamaz. Daha fazla para isteyebilirsiniz ama kimliğiniz yaratmaktan çok tüketen bir kimlikse kazanmak yerine harcamaya doğru çekilmeye devam edersiniz. Sağlığınızın daha iyi olmasını isteyebilirsiniz ama konforunuza öncelik verdiğiniz sürece, spor yapmak yerine gevşemeye çekilirsiniz. İçsel motivasyonunuzun en üst düzeyi, bir alışkanlığın kimliğinizin bir parçasına dönüşmesidir. Şunu isteyecek türde bir insan olduğunu söylemek başka bir şeydir, şu olan türde bir insan olduğunuzu söylemek bambaşka. Gerçek davranış değişikliği kimlik değişikliğidir. Bir alışkanlığa motivasyon nedeniyle başlayabilirsiniz ama ona bağlı kalmanızın tek nedeni kimliğinizin bir parçasına dönüşmesi olacaktır. Hedef bir kitap okumak değil okuyan birine dönüşmek, hedef bir maraton koşmak değil koşucuya dönüşmek, hedef bir enstrüman çalmayı öğrenmek değil müzisyene dönüşmek. Kimliğinizi değiştirmenin iki adımlı süreci: Alışkanlıklarınız kimliğinizi somutlaştırma şeklinizdir. Her gün yatağınızı toplayarak düzenli bir insanın kimliğini somutlaştırmış olursunuz. Her gün yazarak yaratıcı bir insanın kimliğini somutlaştırırsınız. Her gün antrenman yaparak atletik bir insanın kimliğini somutlaştırırsınız. Bir davranışı ne kadar çok tekrarlarsanız o davranışla bağlantılı kimliği o kadar pekiştirirsiniz. Elbette kimliğinizi etkileyen tek eylem alışkanlıklarınız değildir ancak sıklıklarının gücü onları en önemlileri kılar. Hayattaki her tecrübe öz imajınızı değiştirir ama bir kez topa vurdunuz diye kendinizi futbolcu olarak görmeniz ya da bir resim karaladınız diye kendinizi ressam olarak görmeniz olası değildir. Bu kademeli bir ilerlemedir. Parmağınızı tıklatarak ya da yepyeni biri olmaya karar vererek değişemeyiz. Azar azar, günbegün, alışkanlık üstüne alışkanlıkla değişiriz. Sürekli benliğimizin mikroevrimlerine maruz kalırız. Olduğunuz kişiyi değiştirmenin en pratik yolu yaptığınız şeyi değiştirmektir.\nNe zaman bir sayfa bir şey yazarsanız yazar olursunuz Ne zaman keman çalsanız müzisyen olursunuz Ne zaman egzersiz yapmaya başlarsınız sporcu olursunuz Ne zaman çalışanlarınızı teşvik etseniz lider olursunuz Elbette bu aksi yönde de işler. Ne zaman bir kötü alışkanlığı uygulamayı seçseniz o da kimlik için bir oy sayılır. İyi haber şu ki kusursuz olmak zorunda değilsiniz. Her seçimde iki tarafa da oy çıkacaktır. Bir seçimi kazanmak için oy birliğine değil oy çokluğuna ihtiyaç vardır. Kötü bir alışkanlık ya da üretkenlik dışı bir alışkanlık için birkaç oy almanız önemli değildir. Amacınız çoğunluğu kazanmaktır. Yeni kimlikler yeni kanıtlar gerektirir. Her zaman verdiğiniz şekilde oy vermeye devam ederseniz her zamanki sonuca ulaşırsınız. Hiçbir şey değişmezse gelecekte de hiçbir şey değişmeyecektir. Bu iki adımlı basit bir süreçtir.\nOlmak istediğiniz insan türüne karar verin Bunu küçük kazanımlarla kendinize ispatlayın. Önce kim olmak istediğinize karar verin. Bu ister bir takım, ister toplum, ister ulus için olsun her düzeyde geçerlidir. Neyi temsil etmek istiyorsunuz? Prensip ve değerleriniz neler? Kim olmak istiyorsunuz? Kendinize şunu sorun: \u0026ldquo;İstediğim sonucu ne tür bir insan elde edebilir? Nasıl bir insan yirmi kilo verebilir? Nasıl bir insan yeni bir dil öğrenebilir?\u0026rdquo; Örneğin \u0026ldquo;Nasıl bir insan kitap yazabilir?\u0026rdquo; Muhtemelen istikrarlı ve güvenilir bir insan. Şimdi odak noktanız kitap yazmaktan (sonuca dayalı), istikrarlı ve güvenli bir insan olmaya (kimliğe dayalı) kaysın. Bu süreç şöyle inançlara yol açabilir:\n\u0026ldquo;Ben öğrencilerinin hakkını koruyan bir öğretmenim\u0026rdquo; \u0026ldquo;Ben her hastasına, ihtiyaç duyduğu zamanı ve empatiyi sunan bir doktorum\u0026rdquo; \u0026ldquo;Ben çalışanlarını savunan bir yöneticiyim\u0026rdquo; Olmak istediğiniz insan türünü anladığınız zaman, arzu ettiğiniz kimliği pekiştirmek için küçük adımlar atmaya başlayabilirsiniz. Alışkanlıklarınız kimliğinizi, kimliğiniz alışkanlıklarınızı biçimlendirir. Bu iki yönlü bir sokaktır. Nihayetinde alışkanlıklarınız olmak istediğiniz insana dönüşmenize yardımcı olmak için önemlidir. Kendinizle ilgili en derin inançlarınızı geliştirmenize aracılık eden kanaldırlar. Kelimenin tam anlamıyla insan alışkanlıklarına dönüşür.\nDavranış Değişikliğinin Dört Yasası Bir alışkanlık oluşturmanın omurgasını James Clear dört unsura bağlıyor.\nİşaret: Bir davranışı başlatmak için beyninizi tetikler. Bir ödülün yaklaştığının habercisidir. Zihnimiz ödüllerin ipuçlarını bulmak için iç ve dış çevreyi sürekli analiz eder. İşaret ödülün ilk göstergesidir. İstek: İkinci adımdır ve her alışkanlığın ardındaki motivasyonun gücünü oluşturur. Bir değişim isteği duymadan harekete geçmemiz için bir neden olmaz. Bir bilgi parçası isteği tetikleyebilir. Kumarbaz için kumar makinesi sesi bu tetikleyici olabilir örneğin. Tepki / Eylem: Bir tepkinin olum olmayacağı ne kadar motive olduğunuzla ve ne kadar zorlanacağınızla ilişkilidir. Bir eylem sizin harcamak istediğinizden fazla çaba gerektiriyorsa onu yapmazsınız. Ödül: Ödüller her alışkanlığın nihai amacıdır. İşaret ödülü fark etmektir. İstek ödüle arzu duymaktır. Tepki ödülü ele geçirmekle ilgilidir. Ödülleri iki nedenle kovalarız: 1- Bizi tatmin ederler 2- bize öğretirler Bir davranış bu dört aşamanın birinde yetersizse asla alışkanlığa dönüşmez.\nBu dört adım iki safhaya ayrılabilir: Sorun safhası ve çözüm safhası. Sorun safhası işaret ve isteği kapsar ve bir şeyin değişmesi gerektiğini fark ettiğiniz aşamadır. Çözüm safhası ise tepkiyi ve ödülü kapsar, harekete geçtiğiniz ve arzu ettiğinizi başardığınız safhadır. Bütün davranışlar bir sorunu çözme arzusundan güç alır. Gerçek hayattan birkaç örnek:\nAlışkanlıkların dört yasasını yeni alışkanlıklar edinmek ve kötü alışkanlıklardan kurtulmak için aşağıdaki gibi kullanabiliriz.\nGörünür Kıl: Bir alışkanlığı görünür kılmak onu zahmetleştirmek yani gözümüzün keseceği hale getirmektir. Örneği yatağının yanında bir kitap bulundurursan yatmadan okuyabilirsin, spora gitmeden bir gün önce eşyalarını hazırlarsan gitme için daha rahatlarsın. Cazip Kıl: Kişinin nasıl bir insan olmak istediğiyle alakalıdır. Örneğin bir enstrüman çalıyorum demek yerine ben bir müzisyenim, ben spor yapmaya çalışıyorum demek yerine ben bir sporcuyum demek daha iyidir. Bu şekilde bu söylemler karakterinizin yani kimliğinizin bir parçası haline gelir. Bunu bir süre yaptıktan sonra bilinçaltınız ona göre davranmaya başlayacaktır. Kolaylaştır: Alışkanlığı gerçekleştirirken gereken şeyleri bir araya getirmektir. Sağlıklı beslenmeye karar verdiyseniz bir kaç gün önceden sağlıklı yemekleri hazırlamak gibi. Tatmin Edici Kıl: Eylemin gerçekleştirdikten sonra kendinizi ödüllendirmektir. Bu ödülün kolay ulaşılabilir, küçük şeylerden oluşması daha doğrudur. İlk günlerde kitabı okumak zor geliyorsa bu kadar sayfa okuduktan sonra dizi izleyeceğim, işimi bitirdikten sonra sevdiğim müziği dinleyeceğim vb. İyi alışkanlıkları kazandıran şeylerin tersi kötü alışkanlıkları azaltmaya ve kurtarmaya yardımcı olur.\nAlışveriş merkezine gidip fastfood yiyorsanız gitmezsiniz, belirli bir uygulamadan çok sipariş veriyorsanız uygulamayı silersiniz, sigarayı çok içiyorsanız paketi yanınızda taşımadığınızda içmezsiniz. Yine kötü alışkanlıkları itici kılmak adına bu alışkanlıkların size verdiği zararları düzenli aralıklarla yazabilirsiniz. Alışkanlık Oluşturma Taktikleri Alışkanlık Kartı Oluşturma: Günlük alışkanlıklarınızın bir listesini yapabilirsiniz. İyi alışkanlıklarınıza +, kötü alışkanlıklarınıza -, nötr alışkanlıklarınıza ise = koyabilirsiniz. Bu sayede değişmesini istediğiniz alışkanlıklarınızın farkına varabilir ve değişmesine karar verebilirsiniz. Bu sayede kötü alışkanlıklardan kurtulmak için adım atabilirsiniz. Size zihinsel olarak itici güç verebilir. Alışkanlık İstifleme veya Öncelik-Sonralık İlişkisi: Kötü alışkanlıkları ekarte etmek adına alışkanlıklar arasında bir öncelik-sonralık zinciri yani bir nevi ritüel oluşturabilirsiniz. Örneğin sabah uyanında cep telefonunda sosyal medyaya girip vakit kaybediyorsanız bunun yerine uyandıktan sonra bir bardak su içeceğim, su içtikten sonra evdeki bütün perdeleri açacağım, tüm perdeleri açtıktan sonra 5 dakika meditasyon yapacağım diyebilirsiniz. Aradan Çıkarma Taktiği: Sevmediğiniz veya daha az sevdiğiniz bir şeyi daha fazla sevdiğiniz bir şeyle birlikte yapabilirsiniz. Bu odaklanmayı ve dopamini düşürür ancak hiç bir şey yapmamaktan iyidir. Örneğin spor yaparken çok sevdiğiniz bir diziyi veya filmi izleyebilirsiniz, işinizi yaparken müzik dinleyebilirsiniz vb. Ortamı Tasarlama Taktiği: Ortamınızı alışkanlıklarınıza uygun hale getirerek hayatınızın mimari olabilirsiniz. Mutfakta sadece yemek yemek, yatak odasında sadece uyumak, oturma odanızın bir köşesinde sadece kitap okumak vb. Bir ortamı bir alışkanlığa uygun hale getirdiğinizde bir aidiyet duygusu oluşturursunuz. O koltuğa oturduğunuzda o kitabı elinize alıyorsunuz yani alışkanlığınız ve ortamınızı birbiriyle ilişkili hale getirdiğinizde gerçekleştirmek daha kolay bir hal alıyor veya yaptığınız işi en iyi şekilde yapıyorsunuz. Gruplandırma Taktiği: Birbiriyle uyumlu olan alışkanlıklarınızı gruplandırırsanız gerçekleştirmesi daha kolaylaşacaktır. Örneğin uyandıktan sonra size kendinizi daha iyi hissettirecek şeyleri yapmak. Su içmek, duş almak, giyinmek vb. alışkanlıkları gruplandırmak. Önemli olan basit uygulanabilir ve faydalı alışkanlıkları grup haline getirmek yani birbirleriyle ilişkilendirmek, bir zincirin halkası gibi. Yani bir alışkanlığı yaptığınızda bilinçaltının diğeri için seni yönlendirmesi. Zamana Bölme Taktiği: Bir alışkanlığı en rahat hangi zamanda gerçekleştiriyorsunuz? Alışkanlıklarınızı edinirken hangi zamanlarda neyi daha iyi gerçekleştirdiğinizi gözlemleyin. Bir işi yapma konusunda en istekli olduğunuz zaman ne zaman, en verimli olduğunuz zamanlar hangi dilimler? Kitap okumak, egzersiz yapmak vb. Genel olarak uyandıktan sonra ilk 8 saat yeni alışkanlıklar kazanmak ve zor işlerinizi yapmak için en ideal zamandır. Ancak neyi ne zaman yapmaktan hoşlanıyorsanız buna göre alışkanlıklarınızı zamanlayabilirsiniz? Ataç Taktiği / Görselleştirme Taktiği: Yapacağınız alışkanlıkları hatırlatıcı olarak görselleştirmek. Görselleştirme size eyleme geçmeyi hatırlatır. Bir davranıştaki ilerlemenizi gösterir, sizi motive eder. Bu görselleştirmeyi gerçekten bir ataç alıp işi yaptıkça dolu kavanozdan boş kavanoza atabileceğiniz gibi, not yazma, mobil uygulama kullanma gibi şekillerde de yapabilirsiniz. Başkalarıyla Birlikte Yapma Taktiği: Çevrenizdeki insanlar sürekli olarak alkol alıp sigara içiyorlarsa sizin de onlara eşlik etme ihtimaliniz yüksektir. Hemen değil ancak bir süre sonra bu davranış sizin normale dönecektir. İnsan ortamına uyum sağlayan bir varlıktır ancak bunu aksi yönde uygulamakta mümkündür. Bir türlü kitap okumayı düzenli hale getiremiyorsunuz diyelim. Çevrenizde boş bol kitap okuyan insanlar olursa onlarla birlikte yaparak sizde kitap okuma alışkanlığınızı geliştirebilirsiniz. Duygularını Yönetme veya Duygusal Durumunu Değiştirme Taktiği: Bir çok kötü alışkanlığın kökeni üzüntüden, kaygıdan, olayları zihninde tekrar tekrar ziyaret etmekten kaynaklanır. Örneğin sinirlendiğinizde sürekli bir şeyler yemek, öfkeliyken alkol almak vs. O duygu bir tetikleyici oluyor. Ufak bir değişiklikle bunu olumluya çevirebiliriz. Çok sinirlendiğinizde mümkünse yürüyüş yapın ya da çok sevdiğiniz şarkı vardır dilinize dolanan size ilham veren vb. Öfkelendiğinizde o şarkıyı söyleyebilirsiniz veya dinleyebilirsiniz. 21 Gün Kuralı Taktiği: 21 gün boyunca 6 yeni alışkanlık yapmayı deneyin. Sonrasında bunları yapmayı kasıtlı olarak bırakın. Bu 6 alışkanlığı otomatikleştirdiğinizi gördüğünüzde veya en azından bir kısmını otomatik olarak yapabildiğinizde boşalan sayıda yeni alışkanlıklar kazanmak adına 21 günlük yeni programlara başlayabilirsiniz. Bir alışkanlık edindiğinizde ve bunu içselleştirdiğinizde diğer alışkanlıkları daha kolay edinebildiğinizi göreceksiniz. Peki ya hayatınız alt üst olduğunda alışkanlıklarınıza nasıl devam edeceksiniz? Kapsamı azaltıp plana bağlı kalın. Örneğin 300 kelime yazıyorsanız 50 kelime yazın ama her gün yapın. If-Then Tekniğini kullanın:\u0026ldquo;Eğer [beklenmedik bir şey] ise, o zaman [cevabınız].\u0026rdquo; Örneğin: Yarın sabah koşmak için zamanında uyanamazsam, işten sonra koşacağım. Öğle tatilinde yogaya yetişemezsem öğleden sonra yapacağım Öğle yemeği için sağlıksız bir şey alırsam, akşam yemeği için sağlıklı bir yemek pişiririm.\nSonuç Kitap benim için okuması oldukça faydalı bir kitap oldu. Zaten hali hazırda olan alışkanlıklarımın tekrar farkına vardım ve yeni alışkanlıklar elde edinebilmek için içerideki yöntemlerden bazılarını uygulamaya başladım. İlerleme veya sonuçları gördükçe paylaşmaya devam ederim. Umarım size de faydalı bir içerik olur. Teşekkürler.\nKaynakça James Clear - Atomik Alışkanlıklar https://medium.com/@sevketkurt/atomi%CC%87k-ali%C5%9Fkanliklar-ki%CC%87tap-%C3%B6zeti%CC%87-89393c903b06 https://nurdanozdemir.medium.com/atomik-al%C4%B1%C5%9Fkanl%C4%B1klar-kitap-%C3%B6zeti-bfa513c2c890 ",
        "tags": ["kitap-özeti","alışkanlıklar","kişisel-gelişim"],
        "categories": ["Kitap","Kişisel Gelişim"],
        "lang": "tr"
    },{
        "title": "Arşiv",
        "permalink": "/blog/tr/archives/",
        "summary": "",
        "content": "",
        "tags": null,
        "categories": ["archives"],
        "lang": "tr"
    },{
        "title": "App Store Connect API için JWT Token Nasıl Oluşturulur?",
        "permalink": "/blog/tr/appstore-connect-ile-jwt-token-nasil-olusturulur/",
        "summary": "App Store Connect API, App Store Connect\u0026rsquo;te gerçekleştirdiğiniz işlemleri otomatikleştiren bir REST API\u0026rsquo;dir. Bu API, geliştiricilere uygulama gönderme ve güncelleme işlemlerinden, iç uygulama satın almalarını yönetmeye, uygulama performansını ve kullanıcı etkileşimini..",
        "content": "\nHerkese merhabalar! App Store Connect API hakkında ilk blog yazısına hoşgeldiniz. Bu yazımda sizlere kısaca App Store Connect API\u0026rsquo;den ve API\u0026rsquo;yi kullanabilmek için nasıl JWT token oluşturabileceğinizi anlatacağım.\nApp Store Connect API Nedir? App Store Connect API, App Store Connect\u0026rsquo;te gerçekleştirdiğiniz işlemleri otomatikleştiren bir REST API\u0026rsquo;dir. Bu API, geliştiricilere uygulama gönderme ve güncelleme işlemlerinden, iç uygulama satın almalarını yönetmeye, uygulama performansını ve kullanıcı etkileşimini kapsamlı raporlar aracılığıyla izlemeye, müşteri değerlendirmelerine ve geri bildirimlere etkili bir şekilde yanıt vermeye kadar çeşitli görevleri sorunsuz bir şekilde yerine getirme imkanı sunar.\nNeden JWT Token? Token olmadan, App Store Connect API\u0026rsquo;den yanıt alamazsınız, ancak genellikle API, kimlik doğrulama ve yetkilendirme amaçları için JSON Web Token (JWT) gerektirir. API bağlamında JWT token, istemcinin kimliğini doğrulamak ve istenen kaynaklara erişim için gerekli izinlere sahip olduğunu sağlamak için güvenli ve standart bir yöntem olarak hizmet eder.\nJWT Token Nasıl Oluşturulur? App Store Connect API\u0026rsquo;yi kullanmak için JWT tokenları oluşturmadan önce birkaç adımı tamamlamanız gerekmektedir.\nApp Store Connect GUI üzerinden API Key oluşturun\nÖzel anahtarı p8 formatında kaydedin.\nIssuer ID ve API Key ID değerlerini kopyalayın.\nAPI Key Oluşturma API anahtarı oluşturmak için, hesabınızla App Store Connect web arayüzüne giriş yapın ve Users\u0026amp;Access sayfasına gidin. Sayfadaki \u0026ldquo;Keys\u0026rdquo; sekmesine tıklayın. \u0026ldquo;Keys\u0026rdquo; sekmesini görebilmek için hesabınızın bu izne sahip olması gerekmektedir. Belirli bir amaç için API anahtarı veya tüm App Store Connect API\u0026rsquo;ına erişim sağlayan yönetici API anahtarı oluşturabilirsiniz.\n\u0026lsquo;Active\u0026rsquo; metni yanındaki artı ikonuna tıklayın, anahtar için bir isim yazın, açılan modalda anahtara erişebilecek rolleri seçin ve \u0026lsquo;Generate\u0026rsquo; düğmesine tıklayın. Ardından anahtar oluşturulacak ve listelenecektir.\nÖzel Anahtarı Kaydedin API Anahtarı oluşturulduktan sonra Özel Anahtarı bilgisayarınıza kaydetmeniz gerekiyor. Anahtar genellikle .p8 formatındadır. Özel anahtarla uğraşırken akılda tutmanız gereken bazı önemli noktalar bulunmaktadır.\nÖzel anahtar yalnızca bir kez kaydedilebilir. Kaydedildikten sonra mutlaka güvenli bir şekilde saklanması önemlidir.\nÖzel anahtar asla süresi dolmaz ve geçerli olduğu sürece çalışır; hatta tehlikeye girmiş olsa bile. Eğer anahtarınızın artık güvenli olmadığını düşünüyorsanız, en kısa sürede App Store Connect\u0026rsquo;ten iptal edin ve yeni bir anahtar alın.\nIssuer ID ve API Key ID Değerlerini Kopyalayın JWT token oluşturmadan önce son adım, Users\u0026amp;Access sayfasında bulabileceğiniz Issuer ID ve API Key ID\u0026rsquo;yi kopyalamaktır.\nJWT Token Oluşturma Daha önce belirttiğim gibi, JWT, App Store Connect API tarafından kullanılan belirli bir tokenı oluşturmak için kullanılır. Token oluşturma süreci aşağıdaki adımları içerir:\nIssuerID: User\u0026amp;Access sayfasından kopyalanan Issuer ID bilgisi.\nPrivate Key: .p8 formatında kaydedilen özel anahtar.\nExpiration Time: Maksimum 20 dakika, token 20 dakikadan fazla geçerli olamaz, bu nedenle süresi dolmadan yeni bir token oluşturduğumuzdan emin olmalıyız.\nAudience: Genellikle \u0026lsquo;applestoreconnect-v1\u0026rsquo; olarak ayarlanan API sürüm değeri ile sabit bir değerdir.\nAlgorithm: JWT algoritması, örneğin ES256, token oluşturmak için gereklidir.\nGerekli tüm detaylara sahip olduktan sonra, istediğiniz dil kullanarak JWT token oluşturabileceksiniz. Ben bu süreç için Node.js kullanacağım.\nAşağıdaki komutları bilgisayarınızda sırasıyla çalıştırın:\nmkdir appStoreToken cd appStoreToken npm init -y npm i jsonwebtoken touch index.js Aşağıdaki kodu index.js dosyanıza yapıştırın ve ilgili alanları kendi bilgilerinizle değiştirip kaydedin.\nconst fs = require(\u0026#34;fs\u0026#34;); const jwt = require(\u0026#34;jsonwebtoken\u0026#34;); const privateKey = fs.readFileSync(\u0026#34;yourPrivateKey.p8\u0026#34;); const apiKeyId = \u0026#34;Your API Key ID\u0026#34;; const issuerId = \u0026#34;Your Issuer ID\u0026#34;; let now = Math.round(new Date().getTime() / 1000); // Notice the /1000 let nowPlus20 = now + 1199; // 1200 === 20 minutes let payload = { iss: issuerId, exp: nowPlus20, aud: \u0026#34;appstoreconnect-v1\u0026#34;, }; let signOptions = { algorithm: \u0026#34;ES256\u0026#34;, header: { alg: \u0026#34;ES256\u0026#34;, kid: apiKeyId, typ: \u0026#34;JWT\u0026#34;, }, }; let token = jwt.sign(payload, privateKey, signOptions); console.log(\u0026#34;@token: \u0026#34;, token); ve son olarak aşağıdaki komutu çalıştırın.\nnode index.js Bu işlem, App Store Connect API\u0026rsquo;ye erişim için kullanabileceğimiz uzun bir token döndürecektir. Ayrıca, API\u0026rsquo;yi 20 dakika sonrasında kullanmaya devam etmek istiyorsak başka bir token oluşturmamız gerekecektir.\nSonuç Bu yazıdma, App Store Connect API için Node.js kullanarak bir JWT tokenı nasıl oluşturulur konusunu anlatmaya çalıştım. Bu, API\u0026rsquo;ye olan isteklerinizi doğrulamanın kritik bir adımıdır. Gelecekteki yazılarda, App Store Connect API\u0026rsquo;yi kullanmanın diğer yollarını anlatmaya çalışacağım. Okuduğunuz için teşekkür ederim.\nBu yazıyı İngilizce oku\n",
        "tags": ["jwt","app-store","api"],
        "categories": ["Geliştirme","iOS"],
        "lang": "tr"
    }]

