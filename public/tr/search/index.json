[{"categories":["TypeScript"],"contents":"Merhaba! TypeScript serimizin bu bölümünde, object types konusunu detaylı bir şekilde inceleyeceğiz. Özellikle fonksiyonlarda obje tiplerinin nasıl kullanıldığına ve type alias\u0026rsquo;ların neden önemli olduğuna odaklanacağız.\nObject Annotations ile Çalışmak TypeScript\u0026rsquo;te fonksiyonlarda obje parametreleri tanımlarken iki farklı yaklaşım kullanabiliriz. İlk olarak, doğrudan fonksiyon parametresi içinde obje tipini tanımlayabiliriz:\n// Parametre içinde doğrudan obje tipi tanımlama const printName = (name: { first: string; last: string }) =\u0026gt; { return `Name: ${name.first} ${name.last}`; }; // Kullanımı printName({ first: \u0026#39;Will\u0026#39;, last: \u0026#39;Ferrell\u0026#39; }); Bu yaklaşım basit objeler için kullanışlı olsa da, karmaşık obje yapılarında okunabilirliği azaltabilir ve kod tekrarına yol açabilir. Özellikle aynı obje tipini birden fazla yerde kullanacaksanız, bu yaklaşım yerine type alias kullanmanız önerilir.\nSüslü Parantezlerin Kullanımı Fonksiyon parametrelerinde obje tiplerini tanımlarken süslü parantezlerin kullanımı bazen kafa karıştırıcı olabilir:\n// Kafa karıştırıcı olabilecek syntax const printPerson = (person: { name: string; age: number }): { info: string } =\u0026gt; { return { info: `${person.name} is ${person.age} years old` }; }; // Daha okunaklı versiyonu - Type Alias kullanarak type Person = { name: string; age: number; }; type PersonInfo = { info: string; }; const printPerson2 = (person: Person): PersonInfo =\u0026gt; { return { info: `${person.name} is ${person.age} years old` }; }; İkinci yaklaşım daha okunaklıdır çünkü:\nTip tanımlamaları fonksiyon tanımından ayrılmıştır Tipler yeniden kullanılabilir Kod daha düzenli ve bakımı daha kolaydır Type Alias Kullanımı Type alias\u0026rsquo;lar, obje tiplerini ayrı olarak tanımlamamıza ve bu tipleri kodumuzda tekrar tekrar kullanmamıza olanak sağlar:\n// Type alias tanımlama type Person = { name: string; age: number; }; // Fonksiyonda kullanma const sayHappyBirthday = (person: Person) =\u0026gt; { return `Hey ${person.name}, congrats on turning ${person.age}!`; }; // Değişkende kullanma const jerry: Person = { name: \u0026#39;Jerry\u0026#39;, age: 42, }; sayHappyBirthday(jerry); Type alias kullanmanın avantajları:\nKod tekrarını önler Tip tanımlarını merkezi bir yerde tutar Değişiklikleri tek bir yerden yönetmeyi sağlar Kodun okunabilirliğini artırır Nested Objects (İç İçe Objeler) TypeScript\u0026rsquo;te iç içe obje yapıları tanımlamak oldukça yaygındır. İşte bir örnek:\nconst describePerson = (person: { name: string; age: number; parentNames: { mom: string; dad: string; }; }) =\u0026gt; { return `Person: ${name}, Age: ${age}, Parents: ${parentNames.mom}, ${parentNames.dad}`; }; // Kullanımı describePerson({ name: \u0026#39;Jimmy\u0026#39;, age: 10, parentNames: { mom: \u0026#39;Kim\u0026#39;, dad: \u0026#39;Steve\u0026#39;, }, }); Bu yapıyı type alias kullanarak daha düzenli hale getirebiliriz:\ntype ParentNames = { mom: string; dad: string; }; type PersonWithParents = { name: string; age: number; parentNames: ParentNames; }; const describePerson2 = (person: PersonWithParents) =\u0026gt; { const { name, age, parentNames } = person; return `Person: ${name}, Age: ${age}, Parents: ${parentNames.mom}, ${parentNames.dad}`; }; Excess Properties (Fazla Özellikler) TypeScript, bir obje tipinde tanımlanmamış özellikleri kullanmaya çalıştığınızda sizi uyarır:\ntype BasicPerson = { name: string; age: number; }; // Hata verecek const person: BasicPerson = { name: \u0026#39;John\u0026#39;, age: 30, location: \u0026#39;New York\u0026#39;, // Fazla özellik hatası }; // Doğru kullanım const personData = { name: \u0026#39;John\u0026#39;, age: 30, location: \u0026#39;New York\u0026#39;, }; const person2: BasicPerson = personData; // Bu çalışır Optional Properties Bazen obje tipindeki bazı özelliklerin opsiyonel olmasını isteyebiliriz:\ntype OptionalPerson = { name: string; age: number; phone?: string; // Opsiyonel özellik email?: string; // Opsiyonel özellik }; // Her iki kullanım da geçerli const person1: OptionalPerson = { name: \u0026#39;Alice\u0026#39;, age: 25, }; const person2: OptionalPerson = { name: \u0026#39;Bob\u0026#39;, age: 30, phone: \u0026#39;555-0123\u0026#39;, email: \u0026#39;bob@email.com\u0026#39;, }; Readonly Modifier TypeScript\u0026rsquo;te readonly modifier, bir nesnenin özelliklerinin değiştirilmesini engellemek için kullanılır. Bu, veri bütünlüğünü korumak ve istenmeyen değişiklikleri önlemek için oldukça kullanışlıdır:\ntype Person = { readonly name: string; readonly age: number; }; const john: Person = { name: \u0026#39;John\u0026#39;, age: 30, }; // Aşağıdaki satırlar derleme zamanında hata verecektir // john.name = \u0026#34;Johnny\u0026#34;; // Hata: Cannot assign to \u0026#39;name\u0026#39; because it is a read-only property // john.age = 31; // Hata: Cannot assign to \u0026#39;age\u0026#39; because it is a read-only property readonly modifier, nesnenin ilk oluşturulması sırasında değer atamasına izin verir, ancak daha sonra bu özelliklerin değiştirilmesini engeller.\nReadonly Array Diziler için de readonly modifier kullanılabilir. Bu, dizinin içeriğinin değiştirilmesini engeller:\nconst numbers: readonly number[] = [1, 2, 3, 4, 5]; // Aşağıdaki metodlar artık kullanılamaz // numbers.push(6); // Hata // numbers.pop(); // Hata // numbers[2] = 10; // Hata Intersection Types Intersection types, birden fazla tipi birleştirerek yeni bir tip oluşturmamıza olanak sağlar:\ntype Employee = { employeeId: number; department: string; }; type Person = { name: string; age: number; }; // İki tipi birleştiren yeni bir tip type EmployeePerson = Employee \u0026amp; Person; const worker: EmployeePerson = { employeeId: 1234, department: \u0026#39;Engineering\u0026#39;, name: \u0026#39;Alice\u0026#39;, age: 30, }; Intersection types, karmaşık nesne yapıları oluştururken oldukça kullanışlıdır. Birden fazla tipin özelliklerini tek bir tipte birleştirebilirsiniz.\nIntersection Type Örneği Intersection type\u0026rsquo;ların nasıl kullanılabileceğini gösteren basit bir örneğe bakalım:\n// Adres bilgilerini içeren tip type Address = { street: string; city: string; country: string; }; // İletişim bilgilerini içeren tip type Contact = { email: string; phone: string; }; // İki tipi birleştirerek tam bir kullanıcı profili oluşturma type UserProfile = Person \u0026amp; Address \u0026amp; Contact; // Kullanım örneği: const user: UserProfile = { name: \u0026#39;Ahmet\u0026#39;, age: 30, street: \u0026#39;Atatürk Caddesi\u0026#39;, city: \u0026#39;İstanbul\u0026#39;, country: \u0026#39;Türkiye\u0026#39;, email: \u0026#39;ahmet@email.com\u0026#39;, phone: \u0026#39;555-0123\u0026#39; }; // Fonksiyonda kullanım örneği function displayUserInfo(user: UserProfile) { console.log(` Kullanıcı: ${user.name} Yaş: ${user.age} Adres: ${user.street}, ${user.city}, ${user.country} İletişim: ${user.email}, ${user.phone} `); } displayUserInfo(user); Bu örnek, intersection type\u0026rsquo;ların nasıl farklı özellikleri birleştirmek için kullanılabileceğini gösteriyor:\nTip Kompozisyonu: Farklı amaçlar için ayrı tipler tanımlıyoruz (Person, Address, Contact) Intersection Types: Bu tipleri \u0026amp; operatörü ile birleştirerek daha kapsamlı bir tip oluşturuyoruz Modülerlik: Her tip kendi sorumluluğuna sahip ve ayrı ayrı yönetilebilir Yeniden Kullanılabilirlik: Bu tipleri başka yerlerde de kullanabiliriz Bu desen özellikle şunları yapmak istediğinizde kullanışlıdır:\nFarklı veri gruplarını mantıksal olarak ayırmak Kodunuzu daha modüler hale getirmek Tip tanımlarını yeniden kullanmak Karmaşık veri yapılarını organize etmek Array Types TypeScript\u0026rsquo;te dizi tipleri birkaç farklı şekilde tanımlanabilir:\n// Birinci yöntem: Köşeli parantez kullanarak const numbers: number[] = [1, 2, 3, 4, 5]; // İkinci yöntem: Generic Array tipi kullanarak const strings: Array\u0026lt;string\u0026gt; = [\u0026#39;hello\u0026#39;, \u0026#39;world\u0026#39;]; // Karışık tip dizisi const mixed: (number | string)[] = [1, \u0026#39;two\u0026#39;, 3, \u0026#39;four\u0026#39;]; // Tuple (Sabit uzunlukta, farklı tiplerde dizi) const employee: [number, string] = [1, \u0026#39;John Doe\u0026#39;]; // Readonly dizi const readonlyNumbers: readonly number[] = [1, 2, 3]; Dizi Metodları ve Tip Çıkarımı TypeScript, dizi metodlarında akıllı tip çıkarımı yapar:\nconst numbers = [1, 2, 3, 4, 5]; const doubled = numbers.map((x) =\u0026gt; x * 2); // doubled tipi number[] const names = [\u0026#39;Alice\u0026#39;, \u0026#39;Bob\u0026#39;, \u0026#39;Charlie\u0026#39;]; const upperNames = names.map((name) =\u0026gt; name.toUpperCase()); // upperNames tipi string[] Çok Boyutlu Diziler (Multi-Dimensional Arrays) TypeScript\u0026rsquo;te çok boyutlu diziler, iç içe diziler veya matris benzeri veri yapıları oluşturmak için kullanılır:\n// 2 Boyutlu sayı dizisi const matrix: number[][] = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ]; // 3 Boyutlu dizi örneği const threeDimensionalArray: number[][][] = [ [ [1, 2], [3, 4], ], [ [5, 6], [7, 8], ], [ [9, 10], [11, 12], ], ]; // Karışık tipli 2 boyutlu dizi const mixedMatrix: (number | string)[][] = [ [1, \u0026#39;two\u0026#39;, 3], [\u0026#39;four\u0026#39;, 5, \u0026#39;six\u0026#39;], ]; // Çok boyutlu dizi üzerinde işlemler const sumMatrix = (matrix: number[][]): number =\u0026gt; { return matrix.flat().reduce((sum, num) =\u0026gt; sum + num, 0); }; console.log(sumMatrix(matrix)); // Tüm elemanların toplamını verir // Dizi boyutunu kontrol etme const printMatrixInfo = (matrix: number[][]) =\u0026gt; { console.log(`Matris boyutu: ${matrix.length} x ${matrix[0].length}`); }; printMatrixInfo(matrix); // \u0026#34;Matris boyutu: 3 x 3\u0026#34; çıktısı verir Çok boyutlu diziler, özellikle görüntü işleme, oyun geliştirme, bilimsel hesaplamalar gibi alanlarda sıkça kullanılır. TypeScript, bu tür karmaşık dizi yapılarında güçlü tip kontrolü sağlar.\nSonuç TypeScript\u0026rsquo;in object types özellikleri, kodunuzun tip güvenliğini artırır ve daha net, hata ayıklaması kolay kod yazmanıza yardımcı olur. readonly modifier, intersection types, esnek dizi tipleri ve çok boyutlu diziler, TypeScript\u0026rsquo;in güçlü tip sisteminin önemli parçalarıdır.\nBir sonraki yazımızda görüşmek üzere!\n","lang":"tr","permalink":"/tr/blog/typescript-serisi/typescripti-anlamak-bolum3/","summary":"Bu makalede, TypeScript\u0026rsquo;teki obje tiplerini detaylı bir şekilde inceleyeceğiz. Obje tanımlamaları, tip takma adları ve iç içe objelerle çalışmayı öğreneceğiz.","tags":["typescript","javascript","object-types"],"title":"TypeScript'i Anlamak - Bölüm 3: Obje Tipleri"},{"categories":["TypeScript"],"contents":"Merhaba! Önceki yazımızda TypeScript\u0026rsquo;teki temel tipleri incelemiştik. Bugün, fonksiyonları ve TypeScript\u0026rsquo;in onları nasıl daha güçlü ve güvenli hale getirdiğini öğreneceğiz. Basit örneklerle başlayıp, adım adım daha ileri konulara geçeceğiz.\nFonksiyon Parametre Tipleri TypeScript\u0026rsquo;te fonksiyon parametrelerinin tipini belirleyebiliriz. Bu özellik, yanlış tip bir değer gönderildiğinde daha kod çalıştırılmadan hata almamızı sağlar. Basit bir örnekle başlayalım:\n// Tipli parametrelerle fonksiyon oluşturma const ogrenciyiCesaretle = (isim: string) =\u0026gt; { return `Hey, ${isim}, harika gidiyorsun!`; }; // Bu çalışır ogrenciyiCesaretle(\u0026#39;sen\u0026#39;); // Çıktı: \u0026#34;Hey, sen, harika gidiyorsun!\u0026#34; // Bu TypeScript hatası verir ogrenciyiCesaretle(85); // Hata: \u0026#39;number\u0026#39; tipi \u0026#39;string\u0026#39; tipine atanamaz Her parametreden sonra yazdığımız tip açıklaması (örneğin : string), TypeScript\u0026rsquo;e bu fonksiyonun hangi tipte değerler bekleyeceğini söyler. Bu sayede hataları daha kod yazarken yakalayabiliriz.\nÇoklu Parametreler Fonksiyonlar birden fazla parametre alabilir ve her parametrenin kendi tipini belirleyebiliriz:\nfunction kullaniciOlustur(isim: string, yas: number, aktifMi: boolean) { return { isim, yas, aktifMi, }; } // Doğru kullanım kullaniciOlustur(\u0026#39;Ahmet\u0026#39;, 25, true); // TypeScript bu hataları yakalar kullaniciOlustur(\u0026#39;Ahmet\u0026#39;, \u0026#39;25\u0026#39;, true); // Hata: yaş number olmalı kullaniciOlustur(\u0026#39;Ahmet\u0026#39;); // Hata: eksik parametreler kullaniciOlustur(\u0026#39;Ahmet\u0026#39;, 25, \u0026#39;evet\u0026#39;); // Hata: aktifMi boolean olmalı Bu örnekte kullaniciOlustur fonksiyonu üç farklı tipte parametre alıyor. TypeScript, bu parametrelerin doğru tipte ve eksiksiz gönderildiğinden emin olmamızı sağlıyor.\nFonksiyon Dönüş Tipleri TypeScript ile bir fonksiyonun hangi tipte değer döndüreceğini de belirtebiliriz. TypeScript çoğu zaman dönüş tipini otomatik olarak anlayabilse de (buna type inference denir), açıkça belirtmek kodunuzu daha okunabilir ve bakımı kolay hale getirir:\nconst sayilariTopla = (x: number, y: number): number =\u0026gt; { return x + y; }; sayilariTopla(5, 5); // Dönüş: 10 const metinBirlestir = (a: string, b: string): string =\u0026gt; { return a + \u0026#39; \u0026#39; + b; }; metinBirlestir(\u0026#39;Merhaba\u0026#39;, \u0026#39;Dünya\u0026#39;); // Dönüş: \u0026#34;Merhaba Dünya\u0026#34; Bu örneklerde parametre listesinden sonra gelen : number ve : string ifadeleri, fonksiyonların hangi tipte değer döndüreceğini belirtir. Bu sayede:\nFonksiyonun ne döndüreceği konusunda dokümentasyon sağlamış oluruz Yanlış tipte bir değer döndürmeye çalıştığımızda hemen hata alırız Fonksiyonu kullanan diğer geliştiriciler, ne bekleyeceklerini önceden bilirler void Dönüş Tipi Bazen fonksiyonlarımız herhangi bir değer döndürmez, sadece bir işlem yaparlar. TypeScript\u0026rsquo;te bunu belirtmek için void tipini kullanırız:\nconst kullaniciyiUyar = (mesaj: string): void =\u0026gt; { alert(mesaj); // Hiçbir şey döndürmüyoruz }; const logla = (data: any): void =\u0026gt; { console.log(data); // return yazmadık bile }; void dönüş tipi, fonksiyonun bir değer döndürmeyeceğini söyler. Bu özellikle önemlidir çünkü:\nKodunuzu okuyan diğer geliştiriciler fonksiyondan bir değer beklememeleri gerektiğini bilirler Yanlışlıkla bir değer döndürmeye çalışırsanız TypeScript hata verir API\u0026rsquo;lerinizi daha net ve anlaşılır hale getirir Opsiyonel Parametreler ve Varsayılan Değerler TypeScript\u0026rsquo;te parametreleri iki şekilde esnek hale getirebiliriz: opsiyonel parametreler ve varsayılan değerler.\nOpsiyonel Parametreler Bir parametrenin sonuna ? işareti koyarak o parametrenin opsiyonel olduğunu belirtiriz:\nfunction kisiSelam(isim: string, unvan?: string) { if (unvan) { return `Merhaba ${unvan} ${isim}`; } return `Merhaba ${isim}`; } kisiSelam(\u0026#39;Ahmet\u0026#39;); // Çıktı: \u0026#34;Merhaba Ahmet\u0026#34; kisiSelam(\u0026#39;Ahmet\u0026#39;, \u0026#39;Dr.\u0026#39;); // Çıktı: \u0026#34;Merhaba Dr. Ahmet\u0026#34; Varsayılan Değerler Parametrelere varsayılan değerler atayarak, değer gönderilmediğinde ne kullanılacağını belirleyebiliriz:\nfunction kahveSiparis(kahveTuru: string = \u0026#39;Americano\u0026#39;, boyut: string = \u0026#39;orta\u0026#39;, sut: boolean = false) { let siparis = `${boyut} boy ${kahveTuru}`; if (sut) siparis += \u0026#39; sütlü\u0026#39;; return siparis; } kahveSiparis(); // \u0026#34;orta boy Americano\u0026#34; kahveSiparis(\u0026#39;Latte\u0026#39;); // \u0026#34;orta boy Latte\u0026#34; kahveSiparis(\u0026#39;Espresso\u0026#39;, \u0026#39;küçük\u0026#39;); // \u0026#34;küçük boy Espresso\u0026#34; kahveSiparis(\u0026#39;Mocha\u0026#39;, \u0026#39;büyük\u0026#39;, true); // \u0026#34;büyük boy Mocha sütlü\u0026#34; Opsiyonel parametreler ve varsayılan değerler arasındaki farklar:\nOpsiyonel Parametreler (?)\nParametre gönderilmezse undefined olur Fonksiyon içinde kontrol etmeniz gerekir Daha esnek ama daha fazla kontrol gerektirir Varsayılan Değerler (= değer)\nParametre gönderilmezse belirlediğiniz değer kullanılır Ekstra kontrol gerektirmez Daha az esnek ama kullanımı daha kolay Önemli Nokta: Parametre Sırası Hem opsiyonel hem zorunlu parametreler kullanırken, zorunlu parametreler her zaman önce gelmelidir:\n// DOĞRU function dogru(zorunlu: string, opsiyonel?: string) {} // YANLIŞ - TypeScript hata verir function yanlis(opsiyonel?: string, zorunlu: string) {} // Hata! Bu kural varsayılan değerler için de geçerlidir:\n// DOĞRU function dogru2(zorunlu: string, varsayilan: string = \u0026#39;default\u0026#39;) {} // YANLIŞ function yanlis2(varsayilan: string = \u0026#39;default\u0026#39;, zorunlu: string) {} // Hata! Bu kurala uymak, kodunuzun daha mantıklı ve anlaşılır olmasını sağlar. Ayrıca JavaScript\u0026rsquo;in fonksiyon çağrılarını nasıl işlediğiyle de uyumludur.\nAnonim Fonksiyonlar ve Tip Çıkarımı TypeScript\u0026rsquo;in en güçlü özelliklerinden biri, tipleri otomatik olarak çıkarabilme yeteneğidir. Bu özellikle anonim fonksiyonlarda çok kullanışlıdır:\nconst sayilar = [1, 2, 3, 4, 5]; // TypeScript otomatik olarak \u0026#39;sayi\u0026#39; parametresinin number olduğunu anlar sayilar.forEach((sayi) =\u0026gt; { console.log(sayi.toFixed(2)); // TypeScript bunu güvenli buluyor }); // Dizi metotlarında da tip çıkarımı çalışır const kareler = sayilar.map((sayi) =\u0026gt; sayi * sayi); // kareler dizisinin tipi number[] olarak çıkarılır Tip çıkarımı kod yazarken işimizi kolaylaştırır, ancak her zaman tip belirtmemek kodunuzu daha az okunabilir hale getirebilir. Bu yüzden dengeyi iyi kurmak önemlidir.\nnever Tipi never tipi, TypeScript\u0026rsquo;te özel bir tiptir ve asla gerçekleşmeyecek durumları temsil eder. İki ana kullanım senaryosu vardır:\nSonsuz Döngüler: Asla tamamlanmayan fonksiyonlar function sonsuzdDongu(): never { while (true) { console.log(\u0026#39;Bu fonksiyon asla bitmeyecek!\u0026#39;); } } function sonsuzOzyineleme(): never { return sonsuzOzyineleme(); } Her Zaman Hata Fırlatan Fonksiyonlar: function hataFirlat(mesaj: string): never { throw new Error(mesaj); } function hataKontrol(deger: string | number) { if (typeof deger === \u0026#39;string\u0026#39;) { console.log(\u0026#39;Bu bir string:\u0026#39;, deger); } else if (typeof deger === \u0026#39;number\u0026#39;) { console.log(\u0026#39;Bu bir number:\u0026#39;, deger); } else { // Bu noktada deger tipi \u0026#39;never\u0026#39; olur // Çünkü buraya ulaşmak imkansızdır hataFirlat(\u0026#39;Bu asla olmamalı!\u0026#39;); } } never ile void arasındaki farkı anlamak önemlidir:\nvoid: Fonksiyon bir değer döndürmez never: Fonksiyon asla tamamlanmaz veya her zaman bir hata fırlatır Fonksiyon Aşırı Yüklemesi (Function Overloads) TypeScript\u0026rsquo;te bir fonksiyonu farklı parametre tipleriyle kullanmak istediğimizde fonksiyon aşırı yüklemesini kullanabiliriz:\n// Aşırı yükleme imzaları function birlestir(a: string, b: string): string; function birlestir(a: number, b: number): number; // Gerçek implementasyon function birlestir(a: string | number, b: string | number): string | number { if (typeof a === \u0026#39;string\u0026#39; \u0026amp;\u0026amp; typeof b === \u0026#39;string\u0026#39;) { return a.concat(b); } if (typeof a === \u0026#39;number\u0026#39; \u0026amp;\u0026amp; typeof b === \u0026#39;number\u0026#39;) { return a + b; } throw new Error(\u0026#39;Parametreler aynı tipte olmalıdır!\u0026#39;); } console.log(birlestir(\u0026#39;Merhaba, \u0026#39;, \u0026#39;Dünya\u0026#39;)); // \u0026#34;Merhaba, Dünya\u0026#34; console.log(birlestir(5, 10)); // 15 // birlestir(\u0026#34;5\u0026#34;, 10); // Hata! Bu kombinasyon tanımlı değil Fonksiyon aşırı yüklemesi sayesinde:\nAynı fonksiyonu farklı parametre tipleriyle kullanabiliriz Her kombinasyon için doğru dönüş tipini belirleyebiliriz TypeScript hangi kombinasyonların geçerli olduğunu kontrol eder En İyi Uygulamalar TypeScript fonksiyonları yazarken izlemeniz gereken bazı önemli pratikler vardır. İşte bu pratikler ve nedenleri:\nHer Zaman Parametre Tiplerini Belirtin\n// KÖTÜ function kotu(isim) { return `Merhaba ${isim}`; } // İYİ function iyi(isim: string): string { return `Merhaba ${isim}`; } Tip belirtmek kodunuzu daha okunabilir yapar ve hataları önler.\nDönüş Tiplerini Düşünün\n// Otomatik çıkarım bazen yeterlidir const topla = (a: number, b: number) =\u0026gt; a + b; // Ama karmaşık fonksiyonlarda dönüş tipini belirtmek daha iyidir function veriIsle(data: any[]): ProcessedData { // Karmaşık işlemler... return islenmisSonuc; } Opsiyonel Parametreleri Sona Koyun\n// KÖTÜ function kotu(opsiyonel?: string, zorunlu: string) {} // İYİ function iyi(zorunlu: string, opsiyonel?: string) {} any Tipinden Kaçının\n// KÖTÜ function herhangiVeri(data: any) { return data.birsey(); // Tehlikeli! } // İYİ function tipliVeri\u0026lt;T\u0026gt;(data: T) { // Tip güvenli işlemler } Fonksiyon Dokümantasyonu Yazın\n/** * Verilen sayıları toplar ve sonucu döndürür * @param sayilar - Toplanacak sayı dizisi * @returns Toplam değer */ function topla(...sayilar: number[]): number { return sayilar.reduce((a, b) =\u0026gt; a + b, 0); } Hızlı Başvuru İşte TypeScript\u0026rsquo;te en sık kullanılan fonksiyon yapılarının hızlı bir özeti:\n1. Temel Fonksiyon Tanımlamaları // Normal fonksiyon function selamla(isim: string): string { return `Merhaba ${isim}`; } // Ok fonksiyonu const selamla2 = (isim: string): string =\u0026gt; `Merhaba ${isim}`; 2. Parametre Çeşitleri // Opsiyonel parametre function log(mesaj: string, seviye?: string) {} // Varsayılan değerli parametre function baglan(url: string = \u0026#39;localhost\u0026#39;) {} // Rest parametresi function toplam(...sayilar: number[]): number { return sayilar.reduce((a, b) =\u0026gt; a + b, 0); } 3. Dönüş Tipleri // Değer döndüren function topla(a: number, b: number): number { return a + b; } // Void dönüş function logla(mesaj: string): void { console.log(mesaj); } // Never dönüş function hataFirlat(mesaj: string): never { throw new Error(mesaj); } 4. Fonksiyon Tipleri // Fonksiyon tipi tanımlama type MatematikIslemi = (a: number, b: number) =\u0026gt; number; // Fonksiyon tipi kullanma const toplama: MatematikIslemi = (a, b) =\u0026gt; a + b; const cikarma: MatematikIslemi = (a, b) =\u0026gt; a - b; Sonuç TypeScript\u0026rsquo;in fonksiyonlar için sunduğu tip sistemi, JavaScript geliştirmede çok değerli bir araçtır. Tip güvenliği sayesinde:\nHataları erken yakalarsınız Kodunuz daha okunabilir olur IDE desteği daha iyi çalışır Refactoring yapmak kolaylaşır Bu özelliklerin hepsi bir araya geldiğinde, daha güvenilir ve bakımı kolay uygulamalar geliştirmenize yardımcı olur.\n","lang":"tr","permalink":"/tr/blog/typescript-serisi/typescripti-anlamak-bolum2/","summary":"Bu makalede, TypeScript fonksiyonlarını detaylı bir şekilde inceleyeceğiz. Parametre tipleri, dönüş tipleri ve TypeScript\u0026rsquo;i benzersiz ve güçlü kılan özel fonksiyon tiplerini ele alacağız.","tags":["typescript","javascript","fonksiyonlar"],"title":"TypeScript'i Anlamak - Bölüm 2: Fonksiyonlar"},{"categories":["TypeScript"],"contents":"Merhaba! Yakın zamanda TypeScript\u0026rsquo;i derinlemesine öğrenmeye başlayan bir geliştirici olarak, bu öğrenme yolculuğumu sizlerle paylaşmak istiyorum. Bu seride, TypeScript\u0026rsquo;i en temelinden başlayarak inceleyeceğiz, neden var olduğunu ve JavaScript geliştirme deneyimimizi nasıl daha iyi hale getirebileceğini anlayacağız.\nTypeScript Nedir? TypeScript, en basit tanımıyla tip desteği eklenmiş JavaScript\u0026rsquo;tir. Ancak bu tanım, TypeScript\u0026rsquo;in tüm özelliklerini karşılamıyor. Microsoft tarafından geliştirilen TypeScript, JavaScript\u0026rsquo;e statik tip desteği ekleyen bir üst kümedir (superset). Bu, tüm geçerli JavaScript kodunun aynı zamanda geçerli TypeScript kodu olduğu, ancak TypeScript\u0026rsquo;in daha sağlam ve sürdürülebilir kod yazmamıza yardımcı olan ek özellikler sunduğu anlamına gelir.\nTypeScript\u0026rsquo;in JavaScript\u0026rsquo;ten nasıl farklılaştığına dair basit bir örnek:\n// JavaScript let greeting = \u0026#34;Hello\u0026#34;; greeting = 42; // JavaScript\u0026#39;te çalışır, ancak sorunlara yol açabilir // TypeScript let greeting: string = \u0026#34;Hello\u0026#34;; greeting = 42; // Hata: \u0026#39;number\u0026#39; tipi \u0026#39;string\u0026#39; tipine atanamaz Neden Tipler? TypeScript\u0026rsquo;in tip sistemi birkaç önemli avantaj sağlar:\nHataları bulmamıza yardımcı olur: Tip sistemi, kodumuz çalışmadan önce hataları yakalayabilir Kodumuzu yazarken analiz eder: Editörümüzde gerçek zamanlı geri bildirim sağlar Sadece geliştirme aşamasında vardır: Tipler, kod JavaScript\u0026rsquo;e derlendiğinde kaldırılır Bu özellikler, TypeScript\u0026rsquo;i özellikle büyük kod tabanları ve takım çalışmaları için değerli kılar.\nTypeScript\u0026rsquo;te Temel Tipler Şimdi TypeScript\u0026rsquo;teki temel tipleri inceleyelim:\n1. String (Metin) String\u0026rsquo;ler TypeScript\u0026rsquo;te metin değerlerini temsil eder. İşte nasıl kullanıldıklarına dair bir örnek:\n// String değişkeni tanımlama let myString: string = \u0026#34;Merhaba!!!\u0026#34;; // Farklı bir tipe ATANMAZ myString = 100; // Hata // Aynı tipte bir değere ATANABİLİR myString = \u0026#34;Yeni metin!!!\u0026#34;; // Çalışır Bu örnekte, myString\u0026lsquo;i bir string olarak tanımladıktan sonra, TypeScript sadece string değerler atayabilmemizi sağlar.\n2. Number (Sayı) TypeScript, diğer dillere göre sayı yönetimini basitleştirir:\n// Sayı değişkeni tanımlama let myNumber: number = 42; // Farklı bir tipe ATANMAZ myNumber = \u0026#34;Ben bir string\u0026#39;im!\u0026#34;; // Hata // Aynı tipte bir değere ATANABİLİR myNumber = 60; // Çalışır Bazı programlama dillerinin aksine (float, int vb. gibi birden çok sayı tipi olan), TypeScript (JavaScript gibi) tüm sayısal değerler için sadece number tipini kullanır.\n3. Boolean (Mantıksal) Boolean değerler doğru/yanlış durumlarını temsil eder:\n// Boolean değişkeni tanımlama const myBoolean: boolean = true; // Farklı bir tipe ATANMAZ myBoolean = 87; // Hata // Aynı tipte bir değere ATANABİLİR myBoolean = false; // Çalışır Tip Çıkarımı (Type Inference) TypeScript\u0026rsquo;in en güçlü özelliklerinden biri, tipleri otomatik olarak çıkarabilme yeteneğidir. Bu, her zaman tipleri açıkça belirtmemiz gerekmediği anlamına gelir:\n// Bir değişkeni tip belirtmeden değer ile tanımlama let x = 27; x = \u0026#39;Yirmi yedi\u0026#39;; // Hata - \u0026#39;string\u0026#39; tipi \u0026#39;number\u0026#39; tipine atanamaz Bu örnekte TypeScript, x değişkeninin tipini ilk değerine bakarak otomatik olarak number olarak belirler. Bu özellik, tip güvenliğini korurken daha az kod yazmamızı sağlar.\n\u0026lsquo;any\u0026rsquo; Tipi Bazen katı tip kontrolünden daha fazla esnekliğe ihtiyaç duyarız. İşte bu noktada any tipi devreye girer:\n// \u0026#39;any\u0026#39; tipi ile değişken tanımlama const myComplicatedData: any = \u0026#34;Karmaşık olacağım!\u0026#34;; // Herhangi bir tipe ATANABİLİR - tip kontrolleri kapalı! myComplicatedData = 87; // Çalışır myComplicatedData = \u0026#39;abc...\u0026#39;; // Çalışır myComplicatedData = true; // Çalışır \u0026lsquo;any\u0026rsquo; Ne Zaman Kullanılmalı? Her ne kadar any kullanımından genellikle kaçınmamız gerekse de, meşru kullanım durumları vardır. İşte gerçek bir senaryo:\n// Harici API verisiyle çalışırken function handleAPIResponse(response: any) { // API yanıtının tam yapısını bilmeyebiliriz // özellikle üçüncü taraf API\u0026#39;lerle çalışırken console.log(response.data); // Çalışır console.log(response.status); // Çalışır console.log(response.someField); // Çalışır } // Eski JavaScript koduyla çalışırken declare const oldJavaScriptLibrary: any; // Kütüphaneyi TypeScript hataları olmadan kullanabiliriz oldJavaScriptLibrary.someOldMethod(); any tipinin gerekli olabileceği yaygın senaryolar:\nYanıt yapısının bilinmediği veya dinamik olduğu harici API\u0026rsquo;lerle entegrasyon sırasında JavaScript\u0026rsquo;ten TypeScript\u0026rsquo;e geçiş sürecinde (geçici kullanım) TypeScript tip tanımlamaları olmayan üçüncü taraf kütüphanelerle çalışırken Tipin tahmin edilemeyeceği gerçekten dinamik içeriklerle uğraşırken Ancak unutmayın ki any kullanmak, TypeScript\u0026rsquo;in tip kontrolü avantajlarını ortadan kaldırır. Son çare olarak kullanılmalı ve mümkün olduğunda uygun tipler tanımlanmalıdır.\nPratik Örnek Öğrendiklerimizi birleştiren pratik bir örneğe bakalım:\n// Farklı tiplerle değişkenler oluşturma let kullaniciAdi: string = \u0026#34;Ahmet Yılmaz\u0026#34;; let yas: number = 30; let girisYapildi: boolean = true; // Tip çıkarımı kullanma let sonGirisTarihi = new Date(); // TypeScript Date tipini çıkarır let girisAdedi = 5; // TypeScript number tipini çıkarır // Bu değişkenlerle çalışma function kullaniciBilgileriniGoster() { console.log(`Kullanıcı: ${kullaniciAdi}`); console.log(`Yaş: ${yas}`); console.log(`Giriş Yapıldı: ${girisYapildi}`); console.log(`Son Giriş: ${sonGirisTarihi}`); console.log(`Giriş Sayısı: ${girisAdedi}`); } // TypeScript bu hataları yakalar: kullaniciAdi = 123; // Hata: \u0026#39;number\u0026#39; tipi \u0026#39;string\u0026#39; tipine atanamaz yas = \u0026#34;otuz\u0026#34;; // Hata: \u0026#39;string\u0026#39; tipi \u0026#39;number\u0026#39; tipine atanamaz girisYapildi = \u0026#34;evet\u0026#34;; // Hata: \u0026#39;string\u0026#39; tipi \u0026#39;boolean\u0026#39; tipine atanamaz Bu örnek, TypeScript\u0026rsquo;in gerçek bir uygulama senaryosunda tip güvenliğini nasıl sağladığını ve yaygın tip hatalarını daha oluşmadan nasıl engellediğini gösteriyor.\nBest Practices (En İyi Uygulamalar) Mümkün Olduğunda Tip Çıkarımını Kullanın\nTypeScript tipi doğru çıkarabiliyorsa, tip açıklamaları eklemeyin Bu, kodunuzu daha temiz ve bakımı daha kolay hale getirir \u0026lsquo;any\u0026rsquo; Kullanımından Kaçının\nany kullanmak, TypeScript\u0026rsquo;in tüm avantajlarını ortadan kaldırır Sadece gerçekten gerektiğinde kullanın Gerektiğinde Açık Olun\nTypeScript\u0026rsquo;in çıkarımı yeterli olmadığında tip açıklamaları ekleyin Bu, kod okunabilirliğini artırır ve hataları yakalamaya yardımcı olur Sonuç Bu TypeScript\u0026rsquo;e giriş, tipler ve tip çıkarımının temellerini kapsıyor. TypeScript, JavaScript\u0026rsquo;e güçlü bir tip sistemi ekleyerek daha güvenilir kod yazmamıza yardımcı olur. Başlangıçta ekstra iş gibi görünse de, projeleriniz büyüdükçe ve karmaşıklaştıkça faydaları net bir şekilde ortaya çıkar.\nSerinin 2. bölümünde daha ileri TypeScript konularını inceleyeceğiz. Takipte kalın!\n","lang":"tr","permalink":"/tr/blog/typescript-serisi/typescripti-anlamak-bolum1/","summary":"TypeScript, JavaScript\u0026rsquo;e statik tip desteği ekleyen güçlü bir üst kümedir. Bu makale serisinde, TypeScript\u0026rsquo;i temellerden ileri seviyeye kadar keşfedeceğiz ve temel tipler ve tip çıkarımı ile başlayacağız.","tags":["typescript","javascript"],"title":"TypeScript'i Anlamak - Bölüm 1: Temeller"},{"categories":["Linux"],"contents":"Herkese merhaba! Bu makale serisinde, her geliştiricinin bilmesi gereken en sık kullanılan Linux komutlarını açıklayacağım. Bu komutlar, Linux sisteminizi etkili bir şekilde yönetmek ve terminaldeki verimliliğinizi artırmak için gereklidir.\nNeden Linux Komutlarını Öğrenmeliyiz? Linux komutları, terminal aracılığıyla işletim sistemimizle etkileşim kurmamızı sağlayan temel araçlardır. Bu komutları anlamak önemlidir çünkü:\nSistem üzerinde daha fazla kontrol sağlarlar Genellikle grafiksel arayüz kullanmaktan daha hızlıdırlar Birçok sunucu Linux üzerinde çalışır ve grafiksel arayüzleri yoktur Otomasyon ve betik yazımı için gereklidirler DevOps ve sistem yönetiminde yaygın olarak kullanılırlar En Çok Kullanılan Linux Komutları En sık kullanılan 20 Linux komutunu inceleyelim:\nls (Listele) Mevcut dizindeki dosya ve klasörleri listeler Sık kullanılan seçenekler: ls -l: Uzun format listeleme ls -a: Gizli dosyaları göster ls -h: İnsan tarafından okunabilir dosya boyutları user@linux:~$ ls -la total 32 drwxr-xr-x 2 user user 4096 Feb 8 10:00 . drwxr-xr-x 20 user user 4096 Feb 8 10:00 .. -rw-r--r-- 1 user user 220 Feb 8 10:00 .bash_profile -rw-r--r-- 1 user user 3526 Feb 8 10:00 .bashrc drwxr-xr-x 2 user user 4096 Feb 8 10:00 Documents cd (Dizin Değiştir) Bulunduğunuz dizini değiştirir Kullanım örnekleri: cd /path/to/directory: Belirli bir dizine git cd ..: Bir üst dizine git cd ~: Ana dizine git user@linux:~$ pwd /home/user user@linux:~$ cd Documents user@linux:~/Documents$ cd .. user@linux:~$ cd ~ pwd (Çalışma Dizinini Yazdır) Mevcut dizin yolunu gösterir Dosya sisteminde nerede olduğunuzu doğrulamak için kullanışlıdır user@linux:~$ pwd /home/user/Documents/projects mkdir (Dizin Oluştur) Yeni dizinler oluşturur Seçenekler: mkdir -p: Eğer yoksa üst dizinleri oluşturur user@linux:~$ mkdir -p projects/new-project user@linux:~$ ls -l projects/ total 4 drwxr-xr-x 2 user user 4096 Feb 8 10:00 new-project rm (Sil) Dosya ve dizinleri siler Önemli seçenekler: rm -r: Dizinleri özyinelemeli olarak sil rm -f: Onay istemeden zorla sil user@linux:~$ ls file1.txt file2.txt test_dir user@linux:~$ rm file1.txt user@linux:~$ rm -r test_dir user@linux:~$ ls file2.txt cp (Kopyala) Dosya ve dizinleri kopyalar Yaygın kullanım: cp file1 file2: file1\u0026rsquo;i file2\u0026rsquo;ye kopyala cp -r dir1 dir2: Dizini özyinelemeli olarak kopyala user@linux:~$ cp file1.txt backup.txt user@linux:~$ cp -r projects/ projects_backup/ user@linux:~$ ls backup.txt file1.txt projects projects_backup mv (Taşı) Dosya ve dizinleri taşır veya yeniden adlandırır Örnekler: mv old.txt new.txt: Dosyayı yeniden adlandır mv file /path/to/dir: Dosyayı dizine taşı user@linux:~$ ls old.txt documents/ user@linux:~$ mv old.txt new.txt user@linux:~$ mv new.txt documents/ user@linux:~$ ls documents/ new.txt cat (Birleştir) Dosya içeriğini görüntüler Ayrıca dosyaları birleştirmek için kullanılır user@linux:~$ cat file.txt Bu file.txt dosyasının içeriğidir user@linux:~$ cat file1.txt file2.txt \u0026gt; combined.txt user@linux:~$ cat combined.txt file1\u0026#39;den içerik file2\u0026#39;den içerik grep (Global Regular Expression Print) Dosyalarda kalıp arar Kullanışlı seçenekler: grep -i: Büyük/küçük harf duyarsız arama grep -r: Özyinelemeli arama user@linux:~$ grep -r \u0026#34;TODO\u0026#34; . ./src/app.js:// TODO: Hata yönetimi eklenecek ./docs/readme.md:TODO: Dokümantasyon güncellenecek user@linux:~$ grep -i \u0026#34;hata\u0026#34; log.txt Hata: Bağlantı başarısız hata: bağlanılamadı HATA: Sistem hatası chmod (İzinleri Değiştir) Dosya izinlerini değiştirir Format: chmod [seçenekler] mod dosya user@linux:~$ ls -l script.sh -rw-r--r-- 1 user user 256 Feb 8 10:00 script.sh user@linux:~$ chmod +x script.sh user@linux:~$ ls -l script.sh -rwxr-xr-x 1 user user 256 Feb 8 10:00 script.sh sudo (Süper Kullanıcı Olarak Yap) Komutları süper kullanıcı yetkileriyle çalıştırır Sistem yönetimi görevleri için önemlidir user@linux:~$ apt update E: Could not open lock file - open (13: Permission denied) user@linux:~$ sudo apt update [sudo] password for user: Reading package lists... Done Building dependency tree... Done top Çalışan işlemleri ve sistem kaynaklarını gösterir Etkileşimli işlem görüntüleyici user@linux:~$ top top - 10:00:00 up 2 days, 3:45, 1 user, load average: 0.52, 0.58, 0.59 Tasks: 180 total, 1 running, 179 sleeping, 0 stopped, 0 zombie %Cpu(s): 5.9 us, 3.1 sy, 0.0 ni, 90.6 id, 0.4 wa, 0.0 hi, 0.0 si MiB Mem : 7861.1 total, 2457.2 free, 3245.5 used, 2158.4 buff/cache ps (İşlem Durumu) Çalışan işlemleri görüntüler Yaygın seçenekler: ps aux: Tüm işlemleri göster user@linux:~$ ps aux USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND user 2345 0.0 0.1 169512 3252 pts/0 Ss 09:30 0:00 bash user 2789 0.0 0.2 170284 6432 pts/0 R+ 10:00 0:00 ps aux df (Disk Boş Alan) Disk alanı kullanımını gösterir Kullanışlı seçenekler: df -h: İnsan tarafından okunabilir boyutlar user@linux:~$ df -h Filesystem Size Used Avail Use% Mounted on /dev/sda1 234G 67G 156G 31% / tmpfs 3.9G 0 3.9G 0% /tmp /dev/sda2 100G 45G 55G 45% /home du (Disk Kullanımı) Dizin alan kullanımını gösterir Yaygın kullanım: du -sh *: Mevcut dizin içeriğinin boyutu user@linux:~$ du -sh * 156M Documents 1.2G Downloads 42M Pictures 890M projects tar Dosya ve dizinleri arşivler Yaygın işlemler: tar -czf: Arşiv oluştur tar -xzf: Arşivi çıkart user@linux:~$ tar -czf archive.tar.gz Documents/ user@linux:~$ ls -lh archive.tar.gz -rw-r--r-- 1 user user 145M Feb 8 10:00 archive.tar.gz user@linux:~$ tar -xzf archive.tar.gz find Dizin hiyerarşisinde dosya arar Örnekler: find . -name \u0026quot;*.txt\u0026quot;: Tüm .txt dosyalarını bul user@linux:~$ find . -name \u0026#34;*.txt\u0026#34; ./documents/notes.txt ./projects/readme.txt ./backup/old.txt user@linux:~$ find . -type d -name \u0026#34;test\u0026#34; ./projects/test ./src/test wget İnternetten dosya indirir Kullanışlı seçenekler: wget -c: Yarıda kalan indirmeye devam et user@linux:~$ wget https://example.com/file.zip --2025-02-08 10:00:00-- https://example.com/file.zip Resolving example.com... 93.184.216.34 Connecting to example.com... connected. HTTP request sent, awaiting response... 200 OK Length: 52890112 (50M) [application/zip] Saving to: \u0026#39;file.zip\u0026#39; systemctl Systemd sistem ve servis yöneticisini kontrol eder Yaygın kullanımlar: systemctl start/stop/restart/status service user@linux:~$ sudo systemctl status nginx ● nginx.service - Yüksek performanslı web sunucusu ve ters proxy sunucusu Loaded: loaded (/lib/systemd/system/nginx.service; enabled; vendor preset: enabled) Active: active (running) since Thu 2025-02-08 09:30:12 UTC; 30min ago history Komut geçmişini gösterir Kullanışlı özellikler: !n: n numaralı komutu çalıştır !!: Son komutu çalıştır user@linux:~$ history 1 pwd 2 cd Documents 3 ls -la 4 mkdir projects 5 cd projects user@linux:~$ !3 ls -la total 32 drwxr-xr-x 2 user user 4096 Feb 8 10:00 . drwxr-xr-x 5 user user 4096 Feb 8 10:00 .. En İyi Uygulamalar Her Zaman Tab Tamamlama Kullanın\nZaman kazandırır ve yazım hatalarını önler Mevcut seçenekleri gösterir Komutları Çalıştırmadan Önce Kontrol Edin\n--help veya man komutunu kullanın rm ve sudo ile ekstra dikkatli olun Komut Geçmişini Kullanın\nÖnceki komutlara göz atmak için yukarı ok tuşuna basın Geriye dönük arama için Ctrl+R kullanın Takma Adlar Oluşturun\nSık kullanılan komutları takma ad olarak kaydedin Bunları .bashrc veya .zshrc dosyanıza ekleyin Sonuç Bu 20 komut, Linux komut satırı kullanımının temelini oluşturur. Bunları anlamak ve ustalaşmak, Linux sistemleriyle çalışırken verimliliğinizi önemli ölçüde artıracaktır. Bu serinin bir sonraki bölümünde, sistem yönetimi ve otomasyon için daha gelişmiş komutları ve teknikleri inceleyeceğiz.\nBu komutlarda ustalaşmanın anahtarının pratik yapmak olduğunu unutmayın. Günlük çalışmalarınızda bunları düzenli olarak kullanmaya çalışın ve güvenli bir ortamda denemekten çekinmeyin.\nDaha gelişmiş Linux komutlarını ele alacağımız 2. Bölüm için takipte kalın!\n","lang":"tr","permalink":"/tr/blog/linux/linux-temel-komutlar%C4%B1/","summary":"Bu makale serisinde, her geliştiricinin bilmesi gereken en sık kullanılan Linux komutlarını inceleyeceğiz. İlk bölümde, Linux sisteminizi etkili bir şekilde yönetmenize yardımcı olacak 20 temel komutu ele alacağız.","tags":["linux","komutlar"],"title":"Linux Temel Komutları - Bölüm 1"},{"categories":["Node.js"],"contents":"Herkese merhabalar! Bu yazımda sizlere Node.js için hızlı ve düşük kaynak tüketen bir web framework olan Fastify\u0026rsquo;ı anlatacağım. Birlikte basit bir TODO API\u0026rsquo;si oluşturacağız ve Fastify\u0026rsquo;ın özelliklerinin geliştirme sürecinizi nasıl daha verimli hale getirebileceğini açıklayacağım.\nBu projenin tüm kaynak koduna GitHub üzerinden ulaşabilirsiniz: fastify-nodejs-restful-api\nFastify Nedir ve Neden Kullanmalıyız? Fastify, Node.js için geliştirilmiş, yüksek performansa ve düşük kaynak kullanımına odaklanan modern bir web framework\u0026rsquo;tür. Node.js geliştiricilerinin çoğu Express.js\u0026rsquo;e aşina olsa da, Fastify bazı önemli avantajlar sunuyor:\nExpress\u0026rsquo;e göre 2 kata kadar daha hızlı Dahili şema doğrulama sistemi Otomatik Swagger dokümantasyonu Plugin tabanlı mimari Projemizi Oluşturalım Öncelikle projemizi kuralım. İlk olarak bazı bağımlılıkları yüklememiz gerekiyor. Yeni bir dizin oluşturun ve şu komutları çalıştırın:\nmkdir fastify-todo-api cd fastify-todo-api npm init -y Şimdi ihtiyacımız olan paketleri yükleyelim:\n{ \u0026#34;dependencies\u0026#34;: { \u0026#34;fastify\u0026#34;: \u0026#34;^3.29.0\u0026#34;, \u0026#34;fastify-swagger\u0026#34;: \u0026#34;^5.2.0\u0026#34;, \u0026#34;uuid\u0026#34;: \u0026#34;^8.3.2\u0026#34; }, \u0026#34;devDependencies\u0026#34;: { \u0026#34;nodemon\u0026#34;: \u0026#34;^2.0.16\u0026#34; } } Proje Yapısı Kodlamaya başlamadan önce proje yapımızı düzenleyelim. Temiz ve bakımı kolay bir yaklaşım izleyeceğiz:\nfastify-todo-api/ ├── app.js # Ana sunucu dosyası ├── items.js # Veri deposu ├── routes/ │ └── todoRouter.js # Route tanımlamaları └── controllers/ └── todoController.js # İstek işleyicileri İlk Fastify Sunucumuzu Oluşturalım Ana sunucu dosyamızla (app.js) başlayalım. İşte temel bir Fastify sunucusunu nasıl kurarız:\nconst fastify = require(\u0026#39;fastify\u0026#39;)({ logger: true }); // Swagger dokümantasyonunu ayarlıyoruz fastify.register(require(\u0026#39;fastify-swagger\u0026#39;), { exposeRoute: true, routePrefix: \u0026#39;/docs\u0026#39;, swagger: { info: { title: \u0026#39;fastify-api\u0026#39; }, }, }); // Route\u0026#39;larımızı kaydediyoruz fastify.register(require(\u0026#39;./routes/todoRouter\u0026#39;)); const PORT = 5000; const start = async () =\u0026gt; { try { await fastify.listen(PORT); } catch (error) { fastify.log.error(error); process.exit(1); } }; start(); Bu kodda neler oluyor?\nLoglama özelliği etkin bir Fastify örneği oluşturuyoruz Swagger dokümantasyonunu ayarlıyoruz (/docs adresinden erişilebilir) Route\u0026rsquo;larımızı Fastify\u0026rsquo;ın plugin sistemi ile kaydediyoruz Sunucuyu 5000 portunda başlatıyoruz Fastify\u0026rsquo;ın Şema Doğrulama Sistemini Anlayalım Fastify\u0026rsquo;ın en güçlü özelliklerinden biri şema doğrulama sistemidir. todoRouter.js dosyasında nasıl kullanacağımıza bakalım:\n// Önce bir TODO öğesinin nasıl görüneceğini tanımlıyoruz const Item = { type: \u0026#39;object\u0026#39;, properties: { id: { type: \u0026#39;string\u0026#39; }, name: { type: \u0026#39;string\u0026#39; }, }, }; // Sonra endpoint\u0026#39;lerimiz için şemalar oluşturuyoruz const getItemsOpts = { schema: { response: { 200: { type: \u0026#39;array\u0026#39;, items: Item, }, }, }, handler: getItems, }; Bu neden özel?\nFastify otomatik olarak tüm gelen ve giden verileri doğrular Bu şemalardan Swagger dokümantasyonu oluşturur Serileştirmeyi optimize ederek performansı artırır Hataları handler\u0026rsquo;lara ulaşmadan yakalar Controller\u0026rsquo;larımızı Oluşturalım Şimdi todoController.js dosyasında istekleri nasıl işleyeceğimize bakalım:\nlet items = require(\u0026#39;../items\u0026#39;); const { v4: uuidv4 } = require(\u0026#39;uuid\u0026#39;); // Tüm öğeleri getir const getItems = (req, reply) =\u0026gt; { reply.send(items); }; // Yeni öğe oluştur const addItem = (req, reply) =\u0026gt; { const { name } = req.body; const item = { id: uuidv4(), name, }; items = [...items, item]; reply.code(201).send(item); }; Fastify\u0026rsquo;ın yanıt işlemeyi nasıl kolaylaştırdığına dikkat edin:\nContent-Type başlıklarını manuel ayarlamaya gerek yok Durum kodları ve yanıt gönderme için method chaining Otomatik yanıt serileştirme API\u0026rsquo;mizi Test Edelim Her şeyi ayarladığımıza göre, API\u0026rsquo;mizi test edelim. curl veya herhangi bir API test aracı kullanabilirsiniz:\n# Tüm öğeleri al curl http://localhost:5000/items # Yeni öğe oluştur curl -X POST \\ http://localhost:5000/items \\ -H \u0026#39;Content-Type: application/json\u0026#39; \\ -d \u0026#39;{\u0026#34;name\u0026#34;:\u0026#34;Fastify Öğren\u0026#34;}\u0026#39; Bilmeniz Gereken Performans Özellikleri Fastify tesadüfen hızlı değil. İşte neden bu kadar iyi performans gösteriyor:\nŞema Tabanlı Serileştirme\nDaha hızlı doğrulama için şemaları önceden derler JSON serileştirmeyi optimize eder İşlem yükünü azaltır Verimli Yönlendirme\nRoute eşleştirme için radix tree kullanır Regex tabanlı yönlendirmeden daha hızlıdır Optimize edilmiş parametre işleme Hafif Çekirdek\nMinimum temel yük Özellik eklemek için plugin sistemi Verimli bellek kullanımı Önerdiğim En İyi Uygulamalar Fastify ile çalıştıktan sonra, işime yarayan bazı pratikler:\nHer Zaman Şema Kullanın\nfastify.get(\u0026#39;/items\u0026#39;, { schema: { response: { 200: itemSchema } } }) Plugin\u0026rsquo;lerle Organize Edin\nfastify.register(require(\u0026#39;./routes/items\u0026#39;)) fastify.register(require(\u0026#39;./routes/users\u0026#39;)) Hataları Düzgün Yönetin\nfastify.setErrorHandler(function (error, request, reply) { reply.status(error.statusCode || 500).send({error: error.message}) }) Sonuç Fastify, yüksek performanslı Node.js API\u0026rsquo;leri oluşturmak için mükemmel bir temel sağlıyor. Şema doğrulama ve swagger dokümantasyonu gibi dahili özellikleri, onu modern web uygulamaları için harika bir seçim haline getiriyor. Gelecek yazılarımda, daha gelişmiş Fastify özelliklerini ve bunları production ortamında nasıl etkili bir şekilde kullanabileceğimizi anlatacağım. Okuduğunuz için teşekkürler!\nTüm bu özellikler hakkında daha detaylı bilgi için Fastify dokümantasyonunu incelemeyi unutmayın.\n","lang":"tr","permalink":"/tr/blog/fastify-ile-rest-api-olusturma/","summary":"Fastify, Node.js için yüksek performans ve düşük kaynak tüketimi sağlamaya odaklanan modern bir web framework\u0026rsquo;tür. Bu yazıda Fastify\u0026rsquo;ın ne olduğunu, nasıl kullanıldığını ve en iyi uygulama önerilerini detaylı olarak anlatacağım.","tags":["nodejs","fastify"],"title":"Fastify ile RESTful API Oluşturma"},{"categories":["Git"],"contents":"\nMerhaba. Bu makalede versiyon kontrol sistemlerinden kısaca bahsedip, Git Flow\u0026rsquo;un ne olduğunu ve nasıl kullanıldığını detaylı olarak anlatacağım. Versiyon kontrol sistemleri, yazılım geliştirme süreçlerinde kod versiyonlarını takip etmek ve yönetmek için kullanılan önemli araçlardır. Git Flow ise bu versiyon kontrol sistemini daha etkili kullanmamızı sağlayan bir dallanma modelidir.\nVersiyon Kontrol Sistemi Nedir? Versiyon kontrol sistemi, bir veya daha fazla dosya, belge (yazılım projesi, ofis belgeleri vb.) üzerinde yaptığımız değişiklikleri adım adım kaydeden, daha sonra belirli bir versiyona geri dönmemizi sağlayan ve istenirse bunu çevrimiçi bir depoda saklayıp yönetmemize olanak tanıyan bir sistemdir. Git, SVN, BitKeeper ve Mercurial versiyon kontrol sistemlerine örnek olarak verilebilir.\nNeden Versiyon Kontrol Sistemleri Kullanırız? Her dosya için uzun vadeli bir değişiklik geçmişi tutulur.\nBu, dosya üzerinde yıllar içinde birden fazla kişi tarafından yapılan her değişikliğin takip edilmesi anlamına gelir. Bu sayede eski ve yeni kodumuzu karşılaştırarak bulunduğumuz noktaya nasıl geldiğimizi anlayabiliriz. Takım üyelerinin aynı kod üzerinde eş zamanlı çalışmasına olanak tanır.\nYazılım üzerinde farklı çalışmalar yürütmek için alt versiyonlar oluşturmak ve daha sonra ana yazılıma entegre etmek mümkündür. Yazılıma yapılan her değişikliğin takip edilmesini ve proje yönetimiyle ilişkilendirilmesini sağlar.\nYazılım sorunlarının versiyonlarla ilişkilendirilmesini ve takibini sağlar. Projede hatalarla karşılaştığımızda eski kod kayıtlarına dönmemizi sağlar.\nVersiyon Kontrol Sistemleri Yerel VKS: En eski versiyon kontrol sistemi yaklaşımıdır. Projemiz ve yaptığımız değişiklikler kullanıcı makinesindeki bir veritabanında saklanır. Her commit bir versiyon olarak saklanır ve her versiyon commit\u0026rsquo;e bir hash değeri atanarak ayırt edilir. Ayrıca versiyon görüntüleme özelliği sunar. Ancak bu sistemde sadece bir kullanıcı etkin olarak çalışabilir.\nMerkezi VKS: Birden fazla kişinin bir proje üzerinde etkin çalışabilmesi için oluşturulmuş bir versiyonlama sistemidir. CVS ve SVN merkezi versiyon kontrol sistemleridir. Bu sistemde proje paylaşılan bir depoda tutulur ve birden fazla geliştirici aynı depo üzerinde checkout ve commit işlemleri gerçekleştirir. Bu yöntem herkesin projeye katkıda bulunmasına olanak sağlarken, bazı ciddi sorunları vardır. Tek merkezi sunucu 1 saat çökerse, kullanıcılar o bir saat boyunca çalışmalarını kaydedemez veya projelerinin versiyonlanmış kopyalarına erişemezler.\nDağıtık VKS: Merkezi versiyon sistemlerinin, geliştiricilerin çevrimdışı çalışamaması ve deponun zarar görmesi durumunda kurtarmanın zor olması gibi kısıtlamalarından dolayı oluşturulmuş bir versiyon sistemidir. Git, Mercurial ve BitKeeper dağıtık versiyon sistemlerine örnektir. Bu sistemlerde merkezi bir depo yoktur ve proje üzerinde çalışan her makine projenin bir kopyasını kendi yerel bilgisayarında tutar. Geliştiriciler proje üzerinde değişiklik yapmak veya proje geçmişini görüntülemek istediklerinde uzak depo ile iletişim kurmaları gerekmez. Bir sunucu çökerse ve o sunucu üzerinde işbirliği yapan sistemler varsa, geliştiricilerden birinin projeyi sunucuya geri yüklemesiyle sistem kurtarılabilir. Özetle, aynı proje üzerinde farklı geliştiricilerin farklı iş akışlarıyla farklı şekillerde çalışmasına olanak tanır.\nGit Flow Nedir? 5 Ocak 2020\u0026rsquo;de nvie, https://nvie.com/posts/a-successful-git-branching-model/ adresindeki bir yazıda git depolarını düzenli tutmak için bir model önerdi. Daha sonra bu modeli kullanmayı kolaylaştıran git uzantılarını içeren Git-Flow adlı bir proje yayınladı. GitFlow modeli temelde git versiyon kontrol sistemi üzerine kurulmuştur. Yani tüm model işlemlerini git komutlarıyla gerçekleştirmek mümkündür.\nGit Flow\u0026rsquo;un Avantajları ve Dezavantajları Avantajları:\nOrganize ve öngörülebilir bir geliştirme süreci sağlar Büyük takımlar için ideal bir yapı sunar Versiyon yönetimini basitleştirir Her dalın net bir amacı vardır Paralel geliştirmeyi destekler Dezavantajları:\nKüçük projeler için fazla karmaşık olabilir Sürekli teslimat için uygun olmayabilir Dal yapısı bazen gereksiz karmaşıklığa yol açabilir Ek araç kurulumu gerektirir Öğrenme eğrisi diğer modellere göre daha yüksektir Git Flow Alternatifleri GitHub Flow: Daha basit bir model, sadece master ve feature dallarını kullanır GitLab Flow: Git Flow ve GitHub Flow arasında denge kurar Trunk Based Development: Ana dal üzerinde geliştirmeye odaklanır Git Flow Çalışma Prensibi Git Flow modelinde 5 ana dal bulunur:\nmaster: Ana dallardan biri olan Master, proje boyunca var olur. Master dalı her zaman üretime çıkabilecek kodu içerir. İdeal olarak master dalına yapılan her commit bir versiyondur ve \u0026ldquo;git tag\u0026rdquo; ile işaretlenmelidir (versiyon numarası verilmelidir). Master dalına direkt commit yapılmaz, sadece hotfix ve release dallarından merge yapılmasına izin verilir.\ndevelop: Develop, proje boyunca var olan diğer ana daldır. Develop dalı bir sonraki versiyon için yapılan değişiklikleri içerir. Tüm feature dalları önce bu dala merge edilir. Bu dal projenin ana geliştirme dalıdır ve sürekli entegrasyon (CI) süreçleri genellikle bu dal üzerinde çalışır.\nhotfix: Hotfix dalı, canlıdaki versiyonda kritik bir hata olduğunda ve bu hatanın hemen düzeltilip deploy edilmesi gerektiğinde kullanılır. Hotfix dalı master dalından oluşturulur ve genellikle \u0026lsquo;hotfix/[versiyon]-[açıklama]\u0026rsquo; formatında isimlendirilir. Hotfix dalında hata düzeltmesi tamamlandığında bu dal hem Developer hem de Master ile merge edilir. Master ile merge edildikten sonra değişiklik yeni bir versiyon numarası ile etiketlenir.\nfeature: Yeni bir özellik eklenirken, bu özellik için bir Feature dalı oluşturulur. Feature dalları her zaman develop dalından oluşturulur ve genellikle \u0026lsquo;feature/[özellik-adı]\u0026rsquo; formatında isimlendirilir. Bunlar özelliklere göre değişiklikler olarak düşünülebilir. Aynı anda birden fazla feature dalı açılabilir. Bu farklı geliştiricilerin farklı özellikler üzerinde çalışabileceği anlamına gelir. Özellikleri ayrı dallarda geliştirmek hem Develop dalının gereksiz commitlerle dolmasını engeller hem de feature dalını silmek suretiyle bir özellikten vazgeçmeyi kolaylaştırır. Özellik tamamlandığında bu dal Develop dalı ile merge edilir ve feature dalı silinir. Yani feature dalları sadece geliştirme süresince yaşar. Tabi bu süreçte kontrol amaçlı arada bir Develop dalından pull almak gerekebilir çünkü başka bir geliştirici feature dalını önce bitirmiş ve Develop dalına version push edilmiş olabilir. Feature dalları master, release, develop veya hotfix içeren isimler içermemelidir.\nrelease: Diyelim ki tüm değişiklikler tamamlandı. Yeni bir versiyon çıkılacağı zaman Develop dalından yeni bir Release dalı oluşturulur. Release dalları genellikle \u0026lsquo;release/[versiyon]\u0026rsquo; formatında isimlendirilir. Versiyondaki son değişiklikler, versiyon numaralarının değiştirilmesi vb. işlemler bu dalda yapılır. Release dalında sadece hata düzeltmeleri yapılmalı, yeni özellikler eklenmemelidir. Gerekli tüm değişiklikler tamamlandığında Release dalında tamamlanan tüm değişiklikler hem Master hem de Develop dallarına merge edilir. Master dalında git tag ile versiyon numarası etiketlenir ve ardından Release dalı silinir.\nGit Flow Örnek Proje /brew install git-flow \u0026gt; git flow init İlk olarak \u0026ldquo;brew install git-flow\u0026rdquo; ile kurulum yapıyoruz. GitFlow git ile birlikte gelmiyor. Ayrıca kurulması gerekiyor. Bu da dezavantajlarından biri olarak görülüyor. Git\u0026rsquo;te projeyi başlatmak için \u0026ldquo;git init\u0026rdquo; komutunu kullanıyorduk. Git-flow için git-flow sürecini başlatmak için \u0026ldquo;git flow init\u0026rdquo; komutunu giriyoruz. Komut çalıştığında eğer repo yoksa önce repo oluşturuyor. Ardından süreç için kullanılacak dal isimlerini kullanıcıya soruyor. Dal isimleri özelleştirilebilir ancak varsayılan değerlerin korunması önerilir.\n/git flow feature start performance Bu komut yeni bir feature dalı oluşturur. Feature ismi performance olduğu için varsayılan olarak feature/performance dalı olacaktır. Aynı işlemi mevcut git komutu ile de yapabiliriz. Bunun için girmemiz gereken komut \u0026ldquo;git checkout -b myFeature feature/performance\u0026rdquo; olacaktır.\n/git flow feature finish performance Bu komut daha önce açılmış bir dalı kapatır. Kapatma işlemi feature dalının develop dalına merge edilmesiyle başlar ve feature dalının silinmesiyle sonlanır. Komut çalıştırıldığında değişiklikler commit edilmemişse hata verecektir. Commit sonrası push yapılmamışsa hata verecektir. Bu işlemi normal git komutlarıyla yapmak için ilgili dalda önce commit yapılır ardından sırasıyla \u0026ldquo;git checkout develop \u0026gt; git merge \u0026ndash;no-ff feature/performance \u0026gt; git branch -D feature/performance\u0026rdquo; komutları çalıştırılır.\n/git flow release start 1.0.0 Bu komut girildiğinde yeni bir versiyon çıkışa hazır hale gelir. Komut çalıştığında Develop dalından yeni bir release/1.0.0 dalı oluşturulur. Bu işlemi mevcut git komutu ile yapmak için \u0026ldquo;git checkout -b release/1.0.0 develop\u0026rdquo; komutu çalıştırılır.\n/git flow release finish 1.0.0 Komut girildiğinde tamamlanan versiyon master dalına alınır. Değişiklikler hem develop hem de master dalları ile merge edilir. Master dalındaki son commit versiyon numarası ile etiketlenir. Ardından release dalı otomatik olarak silinir. Aynı işlemi git komutları ile yapmak için sırasıyla aşağıdaki komutlar çalıştırılır:\ngit checkout master git merge --no-ff release/1.0.0 git tag -a 1.0.0 git checkout develop git merge --no-ff release/1.0.0 git branch -d release/1.0.0 /git flow hotfix start 1.0.1 Bu komut ile yeni bir hotfix başlatılır. Hotfix dalları acil güncellemeler için kullanılır ve master dalından oluşturulur. Komut çalıştığında master dalından dallanan yeni bir hotfix/1.0.1 dalı oluşturulur. İşlemi git komutu ile yapmak için \u0026ldquo;git checkout -b hotfix/1.0.1 master\u0026rdquo; komutu çalıştırılır.\n/git flow hotfix finish 1.0.1 Bu komut ile hotfix tamamlanır. Değişiklikler hem Develop hem de Master dallarına alınır. Master dalı 1.0.1 ile etiketlenir ve hotfix dalı silinir. \u0026ldquo;git tag -l\u0026rdquo; komutu çalıştırıldığında versiyon numaraları görüntülenir. Aynı işlemi mevcut git komutları ile yapmak için sırasıyla aşağıdaki komutlar çalıştırılır:\ngit checkout master git merge --no-ff hotfix/1.0.1 git tag -a 1.0.1 git checkout develop git merge --no-ff hotfix/1.0.1 git branch -d hotfix/1.0.1 Git Flow En İyi Uygulama Önerileri Dal İsimlendirme Kuralları\nFeature dalları için açıklayıcı isimler kullanın (örn. feature/kullanici-dogrulama) Hotfix ve release dalları için semantik versiyonlama kullanın Commit Mesajları\nAçıklayıcı commit mesajları yazın Conventional Commits standardını takip edin Her commit\u0026rsquo;in tek bir amacı olduğundan emin olun Kod İnceleme Süreci\nFeature dallarını merge etmeden önce kod incelemesi yapın Otomatik test süreçlerini kullanın Dokümantasyon güncellemelerini unutmayın Merge Stratejisi\n\u0026ndash;no-ff (no fast-forward) parametresini kullanın Merge çakışmalarını hızlıca çözün Squash commit\u0026rsquo;leri kullanmayı düşünün Sonuç Git Flow, modern yazılım geliştirme süreçlerinde dal yönetimini sistematikleştiren etkili bir yaklaşımdır. Bu iş akışı sayesinde takımlar daha organize çalışabilir, versiyonlamayı daha iyi kontrol edebilir ve kod kalitesini artırabilir. Özellikle büyük projelerde ve takım çalışmalarında, Git Flow\u0026rsquo;un sunduğu yapılandırılmış dal stratejisi geliştirme süreçlerini önemli ölçüde iyileştirir. Yukarıda bahsedilen en iyi uygulamaları takip ederek, Git Flow\u0026rsquo;u projenizde başarıyla uygulayabilir ve yazılım geliştirme süreçlerinizi daha verimli hale getirebilirsiniz.\n","lang":"tr","permalink":"/tr/blog/git-flow/","summary":"Git Flow, versiyon kontrol sistemlerinde dal yönetimini sistematikleştiren etkili bir yaklaşımdır. Bu makalede Git Flow\u0026rsquo;un ne olduğunu, nasıl kullanıldığını ve en iyi uygulama önerilerini detaylı olarak açıklayacağım.","tags":["git-flow","git"],"title":"Git Flow Nedir?"},{"categories":["Kitap","Kişisel Gelişim"],"contents":"\nSelamlar. İlk kitap özeti yazıma hoşgeldiniz. Kitapları okuduktan sonra unutmaya başladığımı fark ettiğim için ve dönüp tekrar hatırlamak istediğimde bakabileceğim kendime ait bir kaynak olsun istediğim için böyle bir şey denemeye karar verdim. Umarım sizlere de faydası olur. İlk olarak bir süredir okuduğum ve yeni bitirdiğim James Clear\u0026rsquo;a ait Atomik Alışkanlıklar kitabının özetini, kitabı okurken kendi çizdiğim taraflar ve izlediğim/okuduğum diğer kitap özetlerinden derlediğim notlarla-alıntılarla ve büyük çoğunluğu kitaptan parçalarla yazacağım.\nGiriş Alışkanlık kelimesini, düzenli olarak ve pek çok örnekte otomatik bir şekilde gerçekleştirilen bir rutin ve davranıştır şeklinde tanımlıyor James Clear. Kendi yaşadığı bir kazadan ve küçük alışkanlıkların kendisini nasıl hayata tekrar bağladığından bahsettikten sonra ekliyor: \u0026ldquo;Başlangıçta küçük ve önemsiz görünen değişiklikler, sizin onlara yıllarca sadık kalmanız durumunda bir araya gelerek hatırı sayılır sonuçlar yaratıyor. Hepimiz engellerle karşılaşıyoruz ama uzun vadede hayatlarımızın kalitesi, alışkanlıklarımızın kalitesine bağlı oluyor. Aynı alışkanlıklarla sadece aynı sonuçları alabilirsiniz ancak daha iyi alışkanlıklarla her şey mümkün.\u0026rdquo;\nKendi deneyimleri ve sonrasında ise faydalandığı biyoloji, felsefe, nörobilim, psikoloji ve diğer dalların katkısı ile yazdığı bu kitabında, adına Davranış Değişikliğinin Dört Yasası dediği dört adımdan oluşan bu omurga ile nasıl iyi alışkanlıklar edinilebileceğinden ve kötü alışkanlıklardan ise nasıl kurtulunabileceğini anlatıyor.\nAtomik Alışkanlıkların Şaşırtıcı Gücü Dört yasaya geçmeden önce alışkanlıkların gücünden örneklerle bahsediyor. En can alıcı örneklerden biri ise İngiltere Bisiklet Takımı ile ilgili olan. Yaklaşık 100 yıldır olimpiyatlarda kötü performans sergileyen ve bisiklet sporunun en büyük yarışı olan Fransa Bisiklet Turu\u0026rsquo;nu 110 yıldır kazanamayan Büyük Britanya Bisikletçiliği\u0026rsquo;nin (British Cycling) başına 2003 yılında British Cycling\u0026rsquo;i yeniden yola sokmak için göreve David Brailsford getirilmişti. Onu önceki koçlardan farklı kılan özelliği \u0026ldquo;marjinal faydaların bir araya toplanması\u0026rdquo; olarak adlandırdığı ve kısaca yaptığımız her şeyde minik bir iyileşme marjı arama felsefesi olan bir stratejliye amansızca bağlı olmasıydı. Brailsford bunu, \u0026ldquo;Bütün prensip, bisiklet sürmekle ilgili her şeyi küçük parçalara böler ve o parçaları %1 oranında iyileştirirseniz, hepsini bir araya topladığınızda hatırı sayılır bir düzelme sağlarsınız\u0026rdquo; düşüncesine dayanıyor demiştir.\nBrailsford ve ekibi; bisiklet selelerinin daha rahat olması için yeniden tasarlamak, daha iyi tutuş için lastiklere alkol sürmek, biniş sırasında sürücülerin ideal kas ısılarını korumak için binicilere elektrikle ısınan dış şortlar giydirmek vb. bir çok küçük iyileştirme yaptılar. Ekip gözden kaçan ve beklenmedik bir çok alanda %1\u0026rsquo;lik iyileştirmeler yapmaya devam ettiler. Bunlar ve diğer yüzlerce küçük iyileştirme birikirken sonuçlar da kimsenin beklemediği hızla gelmeye başladı. Brailsford\u0026rsquo;un başa geçmesinden sadece beş yıl sonra British Cycling takımı, Pekin\u0026rsquo;de düzenlenen 2008 Olimpiyatları\u0026rsquo;nda şaşırtıcı bir oranla altın madalyaların %60\u0026rsquo;ını kazandı. Dört yıl sonra ise Olimpiyatlar İngiltere\u0026rsquo;ye geldiğinde 9 Olimpiyat 7 dünya rekoru kırarak çıtayı daha da yükselttiler. Aynı yıl ise Bradley Wiggins, Fransa Bisiklet Turu\u0026rsquo;nu kazanan ilk İngiliz bisikletçi oldu. Ertesi yıl ise yarışı takım arkadaşı Chris Froome kazandı ve ertesi yıllarda kazanmaya devam ettiler. Bu örnekten yola çıkarak küçük alışkanlıklar neden büyük farklar yaratır konusuna değiniyor.\nKüçük Alışkanlıklar Neden Büyük Farklar Yaratır? Brailsford\u0026rsquo;un dediği gibi yüzde 1 oranında bir iyileşme doğrudan dikkat çekmese de - bazen hiç fark edilmez bile - özellikle uzun vadede çok daha anlamlıdır. Minik bir ilerlemenin zaman içinde yaratabileceği fark şaşırtıcıdır. Hesap şöyle işliyor, 1 yıl boyunca her gün yüzde 1\u0026rsquo;lik bir iyileşme kaydederseniz, yıl sonu geldiğinde 37 kat daha iyi olursunuz. Tam tersi şekilde 1 yıl boyunca her gün yüzde 1 kötü giderseniz neredeyse 0a kadar inersiniz. Küçük bir kazanç ya da önemsiz bir engel olarak başlayan şey sonunda birikerek çok daha fazlasına dönüşür. İyi alışkanlıkların değeri ve kötü alışkanlıkların maliyeti ancak iki, beş veya on yıl sonra geriye dönüp bakıldığında çarpıcı şekilde belirginleşir.\nÜç gün üst üste spor salonuna giderseniz bir anda forma girmezsiniz. Bu akşam bir saat İngilizce çalışsanız bu dili öğrenmiş olmazsınız. Bir kaç değişiklik yaparız ama sonuçlar hiçbir zaman çok çabuk gelmez ve böylece hızla önceki rutinlerimize döneriz. Ne yazık ki dönüşümün yavaş temposu ayrıca kötü bir alışkanlığın geri gelmesini de kolaylaştırır. Bugün sağlıksız bir öğün yerseniz tartının ibresi çok fazla oynamaz. Bu gece geç saate kadar çalışır ve ailenizi ihmal ederseniz sizi affederler. İşleri sonraya bırakır ve projenizi yarına ertelerseniz genellikle daha sonra tamamlayacak zamanınız olacaktır. Basit bir kararı kafadan uzaklaştırmak kolaydır. Ancak yüzde 1\u0026rsquo;lik hataları kötü kararları kopyalayarak küçük hataları çoğaltarak ve minik bahaneleri makul kılarak günden güne tekrarladığımız zaman küçük tercihlerimiz zehirli sonuçlara dönüşür. Sonunda soruna dönüşen birçok hatalı adımın şunda bunda yüzde 1\u0026rsquo;lik düşüşlerin birikimidir.\nÖnemli olan alışkanlarınızın sizi başarıya yönlendirip yönlendirmediğidir. Mevcut rotanıza, mevcut sonuçlarınızdan daha fazla kafa yormalısınız. Milyonerseniz ve her ay kazandığınızdan daha fazla para harcıyorsanız kötü yoldasınız demektir. Harcama alışkanlıklarınızı değiştirmezseniz bunun sonu iyi olmayacaktır. Tam tersine batak durumdaysanız ama her ay birazcık birikim yapıyorsanız, istediğinizden daha yavaş ilerliyor bile olsanız finansal özgürlük yolundasınız demektir.\nAmaçları Unutun Sistemlere Odaklanın Zaman içinde sonuçların belirlediği hedeflerden çok izlediği sistemlerle alakalı olduğunu fark etmeye başladığından bahsediyor yazar. Sistemler ile hedefler arasındaki fark nedir? Bu ayrımı ilk olarak Dilbert çizgi romanının yaratıcısı karikatürist Scott Adams\u0026rsquo;tan öğrendiğini söylüyor ve devam ediyor. Hedefler, ulaşmak istediğiniz sonuçlarla ilgilidir. Sistemler ise o sonuçlara giden süreçlerle. Daha iyi sonuçlar istiyorsanız hedef koymayı unutun. Onun yerine sisteminize odaklanın.\nSpor koçuysanız hedefiniz bir şampiyonluğu kazanmak olabilir. Sisteminiz ise oyuncu alma, yardımcı koçlarınızı yönetme ve antrenman yapma şeklinizdir. Girişimciyseniz hedefiniz bir milyon dolarlık bir iş kurmak olabilir. Sisteminiz ise ürün fikirlerini test etme, çalışanlarınızı işe alma ve pazarlama kampanyalarını yürütme şeklinizdir. Müzisyenseniz hedefiniz yeni bir parçayı çalmak olabilir. Sisteminiz ise ne kadar sık pratik yaptığınız, farklı ölçüleri nasıl parçalara bölüp çaldığınız ve eğitmeninizden nasıl geri bildirim aldığınızdır. Sisteme odaklanın derken ise hedef koymayın demiyor. Hedefler bir yön belirlemek açısından iyidir ancak ilerleme kaydetme açısından sistemler en iyisidir diyor. Hedefleri düşünmeye çok fazla zaman ayırıp sistemleri tasarlamaya yeterince vakit ayırmadığımızda bir avuç problem doğar. Hedef belirlemek neden problemlidir?\nKazanlarınında kaybedenlerinde hedefleri aynıdır: Olimpiyatlara katılan her sporcu altın madalyayı kazanmak ister. Her aday işi almak ister. Ama başarılı ve başarısız insanlar aynı hedefleri paylaşıyorlarsa kazananları kaybedenlerden ayıran şey hedef olamaz. İngiliz bisikletçileri alanlarının zirvesine taşıyan Fransa Bisiklet Turu\u0026rsquo;nu kazanma hedefi değildi. Tahmin edileceği üzere, diğer bütün profesyonel takımlar gibi yarışı ondan önceki yılarda da kazanmak istemişlerdi. Hedef her zaman oradaydı. Farklı bir sonuca ancak sürekli küçük iyileşmelerden oluşan bir sistem oturttukları zaman ulaştılar. Bir hedefe ulaşmak sadece anlık bir değişikliktir: Bir hedefe ulaşmak hayatınızı sadece şimdilik değiştirir. İlerleme konusunda genel kanıya aykırı olan budur. Sonuçları değiştirmeniz gerektiğini düşürünüz ama sorun sonuçlar değildir. Asıl değiştirmemiz gereken o sonuçlara yol açan sistemlerdir. Hedefler mutluluğunuzu kısıtlar: Her hedefin arkasındaki üstü örtülü varsayım şudur: \u0026ldquo;Hedefime ulaştığım zaman mutlu olacağım\u0026rdquo; Hedefi öne koyan zihniyetin sorunu, mutluluğu sürekli bir sonraki kilometre taşına kadar erteliyor olmanızdır. Dahası hedefler bir \u0026ldquo;ya şunu yaparım ya başarısız olurum\u0026rdquo; çatışması yaratır. Ya hedefinize ulaşır ve başarılı olursunuz ya da çuvallar ve bir hayal kırıklığı olursunuz. Kendinizi zihinsel olarak mutuluğun dar bir versiyonuna hapsedersiniz ve bu yanlıştır. Panzehir ise sistemlere öncelik veren bir zihniyettir. Sonuçtan ziyade sürece aşık olduğunuzda kendinize mutlu olma izni vermek için beklemeniz gerekmez. Sisteminizin işlediği her an tatminkar hissedebilirsiniz. Hedefler uzun vadeli ilerlemeyle pek iyi anlaşamaz: Hedef odaklı bir zihniyet \u0026ldquo;yoyo\u0026rdquo; etkisi yaratabilir. Çoğu koşucu aylarca çok çalışır ama bitiş çizgisini geçtikleri anda antrenmanı bırakır. Onları motive eden yarış artık bitmiştir. Hedef belirlemenin amacı oyunu kazanmaktır. Sistem inşa etmenin amacı ise oyunu oynamaya devam etmektir. Gerçek uzun vadeli düşünme tarzı, hedefsiz düşünmektir. Alışkanlıklar Kimliğinizi Nasıl Biçimlendirir? (ve Tam Tersi) Kötü alışkanlıkları tekrar etmek bu kadar kolayken iyileri oluşturmak neden bu kadar zordur? Genellikle iyi alışkanlıkları bir kaç günden fazla sürdürmek samimi çaba ve zaman zaman yaşanan motivasyon patlamalarıyla bile zor gelir. Egzersiz, meditasyon, günlük tutma ve yemek pişirme gibi alışkanlıklar bir ya da iki gün mantıklı geldikten sonra insanı zorlamaya başlar. Öte yandan alışkanlıklarınız bir kez yer ettiğinde sonsuza dek peşinizi bırakmayacak gibi görünür. Hele istenmeyenler. Ne kadar çaba harcasak da abur cubur yemek, çok fazla televizyon izlemek, işleri ertelemek ve sigara içmek gibi sağlıksız alışkanlıkları aşmak imkansız gelebilir. Alışkanlıklarımızı değiştirmek iki nedenden ötürü zorlayıcıdır. Bir; Yanlış şeyi değiştirmeye çalışırız ve İki; Alışkanlıklarımızı yanlış yönde değiştirmeye çalışırız.\nİlk hatamız yanlış şeyi değiştirmeye çalışmamızdır. Ne demek istediğimi anlamak için değişimin üç katmanda gerçekleşebileceğini göz önünde bulundurun. Bu katmanları bir soğanın katmanları gibi düşünebilirsiniz. İlk katman sonuçlarınızı değiştirmektir. Bu katman sonuçlarınızı değiştirmekle ilgilidir. Kilo vermek, kitap yazmak, şampiyonluk kazanmak gibi. Belirlediğiniz hedeflerin çoğu bu değişim seviyesiyle bağlantılıdır. İkinci katman süreci değiştirmektir. Bu katman alışkanlıklarınızı ve sistemlerinizi değiştirmekle ilgilidir. Spor salonunda yeni bir rutin oturtmak, daha iyi bir iş akılı için masanızdaki dağınıklığı toplamak, bir meditasyon pratiği geliştirmek. İnşa ettiğiniz alışkanlıkların çoğu bu katmanla bağlantılıdır. Üçüncü ve en derin katman ise kimliğinizi değiştirmektir. Bu katman, inançlarınızı değiştirmekle ilgilidir. Dünya görüşünüzü, öz imajınızı, kendinizle ve başkalarıyla ilgili yargılarınızı. Taşıdığınız inançların, varsayımların ve önyargıların çoğu bu katmanla ilgilidir. Çoğu insan alışkanlıklarını değiştirme sürecine ne elede etmek istediğine odaklanarak başlar. Bu bizi sonuca dayalı alışkanlıklara götürür. Alternatifi ise kimliğe dayalı alışkanlıklar inşa etmektir. Bu yaklaşımla işe kim olmak istediğimize odaklanarak başlarız. Sigaraya direnen iki kişi düşünün. Sigara ikram edildiğinde birinci kişi \u0026ldquo;Hayır teşekkürler sigarayı bırakmaya çalışıyorum\u0026rdquo; diyor. Kulağa mantıklı bir cevap geliyor bu ama aslında bu kişi hala başka bir şey olmaya çalışan bir tiryaki olduğunu düşünüyor. Aynı inançları taşırken davranışının değişmesini umuyor. İkinci kişi ise teklifi \u0026ldquo;Hayır, teşekkürler ben sigara içmem\u0026rdquo; diyerek geri çeviriyor. Arada küçük bir fark var ama bu beyan, kimlikte bir kaymayı işaret ediyor. Sigara içmek söz konusu kişinin önceki hayatının bir parçasıydı şimdikinin değil. Bu kişi kendini artık sigara içen biri olarak tanımlamıyor. Kişinin özüyle uyuşmayan bir davranış kalıcı olamaz. Daha fazla para isteyebilirsiniz ama kimliğiniz yaratmaktan çok tüketen bir kimlikse kazanmak yerine harcamaya doğru çekilmeye devam edersiniz. Sağlığınızın daha iyi olmasını isteyebilirsiniz ama konforunuza öncelik verdiğiniz sürece, spor yapmak yerine gevşemeye çekilirsiniz. İçsel motivasyonunuzun en üst düzeyi, bir alışkanlığın kimliğinizin bir parçasına dönüşmesidir. Şunu isteyecek türde bir insan olduğunu söylemek başka bir şeydir, şu olan türde bir insan olduğunuzu söylemek bambaşka. Gerçek davranış değişikliği kimlik değişikliğidir. Bir alışkanlığa motivasyon nedeniyle başlayabilirsiniz ama ona bağlı kalmanızın tek nedeni kimliğinizin bir parçasına dönüşmesi olacaktır. Hedef bir kitap okumak değil okuyan birine dönüşmek, hedef bir maraton koşmak değil koşucuya dönüşmek, hedef bir enstrüman çalmayı öğrenmek değil müzisyene dönüşmek. Kimliğinizi değiştirmenin iki adımlı süreci: Alışkanlıklarınız kimliğinizi somutlaştırma şeklinizdir. Her gün yatağınızı toplayarak düzenli bir insanın kimliğini somutlaştırmış olursunuz. Her gün yazarak yaratıcı bir insanın kimliğini somutlaştırırsınız. Her gün antrenman yaparak atletik bir insanın kimliğini somutlaştırırsınız. Bir davranışı ne kadar çok tekrarlarsanız o davranışla bağlantılı kimliği o kadar pekiştirirsiniz. Elbette kimliğinizi etkileyen tek eylem alışkanlıklarınız değildir ancak sıklıklarının gücü onları en önemlileri kılar. Hayattaki her tecrübe öz imajınızı değiştirir ama bir kez topa vurdunuz diye kendinizi futbolcu olarak görmeniz ya da bir resim karaladınız diye kendinizi ressam olarak görmeniz olası değildir. Bu kademeli bir ilerlemedir. Parmağınızı tıklatarak ya da yepyeni biri olmaya karar vererek değişemeyiz. Azar azar, günbegün, alışkanlık üstüne alışkanlıkla değişiriz. Sürekli benliğimizin mikroevrimlerine maruz kalırız. Olduğunuz kişiyi değiştirmenin en pratik yolu yaptığınız şeyi değiştirmektir.\nNe zaman bir sayfa bir şey yazarsanız yazar olursunuz Ne zaman keman çalsanız müzisyen olursunuz Ne zaman egzersiz yapmaya başlarsınız sporcu olursunuz Ne zaman çalışanlarınızı teşvik etseniz lider olursunuz Elbette bu aksi yönde de işler. Ne zaman bir kötü alışkanlığı uygulamayı seçseniz o da kimlik için bir oy sayılır. İyi haber şu ki kusursuz olmak zorunda değilsiniz. Her seçimde iki tarafa da oy çıkacaktır. Bir seçimi kazanmak için oy birliğine değil oy çokluğuna ihtiyaç vardır. Kötü bir alışkanlık ya da üretkenlik dışı bir alışkanlık için birkaç oy almanız önemli değildir. Amacınız çoğunluğu kazanmaktır. Yeni kimlikler yeni kanıtlar gerektirir. Her zaman verdiğiniz şekilde oy vermeye devam ederseniz her zamanki sonuca ulaşırsınız. Hiçbir şey değişmezse gelecekte de hiçbir şey değişmeyecektir. Bu iki adımlı basit bir süreçtir.\nOlmak istediğiniz insan türüne karar verin Bunu küçük kazanımlarla kendinize ispatlayın. Önce kim olmak istediğinize karar verin. Bu ister bir takım, ister toplum, ister ulus için olsun her düzeyde geçerlidir. Neyi temsil etmek istiyorsunuz? Prensip ve değerleriniz neler? Kim olmak istiyorsunuz? Kendinize şunu sorun: \u0026ldquo;İstediğim sonucu ne tür bir insan elde edebilir? Nasıl bir insan yirmi kilo verebilir? Nasıl bir insan yeni bir dil öğrenebilir?\u0026rdquo; Örneğin \u0026ldquo;Nasıl bir insan kitap yazabilir?\u0026rdquo; Muhtemelen istikrarlı ve güvenilir bir insan. Şimdi odak noktanız kitap yazmaktan (sonuca dayalı), istikrarlı ve güvenli bir insan olmaya (kimliğe dayalı) kaysın. Bu süreç şöyle inançlara yol açabilir:\n\u0026ldquo;Ben öğrencilerinin hakkını koruyan bir öğretmenim\u0026rdquo; \u0026ldquo;Ben her hastasına, ihtiyaç duyduğu zamanı ve empatiyi sunan bir doktorum\u0026rdquo; \u0026ldquo;Ben çalışanlarını savunan bir yöneticiyim\u0026rdquo; Olmak istediğiniz insan türünü anladığınız zaman, arzu ettiğiniz kimliği pekiştirmek için küçük adımlar atmaya başlayabilirsiniz. Alışkanlıklarınız kimliğinizi, kimliğiniz alışkanlıklarınızı biçimlendirir. Bu iki yönlü bir sokaktır. Nihayetinde alışkanlıklarınız olmak istediğiniz insana dönüşmenize yardımcı olmak için önemlidir. Kendinizle ilgili en derin inançlarınızı geliştirmenize aracılık eden kanaldırlar. Kelimenin tam anlamıyla insan alışkanlıklarına dönüşür.\nDavranış Değişikliğinin Dört Yasası Bir alışkanlık oluşturmanın omurgasını James Clear dört unsura bağlıyor.\nİşaret: Bir davranışı başlatmak için beyninizi tetikler. Bir ödülün yaklaştığının habercisidir. Zihnimiz ödüllerin ipuçlarını bulmak için iç ve dış çevreyi sürekli analiz eder. İşaret ödülün ilk göstergesidir. İstek: İkinci adımdır ve her alışkanlığın ardındaki motivasyonun gücünü oluşturur. Bir değişim isteği duymadan harekete geçmemiz için bir neden olmaz. Bir bilgi parçası isteği tetikleyebilir. Kumarbaz için kumar makinesi sesi bu tetikleyici olabilir örneğin. Tepki / Eylem: Bir tepkinin olum olmayacağı ne kadar motive olduğunuzla ve ne kadar zorlanacağınızla ilişkilidir. Bir eylem sizin harcamak istediğinizden fazla çaba gerektiriyorsa onu yapmazsınız. Ödül: Ödüller her alışkanlığın nihai amacıdır. İşaret ödülü fark etmektir. İstek ödüle arzu duymaktır. Tepki ödülü ele geçirmekle ilgilidir. Ödülleri iki nedenle kovalarız: 1- Bizi tatmin ederler 2- bize öğretirler Bir davranış bu dört aşamanın birinde yetersizse asla alışkanlığa dönüşmez.\nBu dört adım iki safhaya ayrılabilir: Sorun safhası ve çözüm safhası. Sorun safhası işaret ve isteği kapsar ve bir şeyin değişmesi gerektiğini fark ettiğiniz aşamadır. Çözüm safhası ise tepkiyi ve ödülü kapsar, harekete geçtiğiniz ve arzu ettiğinizi başardığınız safhadır. Bütün davranışlar bir sorunu çözme arzusundan güç alır. Gerçek hayattan birkaç örnek:\nAlışkanlıkların dört yasasını yeni alışkanlıklar edinmek ve kötü alışkanlıklardan kurtulmak için aşağıdaki gibi kullanabiliriz.\nGörünür Kıl: Bir alışkanlığı görünür kılmak onu zahmetleştirmek yani gözümüzün keseceği hale getirmektir. Örneği yatağının yanında bir kitap bulundurursan yatmadan okuyabilirsin, spora gitmeden bir gün önce eşyalarını hazırlarsan gitme için daha rahatlarsın. Cazip Kıl: Kişinin nasıl bir insan olmak istediğiyle alakalıdır. Örneğin bir enstrüman çalıyorum demek yerine ben bir müzisyenim, ben spor yapmaya çalışıyorum demek yerine ben bir sporcuyum demek daha iyidir. Bu şekilde bu söylemler karakterinizin yani kimliğinizin bir parçası haline gelir. Bunu bir süre yaptıktan sonra bilinçaltınız ona göre davranmaya başlayacaktır. Kolaylaştır: Alışkanlığı gerçekleştirirken gereken şeyleri bir araya getirmektir. Sağlıklı beslenmeye karar verdiyseniz bir kaç gün önceden sağlıklı yemekleri hazırlamak gibi. Tatmin Edici Kıl: Eylemin gerçekleştirdikten sonra kendinizi ödüllendirmektir. Bu ödülün kolay ulaşılabilir, küçük şeylerden oluşması daha doğrudur. İlk günlerde kitabı okumak zor geliyorsa bu kadar sayfa okuduktan sonra dizi izleyeceğim, işimi bitirdikten sonra sevdiğim müziği dinleyeceğim vb. İyi alışkanlıkları kazandıran şeylerin tersi kötü alışkanlıkları azaltmaya ve kurtarmaya yardımcı olur.\nAlışveriş merkezine gidip fastfood yiyorsanız gitmezsiniz, belirli bir uygulamadan çok sipariş veriyorsanız uygulamayı silersiniz, sigarayı çok içiyorsanız paketi yanınızda taşımadığınızda içmezsiniz. Yine kötü alışkanlıkları itici kılmak adına bu alışkanlıkların size verdiği zararları düzenli aralıklarla yazabilirsiniz. Alışkanlık Oluşturma Taktikleri Alışkanlık Kartı Oluşturma: Günlük alışkanlıklarınızın bir listesini yapabilirsiniz. İyi alışkanlıklarınıza +, kötü alışkanlıklarınıza -, nötr alışkanlıklarınıza ise = koyabilirsiniz. Bu sayede değişmesini istediğiniz alışkanlıklarınızın farkına varabilir ve değişmesine karar verebilirsiniz. Bu sayede kötü alışkanlıklardan kurtulmak için adım atabilirsiniz. Size zihinsel olarak itici güç verebilir. Alışkanlık İstifleme veya Öncelik-Sonralık İlişkisi: Kötü alışkanlıkları ekarte etmek adına alışkanlıklar arasında bir öncelik-sonralık zinciri yani bir nevi ritüel oluşturabilirsiniz. Örneğin sabah uyanında cep telefonunda sosyal medyaya girip vakit kaybediyorsanız bunun yerine uyandıktan sonra bir bardak su içeceğim, su içtikten sonra evdeki bütün perdeleri açacağım, tüm perdeleri açtıktan sonra 5 dakika meditasyon yapacağım diyebilirsiniz. Aradan Çıkarma Taktiği: Sevmediğiniz veya daha az sevdiğiniz bir şeyi daha fazla sevdiğiniz bir şeyle birlikte yapabilirsiniz. Bu odaklanmayı ve dopamini düşürür ancak hiç bir şey yapmamaktan iyidir. Örneğin spor yaparken çok sevdiğiniz bir diziyi veya filmi izleyebilirsiniz, işinizi yaparken müzik dinleyebilirsiniz vb. Ortamı Tasarlama Taktiği: Ortamınızı alışkanlıklarınıza uygun hale getirerek hayatınızın mimari olabilirsiniz. Mutfakta sadece yemek yemek, yatak odasında sadece uyumak, oturma odanızın bir köşesinde sadece kitap okumak vb. Bir ortamı bir alışkanlığa uygun hale getirdiğinizde bir aidiyet duygusu oluşturursunuz. O koltuğa oturduğunuzda o kitabı elinize alıyorsunuz yani alışkanlığınız ve ortamınızı birbiriyle ilişkili hale getirdiğinizde gerçekleştirmek daha kolay bir hal alıyor veya yaptığınız işi en iyi şekilde yapıyorsunuz. Gruplandırma Taktiği: Birbiriyle uyumlu olan alışkanlıklarınızı gruplandırırsanız gerçekleştirmesi daha kolaylaşacaktır. Örneğin uyandıktan sonra size kendinizi daha iyi hissettirecek şeyleri yapmak. Su içmek, duş almak, giyinmek vb. alışkanlıkları gruplandırmak. Önemli olan basit uygulanabilir ve faydalı alışkanlıkları grup haline getirmek yani birbirleriyle ilişkilendirmek, bir zincirin halkası gibi. Yani bir alışkanlığı yaptığınızda bilinçaltının diğeri için seni yönlendirmesi. Zamana Bölme Taktiği: Bir alışkanlığı en rahat hangi zamanda gerçekleştiriyorsunuz? Alışkanlıklarınızı edinirken hangi zamanlarda neyi daha iyi gerçekleştirdiğinizi gözlemleyin. Bir işi yapma konusunda en istekli olduğunuz zaman ne zaman, en verimli olduğunuz zamanlar hangi dilimler? Kitap okumak, egzersiz yapmak vb. Genel olarak uyandıktan sonra ilk 8 saat yeni alışkanlıklar kazanmak ve zor işlerinizi yapmak için en ideal zamandır. Ancak neyi ne zaman yapmaktan hoşlanıyorsanız buna göre alışkanlıklarınızı zamanlayabilirsiniz? Ataç Taktiği / Görselleştirme Taktiği: Yapacağınız alışkanlıkları hatırlatıcı olarak görselleştirmek. Görselleştirme size eyleme geçmeyi hatırlatır. Bir davranıştaki ilerlemenizi gösterir, sizi motive eder. Bu görselleştirmeyi gerçekten bir ataç alıp işi yaptıkça dolu kavanozdan boş kavanoza atabileceğiniz gibi, not yazma, mobil uygulama kullanma gibi şekillerde de yapabilirsiniz. Başkalarıyla Birlikte Yapma Taktiği: Çevrenizdeki insanlar sürekli olarak alkol alıp sigara içiyorlarsa sizin de onlara eşlik etme ihtimaliniz yüksektir. Hemen değil ancak bir süre sonra bu davranış sizin normale dönecektir. İnsan ortamına uyum sağlayan bir varlıktır ancak bunu aksi yönde uygulamakta mümkündür. Bir türlü kitap okumayı düzenli hale getiremiyorsunuz diyelim. Çevrenizde boş bol kitap okuyan insanlar olursa onlarla birlikte yaparak sizde kitap okuma alışkanlığınızı geliştirebilirsiniz. Duygularını Yönetme veya Duygusal Durumunu Değiştirme Taktiği: Bir çok kötü alışkanlığın kökeni üzüntüden, kaygıdan, olayları zihninde tekrar tekrar ziyaret etmekten kaynaklanır. Örneğin sinirlendiğinizde sürekli bir şeyler yemek, öfkeliyken alkol almak vs. O duygu bir tetikleyici oluyor. Ufak bir değişiklikle bunu olumluya çevirebiliriz. Çok sinirlendiğinizde mümkünse yürüyüş yapın ya da çok sevdiğiniz şarkı vardır dilinize dolanan size ilham veren vb. Öfkelendiğinizde o şarkıyı söyleyebilirsiniz veya dinleyebilirsiniz. 21 Gün Kuralı Taktiği: 21 gün boyunca 6 yeni alışkanlık yapmayı deneyin. Sonrasında bunları yapmayı kasıtlı olarak bırakın. Bu 6 alışkanlığı otomatikleştirdiğinizi gördüğünüzde veya en azından bir kısmını otomatik olarak yapabildiğinizde boşalan sayıda yeni alışkanlıklar kazanmak adına 21 günlük yeni programlara başlayabilirsiniz. Bir alışkanlık edindiğinizde ve bunu içselleştirdiğinizde diğer alışkanlıkları daha kolay edinebildiğinizi göreceksiniz. Peki ya hayatınız alt üst olduğunda alışkanlıklarınıza nasıl devam edeceksiniz? Kapsamı azaltıp plana bağlı kalın. Örneğin 300 kelime yazıyorsanız 50 kelime yazın ama her gün yapın. If-Then Tekniğini kullanın:\u0026ldquo;Eğer [beklenmedik bir şey] ise, o zaman [cevabınız].\u0026rdquo; Örneğin: Yarın sabah koşmak için zamanında uyanamazsam, işten sonra koşacağım. Öğle tatilinde yogaya yetişemezsem öğleden sonra yapacağım Öğle yemeği için sağlıksız bir şey alırsam, akşam yemeği için sağlıklı bir yemek pişiririm.\nSonuç Kitap benim için okuması oldukça faydalı bir kitap oldu. Zaten hali hazırda olan alışkanlıklarımın tekrar farkına vardım ve yeni alışkanlıklar elde edinebilmek için içerideki yöntemlerden bazılarını uygulamaya başladım. İlerleme veya sonuçları gördükçe paylaşmaya devam ederim. Umarım size de faydalı bir içerik olur. Teşekkürler.\nKaynakça James Clear - Atomik Alışkanlıklar https://medium.com/@sevketkurt/atomi%CC%87k-ali%C5%9Fkanliklar-ki%CC%87tap-%C3%B6zeti%CC%87-89393c903b06 https://nurdanozdemir.medium.com/atomik-al%C4%B1%C5%9Fkanl%C4%B1klar-kitap-%C3%B6zeti-bfa513c2c890 ","lang":"tr","permalink":"/tr/blog/atomik-aliskanliklar-kitap-ozeti/","summary":"İlk olarak bir süredir okuduğum ve yeni bitirdiğim James Clear\u0026rsquo;a ait Atomik Alışkanlıklar kitabının özetini, kitabı okurken kendi çizdiğim taraflar ve izlediğim/okuduğum diğer kitap özetlerinden derlediğim notlarla\u0026hellip;","tags":["kitap-özeti","alışkanlıklar","kişisel-gelişim"],"title":"Atomik Alışkanlıklar Kitap Özeti?"},{"categories":["archives"],"contents":"","lang":"tr","permalink":"/tr/archives/","summary":"","tags":null,"title":"Arşiv"},{"categories":["Geliştirme","iOS"],"contents":"\nHerkese merhabalar! App Store Connect API hakkında ilk blog yazısına hoşgeldiniz. Bu yazımda sizlere kısaca App Store Connect API\u0026rsquo;den ve API\u0026rsquo;yi kullanabilmek için nasıl JWT token oluşturabileceğinizi anlatacağım.\nApp Store Connect API Nedir? App Store Connect API, App Store Connect\u0026rsquo;te gerçekleştirdiğiniz işlemleri otomatikleştiren bir REST API\u0026rsquo;dir. Bu API, geliştiricilere uygulama gönderme ve güncelleme işlemlerinden, iç uygulama satın almalarını yönetmeye, uygulama performansını ve kullanıcı etkileşimini kapsamlı raporlar aracılığıyla izlemeye, müşteri değerlendirmelerine ve geri bildirimlere etkili bir şekilde yanıt vermeye kadar çeşitli görevleri sorunsuz bir şekilde yerine getirme imkanı sunar.\nNeden JWT Token? Token olmadan, App Store Connect API\u0026rsquo;den yanıt alamazsınız, ancak genellikle API, kimlik doğrulama ve yetkilendirme amaçları için JSON Web Token (JWT) gerektirir. API bağlamında JWT token, istemcinin kimliğini doğrulamak ve istenen kaynaklara erişim için gerekli izinlere sahip olduğunu sağlamak için güvenli ve standart bir yöntem olarak hizmet eder.\nJWT Token Nasıl Oluşturulur? App Store Connect API\u0026rsquo;yi kullanmak için JWT tokenları oluşturmadan önce birkaç adımı tamamlamanız gerekmektedir.\nApp Store Connect GUI üzerinden API Key oluşturun\nÖzel anahtarı p8 formatında kaydedin.\nIssuer ID ve API Key ID değerlerini kopyalayın.\nAPI Key Oluşturma API anahtarı oluşturmak için, hesabınızla App Store Connect web arayüzüne giriş yapın ve Users\u0026amp;Access sayfasına gidin. Sayfadaki \u0026ldquo;Keys\u0026rdquo; sekmesine tıklayın. \u0026ldquo;Keys\u0026rdquo; sekmesini görebilmek için hesabınızın bu izne sahip olması gerekmektedir. Belirli bir amaç için API anahtarı veya tüm App Store Connect API\u0026rsquo;ına erişim sağlayan yönetici API anahtarı oluşturabilirsiniz.\n\u0026lsquo;Active\u0026rsquo; metni yanındaki artı ikonuna tıklayın, anahtar için bir isim yazın, açılan modalda anahtara erişebilecek rolleri seçin ve \u0026lsquo;Generate\u0026rsquo; düğmesine tıklayın. Ardından anahtar oluşturulacak ve listelenecektir.\nÖzel Anahtarı Kaydedin API Anahtarı oluşturulduktan sonra Özel Anahtarı bilgisayarınıza kaydetmeniz gerekiyor. Anahtar genellikle .p8 formatındadır. Özel anahtarla uğraşırken akılda tutmanız gereken bazı önemli noktalar bulunmaktadır.\nÖzel anahtar yalnızca bir kez kaydedilebilir. Kaydedildikten sonra mutlaka güvenli bir şekilde saklanması önemlidir.\nÖzel anahtar asla süresi dolmaz ve geçerli olduğu sürece çalışır; hatta tehlikeye girmiş olsa bile. Eğer anahtarınızın artık güvenli olmadığını düşünüyorsanız, en kısa sürede App Store Connect\u0026rsquo;ten iptal edin ve yeni bir anahtar alın.\nIssuer ID ve API Key ID Değerlerini Kopyalayın JWT token oluşturmadan önce son adım, Users\u0026amp;Access sayfasında bulabileceğiniz Issuer ID ve API Key ID\u0026rsquo;yi kopyalamaktır.\nJWT Token Oluşturma Daha önce belirttiğim gibi, JWT, App Store Connect API tarafından kullanılan belirli bir tokenı oluşturmak için kullanılır. Token oluşturma süreci aşağıdaki adımları içerir:\nIssuerID: User\u0026amp;Access sayfasından kopyalanan Issuer ID bilgisi.\nPrivate Key: .p8 formatında kaydedilen özel anahtar.\nExpiration Time: Maksimum 20 dakika, token 20 dakikadan fazla geçerli olamaz, bu nedenle süresi dolmadan yeni bir token oluşturduğumuzdan emin olmalıyız.\nAudience: Genellikle \u0026lsquo;applestoreconnect-v1\u0026rsquo; olarak ayarlanan API sürüm değeri ile sabit bir değerdir.\nAlgorithm: JWT algoritması, örneğin ES256, token oluşturmak için gereklidir.\nGerekli tüm detaylara sahip olduktan sonra, istediğiniz dil kullanarak JWT token oluşturabileceksiniz. Ben bu süreç için Node.js kullanacağım.\nAşağıdaki komutları bilgisayarınızda sırasıyla çalıştırın:\nmkdir appStoreToken cd appStoreToken npm init -y npm i jsonwebtoken touch index.js Aşağıdaki kodu index.js dosyanıza yapıştırın ve ilgili alanları kendi bilgilerinizle değiştirip kaydedin.\nconst fs = require(\u0026#34;fs\u0026#34;); const jwt = require(\u0026#34;jsonwebtoken\u0026#34;); const privateKey = fs.readFileSync(\u0026#34;yourPrivateKey.p8\u0026#34;); const apiKeyId = \u0026#34;Your API Key ID\u0026#34;; const issuerId = \u0026#34;Your Issuer ID\u0026#34;; let now = Math.round(new Date().getTime() / 1000); // Notice the /1000 let nowPlus20 = now + 1199; // 1200 === 20 minutes let payload = { iss: issuerId, exp: nowPlus20, aud: \u0026#34;appstoreconnect-v1\u0026#34;, }; let signOptions = { algorithm: \u0026#34;ES256\u0026#34;, header: { alg: \u0026#34;ES256\u0026#34;, kid: apiKeyId, typ: \u0026#34;JWT\u0026#34;, }, }; let token = jwt.sign(payload, privateKey, signOptions); console.log(\u0026#34;@token: \u0026#34;, token); ve son olarak aşağıdaki komutu çalıştırın.\nnode index.js Bu işlem, App Store Connect API\u0026rsquo;ye erişim için kullanabileceğimiz uzun bir token döndürecektir. Ayrıca, API\u0026rsquo;yi 20 dakika sonrasında kullanmaya devam etmek istiyorsak başka bir token oluşturmamız gerekecektir.\nSonuç Bu yazıdma, App Store Connect API için Node.js kullanarak bir JWT tokenı nasıl oluşturulur konusunu anlatmaya çalıştım. Bu, API\u0026rsquo;ye olan isteklerinizi doğrulamanın kritik bir adımıdır. Gelecekteki yazılarda, App Store Connect API\u0026rsquo;yi kullanmanın diğer yollarını anlatmaya çalışacağım. Okuduğunuz için teşekkür ederim.\nBu yazıyı İngilizce oku\n","lang":"tr","permalink":"/tr/blog/appstore-connect-ile-jwt-token-nasil-olusturulur/","summary":"App Store Connect API, App Store Connect\u0026rsquo;te gerçekleştirdiğiniz işlemleri otomatikleştiren bir REST API\u0026rsquo;dir. Bu API, geliştiricilere uygulama gönderme ve güncelleme işlemlerinden, iç uygulama satın almalarını yönetmeye, uygulama performansını ve kullanıcı etkileşimini..","tags":["jwt","app-store","api"],"title":"App Store Connect API için JWT Token Nasıl Oluşturulur?"},{"categories":null,"contents":"Bilgisayar Mühendisliği bölümünden hem lisans hem de yüksek lisans derecesiyle mezun oldum. Teknoloji sektöründe geçirdiğim 5 yıl boyunca, seyahat ve finans dahil olmak üzere çeşitli sektörlerde çalıştım. Ancak, ana odak noktam yapay zeka sohbet botu projeleri oldu. 2.5 yıl iş analisti ve geri kalanında yazılım geliştirici olarak çalışarak, bu özel alandaki beceri ve uzmanlığımı geliştirdim. Şu anda, Juphy\u0026rsquo;de yazılım geliştirici olarak çalışmaktan ve özellikle yapay zeka sohbet botları alanında heyecan verici ve yenilikçi teknoloji projelerine katkıda bulunmaktan büyük mutluluk duyuyorum.\n","lang":"tr","permalink":"/tr/about/","summary":"\u003cp\u003eBilgisayar Mühendisliği bölümünden hem lisans hem de yüksek lisans derecesiyle mezun oldum. Teknoloji sektöründe geçirdiğim 5 yıl boyunca, seyahat ve finans dahil olmak üzere çeşitli sektörlerde çalıştım. Ancak, ana odak noktam yapay zeka sohbet botu projeleri oldu. 2.5 yıl iş analisti ve geri kalanında yazılım geliştirici olarak çalışarak, bu özel alandaki beceri ve uzmanlığımı geliştirdim. Şu anda, Juphy\u0026rsquo;de yazılım geliştirici olarak çalışmaktan ve özellikle yapay zeka sohbet botları alanında heyecan verici ve yenilikçi teknoloji projelerine katkıda bulunmaktan büyük mutluluk duyuyorum.\u003c/p\u003e","tags":null,"title":""}]