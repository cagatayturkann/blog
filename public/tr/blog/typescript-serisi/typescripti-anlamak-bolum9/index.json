{
    "title": "TypeScript'i Anlamak - Bölüm 9: Örnek Proje",
    "permalink": "/tr/blog/typescript-serisi/typescripti-anlamak-bolum9/",
    "summary": "Bu makalede, TypeScript ve Node.js kullanarak JWT ve Google OAuth kimlik doğrulaması içeren bir Todo uygulaması geliştirme sürecini inceleyeceğiz. TypeScript\u0026rsquo;in tip güvenliği, MongoDB entegrasyonu ve clean architecture prensiplerini uygulayarak modern bir REST API tasarlama deneyimini ele alacağız.",
    "content": "TypeScript ile Node.js Authentication API Geliştirme: Kapsamlı Rehber Giriş Modern web uygulamaları geliştirirken tip güvenliği ve kod kalitesi giderek daha önemli hale geliyor. Bu eğitimde, TypeScript\u0026rsquo;in sunduğu güçlü özellikleri gerçek bir proje üzerinde öğreneceğiz. JWT ve Google OAuth kimlik doğrulaması içeren bir Todo uygulaması geliştirirken, TypeScript\u0026rsquo;in temel kavramlarını ve best practice\u0026rsquo;lerini uygulayacağız.\nBu proje size şunları kazandıracak:\nTypeScript ile güvenli kod yazma pratiği Modern bir REST API tasarlama deneyimi Authentication ve Authorization implementasyonu MongoDB ile TypeScript kullanımı Clean Architecture prensiplerini uygulama TypeScript Özellikleri ve Proje Yapısı Bu projede TypeScript\u0026rsquo;in temel özelliklerini kullanarak güvenli ve ölçeklenebilir bir API geliştireceğiz. Her özelliği gerçek proje kodlarımızdan örneklerle açıklayalım:\n1. TypeScript Temelleri (Basics) TypeScript\u0026rsquo;in temel yapı taşlarını projemizde şu şekilde kullanıyoruz:\n// src/config/env.ts\u0026#39;de Tip Tanımlamaları const PORT: number = Number(process.env.PORT) || 3000; const JWT_EXPIRES_IN: string = \u0026#39;1d\u0026#39;; // src/middleware/auth.middleware.ts\u0026#39;de Type Assertion const decoded = jwt.verify(token, JWT_SECRET) as IJwtPayload; // Burada JWT\u0026#39;den gelen veriyi IJwtPayload tipine dönüştürüyoruz // src/interfaces/user.interface.ts\u0026#39;de Literal Types type UserRole = \u0026#39;user\u0026#39; | \u0026#39;admin\u0026#39;; // User modelinde kullanıcı rollerini sadece bu iki değerle sınırlıyoruz Projedeki Kullanım Örnekleri:\nPORT tanımı src/index.ts\u0026lsquo;de server başlatırken kullanılıyor Type assertion auth.middleware.ts\u0026lsquo;de JWT doğrulamasında kullanılıyor UserRole tipi IUser interface\u0026rsquo;inde kullanıcı rolünü kısıtlamak için kullanılıyor 2. Fonksiyonlar (Functions) TypeScript\u0026rsquo;te fonksiyonları tip güvenli şekilde tanımlıyoruz:\n// src/services/auth.service.ts\u0026#39;de Method Signatures interface IAuthService { login(credentials: IUserLogin): Promise\u0026lt;{ user: IUser; token: string }\u0026gt;; register(userData: IUserRegistration): Promise\u0026lt;IUser\u0026gt;; } // src/controllers/auth.controller.ts\u0026#39;de Implementation public async login(req: Request, res: Response): Promise\u0026lt;void\u0026gt; { const { email, password } = req.body; const result = await this.authService.login({ email, password }); // ... } Projedeki Kullanım Örnekleri:\nIAuthService interface\u0026rsquo;i auth.service.ts\u0026lsquo;de servis implementasyonunu tanımlıyor Controller\u0026rsquo;lardaki tüm handler fonksiyonları Request ve Response tiplerini kullanıyor Tüm async fonksiyonlar Promise return type\u0026rsquo;ı ile tanımlanıyor 3. Nesne Tipleri (Object Types) Projemizde karmaşık veri yapılarını nesne tipleriyle modelliyoruz:\n// src/config/database.ts\u0026#39;de Configuration Types type DatabaseConfig = { uri: string; options: { useNewUrlParser: boolean; useUnifiedTopology: boolean; }; }; // src/controllers/todo.controller.ts\u0026#39;de Request Types interface ITodoCreate { title: string; description?: string; // Optional property örneği } Projedeki Kullanım Örnekleri:\nDatabaseConfig tipi MongoDB bağlantı ayarlarını tanımlıyor ITodoCreate interface\u0026rsquo;i todo oluşturma endpoint\u0026rsquo;inde request body validasyonu için kullanılıyor Optional property\u0026rsquo;ler todo güncellemelerinde kısmi güncellemeye izin veriyor 4. Interfaces Interface\u0026rsquo;leri projemizde hem tip tanımı hem de sözleşme olarak kullanıyoruz:\n// src/interfaces/base.interface.ts\u0026#39;de Base Interface interface IBaseEntity { _id: string; createdAt: Date; updatedAt: Date; } // src/interfaces/user.interface.ts\u0026#39;de Interface Extension interface IUser extends IBaseEntity { email: string; password?: string; name: string; role: UserRole; } Projedeki Kullanım Örnekleri:\nIBaseEntity tüm MongoDB modellerimizin temel alanlarını tanımlıyor IUser interface\u0026rsquo;i User modelinin şemasını ve metodlarını tanımlıyor Interface\u0026rsquo;ler mongoose model tanımlarında tip güvenliği sağlıyor 5. TypeScript Compiler TypeScript derleyicisini projemiz için özel olarak yapılandırıyoruz:\n{ \u0026#34;compilerOptions\u0026#34;: { \u0026#34;target\u0026#34;: \u0026#34;es2016\u0026#34;, \u0026#34;module\u0026#34;: \u0026#34;commonjs\u0026#34;, \u0026#34;strict\u0026#34;: true, \u0026#34;esModuleInterop\u0026#34;: true, \u0026#34;skipLibCheck\u0026#34;: true, \u0026#34;forceConsistentCasingInFileNames\u0026#34;: true, \u0026#34;outDir\u0026#34;: \u0026#34;./dist\u0026#34;, \u0026#34;rootDir\u0026#34;: \u0026#34;./src\u0026#34; } } Compiler Ayarlarının Önemi:\nstrict: Katı tip kontrolü sağlıyor target: Modern JavaScript özelliklerini kullanmamızı sağlıyor module: Node.js ile uyumlu modül sistemi kullanıyoruz 6. Classes OOP prensiplerini TypeScript classes ile uyguluyoruz:\n// src/services/base.service.ts\u0026#39;de Abstract Base Class abstract class BaseService\u0026lt;T extends IBaseEntity\u0026gt; { constructor(protected model: Model\u0026lt;T\u0026gt;) {} abstract create(data: Partial\u0026lt;T\u0026gt;): Promise\u0026lt;T\u0026gt;; async findById(id: string): Promise\u0026lt;T | null\u0026gt; { return this.model.findById(id); } } // src/services/todo.service.ts\u0026#39;de Class Implementation class TodoService extends BaseService\u0026lt;ITodo\u0026gt; { async create(data: ICreateTodo): Promise\u0026lt;ITodo\u0026gt; { return this.model.create(data); } async markAsCompleted(id: string): Promise\u0026lt;ITodo | null\u0026gt; { return this.model.findByIdAndUpdate(id, { completed: true }); } } Neden Bu Özellik?\nAbstract class\u0026rsquo;lar ile ortak davranışları zorunlu kılıyoruz Inheritance ile kod tekrarını önlüyoruz Service katmanını organize ediyoruz Projedeki Kullanım Örnekleri:\nBaseService tüm servisler için temel CRUD operasyonlarını tanımlıyor TodoService ve AuthService bu base class\u0026rsquo;ı extend ederek kendi özel metodlarını ekliyor Abstract metodlar sayesinde her servisin kendi create metodunu implemente etmesi zorunlu 7. Generics Generic tipleri projemizde şu şekilde kullanıyoruz:\n// src/services/base.service.ts\u0026#39;de Generic Service class CrudService\u0026lt;T extends IBaseEntity\u0026gt; { async findOne(filter: FilterQuery\u0026lt;T\u0026gt;): Promise\u0026lt;T | null\u0026gt; { return this.model.findOne(filter); } } // src/utils/response.ts\u0026#39;de Generic Response Handler function createResponse\u0026lt;T\u0026gt;(success: boolean, message: string, data?: T): IApiResponse\u0026lt;T\u0026gt; { return { success, message, data }; } // src/utils/error.ts\u0026#39;de Generic Error Handler class ApiError\u0026lt;T = unknown\u0026gt; extends Error { constructor(public statusCode: number, message: string, public data?: T) { super(message); } } Neden Bu Özellik?\nTip güvenliğini koruyarak yeniden kullanılabilir kod yazıyoruz Farklı veri tipleriyle çalışabilen fonksiyonlar oluşturuyoruz Tip parametreleri ile esnek yapılar kuruyoruz Projedeki Kullanım Örnekleri:\nCrudService farklı model tipleriyle çalışabiliyor (User, Todo vb.) createResponse her türlü veri yapısı için tutarlı API yanıtları oluşturuyor ApiError farklı hata tipleri için özelleştirilebilir error handling sağlıyor 8. Type Narrowing Runtime\u0026rsquo;da tip kontrolü ve daraltma işlemlerini güvenli şekilde yapıyoruz:\n// src/utils/error.ts\u0026#39;de Type Guards function isError(error: unknown): error is Error { return error instanceof Error; } // src/middleware/error.middleware.ts\u0026#39;de Error Handling function handleError(error: unknown): IApiResponse\u0026lt;null\u0026gt; { if (isError(error)) { return createResponse(false, error.message); } if (typeof error === \u0026#39;string\u0026#39;) { return createResponse(false, error); } return createResponse(false, \u0026#39;Unknown error occurred\u0026#39;); } // src/types/error.types.ts\u0026#39;de Discriminated Unions type ValidationError = { type: \u0026#39;validation\u0026#39;; fields: { [key: string]: string }; }; type AuthError = { type: \u0026#39;auth\u0026#39;; message: string; }; type AppError = ValidationError | AuthError; // src/utils/error-handler.ts\u0026#39;de Error Type Handling function handleAppError(error: AppError) { switch (error.type) { case \u0026#39;validation\u0026#39;: return error.fields; case \u0026#39;auth\u0026#39;: return error.message; } } Neden Bu Özellik?\nRuntime\u0026rsquo;da tip güvenliğini sağlıyoruz Hata yönetimini daha güvenli yapıyoruz Union type\u0026rsquo;ları doğru şekilde işliyoruz Projedeki Kullanım Örnekleri:\nisError type guard\u0026rsquo;ı middleware\u0026rsquo;lerde hata tipini doğru şekilde belirlememizi sağlıyor Error handling middleware\u0026rsquo;de farklı hata tiplerini ayırt edebiliyoruz Discriminated union\u0026rsquo;lar ile validation ve auth hatalarını ayrı ayrı işleyebiliyoruz Proje Özeti Geliştireceğimiz API aşağıdaki özellikleri içerecek:\nKullanıcı Yönetimi\nKayıt ve Giriş JWT Authentication Google OAuth Entegrasyonu Rol tabanlı yetkilendirme Todo İşlemleri\nTodo oluşturma, okuma, güncelleme, silme Kullanıcıya özel todo\u0026rsquo;lar Todo durumu değiştirme Güvenlik ve Validasyon\nInput validasyonu Route koruması Error handling Proje Yapısı Projemiz şu şekilde organize edilmiştir:\nsrc/ ├── config/ # Konfigürasyon dosyaları ├── controllers/ # HTTP request handlers ├── interfaces/ # TypeScript interfaces ├── middleware/ # Express middleware ├── models/ # Mongoose modelleri ├── routes/ # API routes ├── services/ # İş mantığı ├── utils/ # Yardımcı fonksiyonlar └── index.ts # Uygulama giriş noktası TypeScript ile Proje Geliştirme 1. Proje Kurulumu ve TypeScript Konfigürasyonu İlk adım olarak TypeScript\u0026rsquo;i projemize entegre edelim:\nmkdir nodejs-typescript-auth cd nodejs-typescript-auth npm init -y npm install typescript ts-node @types/node --save-dev Bağımlılıklar Projemiz için gerekli paketleri yükleyelim:\n# Ana bağımlılıklar npm install express mongoose dotenv jsonwebtoken bcrypt passport passport-google-oauth20 passport-jwt cors # Tip tanımlamaları npm install @types/express @types/mongoose @types/jsonwebtoken @types/bcrypt @types/passport @types/passport-google-oauth20 @types/passport-jwt @types/cors --save-dev TypeScript Konfigürasyonu { \u0026#34;compilerOptions\u0026#34;: { \u0026#34;target\u0026#34;: \u0026#34;es2016\u0026#34;, \u0026#34;module\u0026#34;: \u0026#34;commonjs\u0026#34;, \u0026#34;outDir\u0026#34;: \u0026#34;./dist\u0026#34;, \u0026#34;rootDir\u0026#34;: \u0026#34;./src\u0026#34;, \u0026#34;strict\u0026#34;: true, \u0026#34;esModuleInterop\u0026#34;: true, \u0026#34;skipLibCheck\u0026#34;: true, \u0026#34;forceConsistentCasingInFileNames\u0026#34;: true } } 2. Veri Modellerini Tanımlama User Modeli TypeScript interface\u0026rsquo;leri ile kullanıcı modelimizi tanımlayalım:\n// src/interfaces/user.interface.ts // Base interface - temel kullanıcı özellikleri interface IBaseUser { email: string; name: string; } // Ana kullanıcı interface\u0026#39;i - tüm özellikleri içerir interface IUser extends IBaseUser { password?: string; // Optional: Google OAuth kullanıcıları için şifre olmayabilir googleId?: string; // Optional: Sadece Google ile giriş yapanlar için role: \u0026#39;user\u0026#39; | \u0026#39;admin\u0026#39;; // Union type ile rol kısıtlaması comparePassword(candidatePassword: string): Promise\u0026lt;boolean\u0026gt;; } // Kayıt için gerekli alanlar interface IUserRegistration { email: string; password: string; name: string; } // Giriş için gerekli alanlar interface IUserLogin { email: string; password: string; } Todo Modeli Todo işlemleri için gerekli interface\u0026rsquo;leri tanımlayalım:\n// src/interfaces/todo.interface.ts interface ITodo { title: string; description?: string; completed: boolean; user: string; // Referans: User ID createdAt: Date; updatedAt: Date; } // Todo oluşturma için gerekli alanlar interface ICreateTodo { title: string; description?: string; } // Todo güncelleme için opsiyonel alanlar interface IUpdateTodo { title?: string; description?: string; completed?: boolean; } 3. Servis Katmanı Implementasyonu Base Service Generic bir base service oluşturarak kod tekrarını önleyelim:\n// src/services/base.service.ts abstract class BaseService\u0026lt;T\u0026gt; { constructor(protected model: Model\u0026lt;T\u0026gt;) {} async findById(id: string): Promise\u0026lt;T | null\u0026gt; { return this.model.findById(id); } async findOne(filter: FilterQuery\u0026lt;T\u0026gt;): Promise\u0026lt;T | null\u0026gt; { return this.model.findOne(filter); } async find(filter: FilterQuery\u0026lt;T\u0026gt;): Promise\u0026lt;T[]\u0026gt; { return this.model.find(filter); } } Auth Service Kimlik doğrulama işlemlerini yöneten servis:\n// src/services/auth.service.ts class AuthService extends BaseService\u0026lt;IUser\u0026gt; { public async register(userData: IUserRegistration): Promise\u0026lt;IUser\u0026gt; { const existingUser = await this.findOne({ email: userData.email }); if (existingUser) { throw new Error(\u0026#39;Bu email adresi zaten kullanımda\u0026#39;); } const user = await this.model.create(userData); return user; } public async login(loginData: IUserLogin): Promise\u0026lt;{ user: IUser; token: string }\u0026gt; { const user = await this.findOne({ email: loginData.email }); if (!user || !(await user.comparePassword(loginData.password))) { throw new Error(\u0026#39;Geçersiz kimlik bilgileri\u0026#39;); } return { user, token: this.generateToken(user), }; } private generateToken(user: IUser): string { return jwt.sign({ id: user._id, email: user.email, role: user.role }, process.env.JWT_SECRET!, { expiresIn: \u0026#39;1d\u0026#39; }); } } Todo Service Todo işlemlerini yöneten servis:\n// src/services/todo.service.ts class TodoService extends BaseService\u0026lt;ITodo\u0026gt; { public async getAllTodos(userId: string): Promise\u0026lt;ITodo[]\u0026gt; { return this.find({ user: userId }); } public async createTodo(todoData: ICreateTodo, userId: string): Promise\u0026lt;ITodo\u0026gt; { return this.model.create({ ...todoData, user: userId, completed: false, }); } public async updateTodo(todoId: string, todoData: Partial\u0026lt;ITodo\u0026gt;, userId: string): Promise\u0026lt;ITodo | null\u0026gt; { return this.model.findOneAndUpdate({ _id: todoId, user: userId }, todoData, { new: true }); } } 4. Middleware Implementasyonu TypeScript ile güvenli middleware yazımı:\n// src/middleware/auth.middleware.ts // Request tipini genişletme declare global { namespace Express { interface Request { user?: IUser; } } } export const isAuthenticated = async (req: Request, res: Response, next: NextFunction): Promise\u0026lt;void\u0026gt; =\u0026gt; { try { const token = req.headers.authorization?.split(\u0026#39; \u0026#39;)[1]; if (!token) { throw new Error(\u0026#39;Token bulunamadı\u0026#39;); } const decoded = jwt.verify(token, process.env.JWT_SECRET!) as IJwtPayload; const user = await UserModel.findById(decoded.id); if (!user) { throw new Error(\u0026#39;Kullanıcı bulunamadı\u0026#39;); } req.user = user; next(); } catch (error) { res.status(401).json({ success: false, message: \u0026#39;Yetkilendirme hatası\u0026#39;, error: error instanceof Error ? error.message : \u0026#39;Bilinmeyen hata\u0026#39;, }); } }; 5. Controller Katmanı TypeScript ile tip güvenli controller\u0026rsquo;lar:\n// src/controllers/todo.controller.ts class TodoController { constructor(private todoService: TodoService) {} public async getAllTodos(req: Request, res: Response): Promise\u0026lt;void\u0026gt; { try { const todos = await this.todoService.getAllTodos(req.user!._id); res.status(200).json({ success: true, message: \u0026#39;Todolar başarıyla getirildi\u0026#39;, data: todos, }); } catch (error) { res.status(500).json({ success: false, message: \u0026#39;Todolar getirilirken hata oluştu\u0026#39;, error: error instanceof Error ? error.message : \u0026#39;Bilinmeyen hata\u0026#39;, }); } } } API Endpoint\u0026rsquo;leri Auth Endpoints POST /api/auth/register - Request Body: { email: string, password: string, name: string } - Response: { success: boolean, message: string, data: { user: IUser, token: string } } POST /api/auth/login - Request Body: { email: string, password: string } - Response: { success: boolean, message: string, data: { user: IUser, token: string } } GET /api/auth/google - Google OAuth başlatma endpoint\u0026#39;i GET /api/auth/google/callback - Google OAuth callback endpoint\u0026#39;i Todo Endpoints GET /api/todos - Headers: { Authorization: \u0026#34;Bearer ${token}\u0026#34; } - Response: { success: boolean, message: string, data: ITodo[] } POST /api/todos - Headers: { Authorization: \u0026#34;Bearer ${token}\u0026#34; } - Request Body: { title: string, description?: string } - Response: { success: boolean, message: string, data: ITodo } PUT /api/todos/:id - Headers: { Authorization: \u0026#34;Bearer ${token}\u0026#34; } - Request Body: { title?: string, description?: string, completed?: boolean } - Response: { success: boolean, message: string, data: ITodo } DELETE /api/todos/:id - Headers: { Authorization: \u0026#34;Bearer ${token}\u0026#34; } - Response: { success: boolean, message: string } Best Practices Tip Güvenliği\nHer zaman spesifik tipler kullanın any tipinden kaçının Union types ile değer kümelerini sınırlayın Generic tipler ile yeniden kullanılabilir kod yazın Kod Organizasyonu\nHer bir katman için ayrı klasör kullanın Interface\u0026rsquo;leri ilgili domain klasöründe tutun Servis katmanını abstract class\u0026rsquo;lar ile genelleştirin Error Handling\nCustom error sınıfları oluşturun Global error handler kullanın Hata mesajlarını standardize edin Güvenlik\nHassas bilgileri environment variable\u0026rsquo;larda saklayın Input validasyonu yapın Rate limiting uygulayın CORS politikalarını doğru yapılandırın Sonuç Bu projede:\nTypeScript\u0026rsquo;in tip sistemi ile güvenli kod yazmayı OOP prensiplerini TypeScript ile uygulamayı Modern bir API mimarisi tasarlamayı Authentication ve authorization implementasyonunu öğrendik. TypeScript, projemize:\nDerleme zamanında hata yakalama Daha iyi IDE desteği Self-documenting kod Maintainability gibi önemli avantajlar sağladı. ",
    "tags": ["typescript","nodejs","microservices"],
    "categories": ["TypeScript","Node.js","Backend"],
    "lang": "tr"
} 