{
    "title": "TypeScript ile Güvenli ve Verimli Dosya İşleme Servisi Geliştirme",
    "permalink": "/tr/blog/typescript-serisi/understanding-typescript-part9/",
    "summary": "Bu makalede, TypeScript ve Node.js kullanarak büyük CSV dosyalarını güvenli bir şekilde yükleyebilen, hız sınırlaması, kimlik doğrulama ve sağlık izleme yeteneklerine sahip bir BFF (Backend for Frontend) dosya işleme servisi geliştirme sürecini inceleyeceğiz.",
    "content": "TypeScript ile Güvenli ve Verimli Dosya İşleme Servisi Geliştirme Büyük dosya yüklemeleri, her web uygulaması için zorlu bir konudur. Özellikle yüksek boyutlu CSV dosyaları söz konusu olduğunda, güvenlik, performans ve ölçeklenebilirlik faktörlerini dengeli bir şekilde ele almak gerekir. Bu makalede, TypeScript ve Node.js kullanarak oluşturduğumuz bir BFF (Backend for Frontend) dosya işleme servisinin geliştirilme sürecini adım adım inceleyeceğiz.\nProjemiz, 250MB gibi büyük CSV dosyalarını güvenli ve verimli bir şekilde yükleyebilen, hız sınırlaması, kimlik doğrulama ve sağlık izleme özelliklerine sahip bir mikroservis. Bu servisi geliştirirken modern yazılım mühendisliği prensiplerini ve TypeScript\u0026rsquo;in tip güvenliği avantajlarını nasıl kullandığımızı göstereceğiz.\nProje Gereksinimleri Bu projeyi geliştirirken aşağıdaki gereksinimleri karşılamamız gerekiyordu:\nDosya İşleme ve Depolama: Büyük CSV dosyalarını güvenli bir şekilde yükleyen REST API endpoint\u0026rsquo;i Dinamik Hız Sınırlaması: CPU ve bellek kullanımına göre otomatik ayarlanan rate limiting Sağlık İzleme: Sistem kaynaklarını ve bağımlılıkları izleyen health endpoint Dayanıklılık: Circuit breaker deseni ve exponential backoff stratejileri Hız Sınırlaması: Her istemci için 10 saniyede 1 istek ve maksimum 5 eşzamanlı dosya işleme Kimlik Doğrulama: Basic Authentication ile güvenli erişim Performans Metrikler: Yapılandırılmış loglama ve istek bazında takip Proje Yapısı Öncelikle projenin genel yapısını anlamak için dosya organizasyonunu inceleyelim:\nbff-file-handler/ ├── src/ │ ├── config/ # Konfigürasyon dosyaları │ ├── controllers/ # HTTP istek kontrolörleri │ ├── middlewares/ # Express middleware\u0026#39;leri │ ├── routes/ # API yönlendirmeleri │ ├── services/ # İş mantığı servisleri │ ├── utils/ # Yardımcı fonksiyonlar │ ├── app.ts # Express uygulaması │ └── server.ts # HTTP sunucusu ├── tests/ # Test dosyaları ├── uploads/ # Yüklenen dosyaların saklandığı dizin ├── package.json # Bağımlılıklar ve scriptler └── tsconfig.json # TypeScript konfigürasyonu Yapılandırma ve Bağımlılıklar Projemizin package.json dosyası aşağıdaki gibidir:\n{ \u0026#34;name\u0026#34;: \u0026#34;bff-file-handler\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;BFF File Handler Service\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;dist/server.js\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;start\u0026#34;: \u0026#34;node dist/server.js\u0026#34;, \u0026#34;dev\u0026#34;: \u0026#34;ts-node-dev --respawn --transpile-only src/server.ts\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;tsc\u0026#34;, \u0026#34;lint\u0026#34;: \u0026#34;eslint . --ext .ts\u0026#34;, \u0026#34;lint:fix\u0026#34;: \u0026#34;eslint . --ext .ts --fix\u0026#34;, \u0026#34;clean\u0026#34;: \u0026#34;rimraf dist coverage\u0026#34;, \u0026#34;test\u0026#34;: \u0026#34;jest\u0026#34;, \u0026#34;test:watch\u0026#34;: \u0026#34;jest --watch\u0026#34;, \u0026#34;test:coverage\u0026#34;: \u0026#34;jest --coverage\u0026#34; }, \u0026#34;repository\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;git\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;git+https://github.com/cagatayturkann/bff-file-handler.git\u0026#34; }, \u0026#34;keywords\u0026#34;: [ \u0026#34;bff\u0026#34;, \u0026#34;file-handler\u0026#34;, \u0026#34;typescript\u0026#34;, \u0026#34;node\u0026#34; ], \u0026#34;author\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;ISC\u0026#34;, \u0026#34;bugs\u0026#34;: { \u0026#34;url\u0026#34;: \u0026#34;https://github.com/cagatayturkann/bff-file-handler/issues\u0026#34; }, \u0026#34;homepage\u0026#34;: \u0026#34;https://github.com/cagatayturkann/bff-file-handler#readme\u0026#34;, \u0026#34;dependencies\u0026#34;: { \u0026#34;@types/express\u0026#34;: \u0026#34;^4.17.21\u0026#34;, \u0026#34;@types/multer\u0026#34;: \u0026#34;^1.4.11\u0026#34;, \u0026#34;@types/node\u0026#34;: \u0026#34;^20.11.24\u0026#34;, \u0026#34;cors\u0026#34;: \u0026#34;^2.8.5\u0026#34;, \u0026#34;dotenv\u0026#34;: \u0026#34;^16.4.5\u0026#34;, \u0026#34;express\u0026#34;: \u0026#34;^4.18.3\u0026#34;, \u0026#34;express-rate-limit\u0026#34;: \u0026#34;^7.1.5\u0026#34;, \u0026#34;helmet\u0026#34;: \u0026#34;^7.1.0\u0026#34;, \u0026#34;morgan\u0026#34;: \u0026#34;^1.10.0\u0026#34;, \u0026#34;multer\u0026#34;: \u0026#34;^1.4.5-lts.1\u0026#34;, \u0026#34;typescript\u0026#34;: \u0026#34;^5.3.3\u0026#34;, \u0026#34;uuid\u0026#34;: \u0026#34;^9.0.1\u0026#34;, \u0026#34;winston\u0026#34;: \u0026#34;^3.11.0\u0026#34; }, \u0026#34;devDependencies\u0026#34;: { \u0026#34;@types/cors\u0026#34;: \u0026#34;^2.8.17\u0026#34;, \u0026#34;@types/helmet\u0026#34;: \u0026#34;^4.0.0\u0026#34;, \u0026#34;@types/jest\u0026#34;: \u0026#34;^29.5.12\u0026#34;, \u0026#34;@types/morgan\u0026#34;: \u0026#34;^1.9.9\u0026#34;, \u0026#34;@types/uuid\u0026#34;: \u0026#34;^9.0.8\u0026#34;, \u0026#34;@typescript-eslint/eslint-plugin\u0026#34;: \u0026#34;^7.1.0\u0026#34;, \u0026#34;@typescript-eslint/parser\u0026#34;: \u0026#34;^7.1.0\u0026#34;, \u0026#34;eslint\u0026#34;: \u0026#34;^8.57.0\u0026#34;, \u0026#34;jest\u0026#34;: \u0026#34;^29.7.0\u0026#34;, \u0026#34;ts-jest\u0026#34;: \u0026#34;^29.1.2\u0026#34; }, \u0026#34;engines\u0026#34;: { \u0026#34;node\u0026#34;: \u0026#34;\u0026gt;=18.0.0\u0026#34; }, \u0026#34;jest\u0026#34;: { \u0026#34;preset\u0026#34;: \u0026#34;ts-jest\u0026#34;, \u0026#34;testEnvironment\u0026#34;: \u0026#34;node\u0026#34;, \u0026#34;roots\u0026#34;: [ \u0026#34;\u0026lt;rootDir\u0026gt;/tests\u0026#34; ], \u0026#34;testMatch\u0026#34;: [ \u0026#34;**/*.test.ts\u0026#34; ], \u0026#34;moduleFileExtensions\u0026#34;: [ \u0026#34;ts\u0026#34;, \u0026#34;js\u0026#34;, \u0026#34;json\u0026#34; ], \u0026#34;collectCoverageFrom\u0026#34;: [ \u0026#34;src/**/*.{ts,js}\u0026#34;, \u0026#34;!src/**/*.d.ts\u0026#34; ], \u0026#34;coverageDirectory\u0026#34;: \u0026#34;coverage\u0026#34;, \u0026#34;coverageReporters\u0026#34;: [ \u0026#34;text\u0026#34;, \u0026#34;lcov\u0026#34; ], \u0026#34;setupFilesAfterEnv\u0026#34;: [ \u0026#34;\u0026lt;rootDir\u0026gt;/tests/setup.ts\u0026#34; ] } } TypeScript yapılandırmamız ise tsconfig.json dosyasında bulunmaktadır:\n{ \u0026#34;compilerOptions\u0026#34;: { \u0026#34;target\u0026#34;: \u0026#34;es2018\u0026#34;, \u0026#34;lib\u0026#34;: [\u0026#34;es2018\u0026#34;, \u0026#34;esnext.asynciterable\u0026#34;], \u0026#34;module\u0026#34;: \u0026#34;commonjs\u0026#34;, \u0026#34;rootDir\u0026#34;: \u0026#34;./src\u0026#34;, \u0026#34;moduleResolution\u0026#34;: \u0026#34;node\u0026#34;, \u0026#34;resolveJsonModule\u0026#34;: true, \u0026#34;declaration\u0026#34;: true, \u0026#34;sourceMap\u0026#34;: true, \u0026#34;outDir\u0026#34;: \u0026#34;./dist\u0026#34;, \u0026#34;esModuleInterop\u0026#34;: true, \u0026#34;forceConsistentCasingInFileNames\u0026#34;: true, \u0026#34;strict\u0026#34;: true, \u0026#34;skipLibCheck\u0026#34;: true }, \u0026#34;include\u0026#34;: [\u0026#34;src/**/*\u0026#34;], \u0026#34;exclude\u0026#34;: [\u0026#34;node_modules\u0026#34;, \u0026#34;dist\u0026#34;, \u0026#34;coverage\u0026#34;, \u0026#34;**/*.test.ts\u0026#34;] } Express Uygulaması (app.ts) Express uygulamasının temel yapılandırması şu şekildedir:\nimport express from \u0026#39;express\u0026#39;; import cors from \u0026#39;cors\u0026#39;; import helmet from \u0026#39;helmet\u0026#39;; import morgan from \u0026#39;morgan\u0026#39;; import { v4 as uuidv4 } from \u0026#39;uuid\u0026#39;; import routes from \u0026#39;./routes\u0026#39;; import logger from \u0026#39;./utils/logger\u0026#39;; import config from \u0026#39;./config/config\u0026#39;; import { promises as fs } from \u0026#39;fs\u0026#39;; import path from \u0026#39;path\u0026#39;; const app = express(); // Ensure upload directory exists (async () =\u0026gt; { try { await fs.access(config.upload.uploadDir); } catch { await fs.mkdir(config.upload.uploadDir, { recursive: true }); } })(); // Security middleware app.use(helmet()); app.use(cors()); // Request ID middleware app.use((req, res, next) =\u0026gt; { req.headers[\u0026#39;x-request-id\u0026#39;] = req.headers[\u0026#39;x-request-id\u0026#39;] || uuidv4(); next(); }); // Logging middleware app.use(morgan(\u0026#39;combined\u0026#39;, { stream: { write: (message: string) =\u0026gt; { logger.info(message.trim()); }, }, })); // Body parser middleware app.use(express.json()); app.use(express.urlencoded({ extended: true })); // Routes app.use(\u0026#39;/api\u0026#39;, routes); // Error handling middleware app.use((err: Error, req: express.Request, res: express.Response, next: express.NextFunction) =\u0026gt; { logger.error(\u0026#39;Unhandled error\u0026#39;, { error: err.message, stack: err.stack, requestId: req.headers[\u0026#39;x-request-id\u0026#39;], }); res.status(500).json({ error: \u0026#39;Internal server error\u0026#39;, requestId: req.headers[\u0026#39;x-request-id\u0026#39;], }); }); // 404 handler app.use((req, res) =\u0026gt; { res.status(404).json({ error: \u0026#39;Not found\u0026#39;, requestId: req.headers[\u0026#39;x-request-id\u0026#39;], }); }); export default app; Burada birkaç önemli nokta:\nGüvenlik: Helmet ve CORS middleware\u0026rsquo;leri güvenliği artırmak için eklendi. İstek Tanımlama: Her istek için benzersiz bir x-request-id üretiliyor, bu loglama ve izleme için çok önemli. Yapılandırılmış Loglama: Morgan ve winston kullanarak kapsamlı bir loglama sistemi oluşturuldu. Hata Yönetimi: Merkezi hata işleme middleware\u0026rsquo;i ile tüm hatalar tutarlı bir şekilde ele alınıyor. Sunucu Başlatma ve Kapatma (server.ts) Sunucunun başlatılması ve graceful shutdown işlemi için server.ts dosyasını oluşturduk:\nimport app from \u0026#39;./app\u0026#39;; import config from \u0026#39;./config/config\u0026#39;; import logger from \u0026#39;./utils/logger\u0026#39;; import fileUploadService from \u0026#39;./services/fileUploadService\u0026#39;; const server = app.listen(config.server.port, () =\u0026gt; { logger.info(`Server is running on port ${config.server.port}`); logger.info(`Environment: ${config.server.nodeEnv}`); }); // Graceful shutdown const shutdown = async () =\u0026gt; { logger.info(\u0026#39;Shutting down server...\u0026#39;); server.close(async () =\u0026gt; { try { // Stop the cleanup interval fileUploadService.stopCleanup(); // Clean up resources await fileUploadService.cleanup(); // Flush logs logger.on(\u0026#39;finish\u0026#39;, () =\u0026gt; { process.exit(0); }); logger.info(\u0026#39;Server shutdown complete\u0026#39;); logger.end(); } catch (error) { logger.error(\u0026#39;Error during shutdown\u0026#39;, { error: error instanceof Error ? error.message : \u0026#39;Unknown error\u0026#39;, }); process.exit(1); } }); // Force shutdown after 30 seconds setTimeout(() =\u0026gt; { logger.error(\u0026#39;Forced shutdown after timeout\u0026#39;); process.exit(1); }, 30000); }; process.on(\u0026#39;SIGTERM\u0026#39;, shutdown); process.on(\u0026#39;SIGINT\u0026#39;, shutdown); Bu dosya:\nExpress uygulamasını belirtilen portta başlatır Graceful shutdown işlemini yönetir Kapatma sırasında kaynakları temizler ve logları kaydeder Kritik sinyalleri (SIGTERM, SIGINT) yakalar Konfigürasyon Yönetimi Projemizde konfigürasyon yönetimi için dotenv kullanıyoruz ve tüm yapılandırma değerlerini merkezi bir dosyada topluyoruz:\n// src/config/config.ts import dotenv from \u0026#39;dotenv\u0026#39;; import path from \u0026#39;path\u0026#39;; // Load environment variables from .env file dotenv.config(); const config = { server: { port: parseInt(process.env.PORT || \u0026#39;3000\u0026#39;, 10), nodeEnv: process.env.NODE_ENV || \u0026#39;development\u0026#39;, }, upload: { uploadDir: process.env.UPLOAD_DIR || path.join(process.cwd(), \u0026#39;uploads\u0026#39;), maxFileSize: parseInt(process.env.MAX_FILE_SIZE || \u0026#39;262144000\u0026#39;, 10), // 250MB allowedMimeTypes: (process.env.ALLOWED_MIME_TYPES || \u0026#39;text/csv\u0026#39;).split(\u0026#39;,\u0026#39;), tempFileLifetime: parseInt(process.env.TEMP_FILE_LIFETIME || \u0026#39;3600000\u0026#39;, 10), // 1 hour }, auth: { username: process.env.AUTH_USERNAME || \u0026#39;admin\u0026#39;, password: process.env.AUTH_PASSWORD || \u0026#39;password\u0026#39;, }, rateLimit: { windowMs: parseInt(process.env.RATE_LIMIT_WINDOW_MS || \u0026#39;600000\u0026#39;, 10), // 10 minutes max: parseInt(process.env.RATE_LIMIT_MAX || \u0026#39;1\u0026#39;, 10), // 1 request per window maxConcurrent: parseInt(process.env.MAX_CONCURRENT_UPLOADS || \u0026#39;5\u0026#39;, 10), }, logging: { level: process.env.LOG_LEVEL || \u0026#39;info\u0026#39;, directory: process.env.LOG_DIR || \u0026#39;logs\u0026#39;, }, }; export default config; Bu yapılandırma dosyası:\nOrtam değişkenlerini yükler Varsayılan değerler sağlar Tüm yapılandırma değerlerini tek bir nesne olarak dışa aktarır Tip Tanımlamaları TypeScript\u0026rsquo;in en güçlü yanlarından biri, kod tabanımızda kullanacağımız veri yapılarını açıkça tanımlayabilmemizdir. Dosya işleme sistemimiz için gerekli tipleri tanımlayalım:\n// src/types/file.ts export interface FileMetadata { originalName: string; size: number; mimeType: string; uploadDate: Date; processingStatus: FileProcessingStatus; path: string; requestId: string; } export enum FileProcessingStatus { PENDING = \u0026#39;pending\u0026#39;, PROCESSING = \u0026#39;processing\u0026#39;, COMPLETED = \u0026#39;completed\u0026#39;, FAILED = \u0026#39;failed\u0026#39;, } export interface UploadedFile { id: string; metadata: FileMetadata; } export interface FileUploadOptions { maxSize: number; allowedMimeTypes: string[]; } // src/types/health.ts export interface HealthStatus { status: \u0026#39;up\u0026#39; | \u0026#39;down\u0026#39; | \u0026#39;degraded\u0026#39;; uptime: number; timestamp: Date; services: { [key: string]: { status: \u0026#39;up\u0026#39; | \u0026#39;down\u0026#39;; message?: string; }; }; resources: { cpu: { usage: number; }; memory: { total: number; free: number; used: number; }; disk: { total: number; free: number; used: number; }; }; } Bu tip tanımlamaları, sistemimizin tüm bileşenlerinde tutarlı bir şekilde veri yapılarını kullanmamızı sağlar.\nMiddleware Katmanı Projemizde kullandığımız özel middleware\u0026rsquo;leri inceleyelim:\nKimlik Doğrulama Middleware\u0026rsquo;i // src/middlewares/authMiddleware.ts import { Request, Response, NextFunction } from \u0026#39;express\u0026#39;; import config from \u0026#39;../config/config\u0026#39;; import logger from \u0026#39;../utils/logger\u0026#39;; export const basicAuth = (req: Request, res: Response, next: NextFunction) =\u0026gt; { // Skip auth for health endpoint if (req.path === \u0026#39;/health\u0026#39;) { return next(); } // Get auth header const authHeader = req.headers.authorization; if (!authHeader) { logger.warn(\u0026#39;Authentication failed: No authorization header\u0026#39;, { requestId: req.headers[\u0026#39;x-request-id\u0026#39;], }); return res.status(401).json({ error: \u0026#39;Authentication required\u0026#39; }); } // Check if it\u0026#39;s Basic auth const [authType, credentials] = authHeader.split(\u0026#39; \u0026#39;); if (authType !== \u0026#39;Basic\u0026#39;) { logger.warn(\u0026#39;Authentication failed: Not Basic auth\u0026#39;, { requestId: req.headers[\u0026#39;x-request-id\u0026#39;], }); return res.status(401).json({ error: \u0026#39;Basic authentication required\u0026#39; }); } // Decode and verify credentials const decodedCredentials = Buffer.from(credentials, \u0026#39;base64\u0026#39;).toString(\u0026#39;utf-8\u0026#39;); const [username, password] = decodedCredentials.split(\u0026#39;:\u0026#39;); if (username !== config.auth.username || password !== config.auth.password) { logger.warn(\u0026#39;Authentication failed: Invalid credentials\u0026#39;, { requestId: req.headers[\u0026#39;x-request-id\u0026#39;], username, }); return res.status(401).json({ error: \u0026#39;Invalid credentials\u0026#39; }); } // Authentication successful next(); }; Hız Sınırlama Middleware\u0026rsquo;i // src/middlewares/rateLimitMiddleware.ts import rateLimit from \u0026#39;express-rate-limit\u0026#39;; import { Request, Response } from \u0026#39;express\u0026#39;; import config from \u0026#39;../config/config\u0026#39;; import logger from \u0026#39;../utils/logger\u0026#39;; import { getCpuUsage } from \u0026#39;../utils/systemMonitor\u0026#39;; // Track concurrent uploads let concurrentUploads = 0; // Create a rate limiter export const apiLimiter = rateLimit({ windowMs: config.rateLimit.windowMs, max: async (req: Request, res: Response) =\u0026gt; { // Dynamically adjust rate limit based on CPU usage const cpuUsage = await getCpuUsage(); // If CPU usage is high, reduce the limit if (cpuUsage \u0026gt; 80) { return Math.max(1, Math.floor(config.rateLimit.max / 2)); } return config.rateLimit.max; }, standardHeaders: true, legacyHeaders: false, message: { error: \u0026#39;Too many requests, please try again later\u0026#39;, }, keyGenerator: (req: Request) =\u0026gt; { // Use IP address or client ID for rate limiting return req.ip || req.headers[\u0026#39;x-forwarded-for\u0026#39;] as string || \u0026#39;unknown\u0026#39;; }, handler: (req: Request, res: Response) =\u0026gt; { logger.warn(\u0026#39;Rate limit exceeded\u0026#39;, { requestId: req.headers[\u0026#39;x-request-id\u0026#39;], ip: req.ip, }); res.status(429).json({ error: \u0026#39;Too many requests, please try again later\u0026#39;, requestId: req.headers[\u0026#39;x-request-id\u0026#39;], }); }, }); // Middleware to check concurrent uploads export const concurrentLimiter = (req: Request, res: Response, next: Function) =\u0026gt; { if (concurrentUploads \u0026gt;= config.rateLimit.maxConcurrent) { logger.warn(\u0026#39;Concurrent upload limit exceeded\u0026#39;, { requestId: req.headers[\u0026#39;x-request-id\u0026#39;], concurrentUploads, }); return res.status(429).json({ error: \u0026#39;Server is busy processing other uploads, please try again later\u0026#39;, requestId: req.headers[\u0026#39;x-request-id\u0026#39;], }); } // Increment counter concurrentUploads++; // Set up response listener to decrement counter when done res.on(\u0026#39;finish\u0026#39;, () =\u0026gt; { concurrentUploads = Math.max(0, concurrentUploads - 1); }); next(); }; Dosya Yükleme Kontrolörü Dosya yükleme işlemlerini yöneten kontrolör sınıfımız:\n// src/controllers/fileController.ts import { Request, Response } from \u0026#39;express\u0026#39;; import multer from \u0026#39;multer\u0026#39;; import { v4 as uuidv4 } from \u0026#39;uuid\u0026#39;; import fileUploadService from \u0026#39;../services/fileUploadService\u0026#39;; import logger from \u0026#39;../utils/logger\u0026#39;; import config from \u0026#39;../config/config\u0026#39;; // Configure multer for memory storage const storage = multer.memoryStorage(); const upload = multer({ storage, limits: { fileSize: config.upload.maxFileSize, }, fileFilter: (req, file, cb) =\u0026gt; { // Check if the file type is allowed if (config.upload.allowedMimeTypes.includes(file.mimetype)) { cb(null, true); } else { cb(new Error(`File type not allowed. Allowed types: ${config.upload.allowedMimeTypes.join(\u0026#39;, \u0026#39;)}`)); } }, }).single(\u0026#39;file\u0026#39;); export const uploadFile = (req: Request, res: Response) =\u0026gt; { // Use multer to handle the file upload upload(req, res, async (err) =\u0026gt; { if (err) { logger.error(\u0026#39;File upload error\u0026#39;, { error: err.message, requestId: req.headers[\u0026#39;x-request-id\u0026#39;], }); return res.status(400).json({ error: err.message, requestId: req.headers[\u0026#39;x-request-id\u0026#39;], }); } // Check if file exists if (!req.file) { logger.warn(\u0026#39;No file uploaded\u0026#39;, { requestId: req.headers[\u0026#39;x-request-id\u0026#39;], }); return res.status(400).json({ error: \u0026#39;No file uploaded\u0026#39;, requestId: req.headers[\u0026#39;x-request-id\u0026#39;], }); } try { // Generate a unique ID for the file const fileId = uuidv4(); // Process the file await fileUploadService.saveFile({ id: fileId, metadata: { originalName: req.file.originalname, size: req.file.size, mimeType: req.file.mimetype, uploadDate: new Date(), processingStatus: \u0026#39;pending\u0026#39;, path: \u0026#39;\u0026#39;, requestId: req.headers[\u0026#39;x-request-id\u0026#39;] as string, }, }, req.file.buffer); logger.info(\u0026#39;File uploaded successfully\u0026#39;, { fileId, fileName: req.file.originalname, fileSize: req.file.size, requestId: req.headers[\u0026#39;x-request-id\u0026#39;], }); // Return success response res.status(201).json({ message: \u0026#39;File uploaded successfully\u0026#39;, fileId, fileName: req.file.originalname, fileSize: req.file.size, requestId: req.headers[\u0026#39;x-request-id\u0026#39;], }); } catch (error) { logger.error(\u0026#39;Error processing uploaded file\u0026#39;, { error: error instanceof Error ? error.message : \u0026#39;Unknown error\u0026#39;, fileName: req.file.originalname, fileSize: req.file.size, requestId: req.headers[\u0026#39;x-request-id\u0026#39;], }); res.status(500).json({ error: \u0026#39;Error processing uploaded file\u0026#39;, details: error instanceof Error ? error.message : \u0026#39;Unknown error\u0026#39;, requestId: req.headers[\u0026#39;x-request-id\u0026#39;], }); } }); }; export const getFileStatus = async (req: Request, res: Response) =\u0026gt; { try { const fileId = req.params.id; if (!fileId) { return res.status(400).json({ error: \u0026#39;File ID is required\u0026#39;, requestId: req.headers[\u0026#39;x-request-id\u0026#39;], }); } const fileInfo = await fileUploadService.getFileInfo(fileId); if (!fileInfo) { return res.status(404).json({ error: \u0026#39;File not found\u0026#39;, requestId: req.headers[\u0026#39;x-request-id\u0026#39;], }); } res.status(200).json({ fileId, fileName: fileInfo.metadata.originalName, status: fileInfo.metadata.processingStatus, uploadDate: fileInfo.metadata.uploadDate, requestId: req.headers[\u0026#39;x-request-id\u0026#39;], }); } catch (error) { logger.error(\u0026#39;Error getting file status\u0026#39;, { error: error instanceof Error ? error.message : \u0026#39;Unknown error\u0026#39;, fileId: req.params.id, requestId: req.headers[\u0026#39;x-request-id\u0026#39;], }); res.status(500).json({ error: \u0026#39;Error getting file status\u0026#39;, details: error instanceof Error ? error.message : \u0026#39;Unknown error\u0026#39;, requestId: req.headers[\u0026#39;x-request-id\u0026#39;], }); } }; Dosya Yükleme Servisi Dosya işleme mantığını içeren servis sınıfımız:\n// src/services/fileUploadService.ts import { promises as fs } from \u0026#39;fs\u0026#39;; import path from \u0026#39;path\u0026#39;; import { UploadedFile, FileProcessingStatus } from \u0026#39;../types/file\u0026#39;; import logger from \u0026#39;../utils/logger\u0026#39;; import config from \u0026#39;../config/config\u0026#39;; class FileUploadService { private uploadDir: string; private files: Map\u0026lt;string, UploadedFile\u0026gt;; private cleanupInterval: NodeJS.Timeout | null = null; constructor(uploadDir: string) { this.uploadDir = uploadDir; this.files = new Map(); // Start cleanup interval this.startCleanupInterval(); } private startCleanupInterval() { this.cleanupInterval = setInterval(() =\u0026gt; { this.cleanupOldFiles().catch(err =\u0026gt; { logger.error(\u0026#39;Error during automatic cleanup\u0026#39;, { error: err instanceof Error ? err.message : \u0026#39;Unknown error\u0026#39;, }); }); }, config.upload.tempFileLifetime); } public stopCleanup() { if (this.cleanupInterval) { clearInterval(this.cleanupInterval); this.cleanupInterval = null; } } public async saveFile(file: UploadedFile, buffer: Buffer): Promise\u0026lt;void\u0026gt; { try { // Create file path const filePath = path.join(this.uploadDir, `${file.id}.csv`); // Update file metadata file.metadata.path = filePath; file.metadata.processingStatus = FileProcessingStatus.PROCESSING; // Save file to disk await fs.writeFile(filePath, buffer); // Store file info in memory this.files.set(file.id, file); // Process the file asynchronously this.processFile(file.id).catch(err =\u0026gt; { logger.error(\u0026#39;Error processing file\u0026#39;, { error: err instanceof Error ? err.message : \u0026#39;Unknown error\u0026#39;, fileId: file.id, requestId: file.metadata.requestId, }); }); } catch (error) { logger.error(\u0026#39;Error saving file\u0026#39;, { error: error instanceof Error ? error.message : \u0026#39;Unknown error\u0026#39;, fileId: file.id, requestId: file.metadata.requestId, }); throw error; } } private async processFile(fileId: string): Promise\u0026lt;void\u0026gt; { const file = this.files.get(fileId); if (!file) { throw new Error(`File not found: ${fileId}`); } try { // Simulate file processing await new Promise(resolve =\u0026gt; setTimeout(resolve, 2000)); // Update file status file.metadata.processingStatus = FileProcessingStatus.COMPLETED; this.files.set(fileId, file); logger.info(\u0026#39;File processed successfully\u0026#39;, { fileId, requestId: file.metadata.requestId, }); } catch (error) { // Update file status to failed file.metadata.processingStatus = FileProcessingStatus.FAILED; this.files.set(fileId, file); logger.error(\u0026#39;File processing failed\u0026#39;, { error: error instanceof Error ? error.message : \u0026#39;Unknown error\u0026#39;, fileId, requestId: file.metadata.requestId, }); throw error; } } public async getFileInfo(fileId: string): Promise\u0026lt;UploadedFile | null\u0026gt; { return this.files.get(fileId) || null; } public async cleanup(): Promise\u0026lt;void\u0026gt; { try { // Get all files in the upload directory const files = await fs.readdir(this.uploadDir); // Delete all files await Promise.all( files.map(async (file) =\u0026gt; { const filePath = path.join(this.uploadDir, file); await fs.unlink(filePath); }) ); // Clear the files map this.files.clear(); logger.info(\u0026#39;Cleanup completed successfully\u0026#39;); } catch (error) { logger.error(\u0026#39;Error during cleanup\u0026#39;, { error: error instanceof Error ? error.message : \u0026#39;Unknown error\u0026#39;, }); throw error; } } public async cleanupOldFiles(): Promise\u0026lt;void\u0026gt; { try { // Get all files in the upload directory const files = await fs.readdir(this.uploadDir); const now = Date.now(); // Check each file await Promise.all( files.map(async (file) =\u0026gt; { const filePath = path.join(this.uploadDir, file); const stats = await fs.stat(filePath); // Calculate file age const fileAge = now - stats.mtimeMs; // If file is older than the configured lifetime, delete it if (fileAge \u0026gt; config.upload.tempFileLifetime) { await fs.unlink(filePath); // Remove from memory if it exists const fileId = path.basename(file, path.extname(file)); if (this.files.has(fileId)) { this.files.delete(fileId); } logger.info(\u0026#39;Deleted old file\u0026#39;, { filePath, age: fileAge }); } }) ); } catch (error) { logger.error(\u0026#39;Error cleaning up old files\u0026#39;, { error: error instanceof Error ? error.message : \u0026#39;Unknown error\u0026#39;, }); throw error; } } } // Create and export service instance const fileUploadService = new FileUploadService(config.upload.uploadDir); export default fileUploadService; Sistem İzleme ve Sağlık Kontrolü Sistemimizin sağlığını izlemek için kapsamlı bir sağlık kontrolü mekanizması oluşturduk. Bu mekanizma, CPU kullanımı, bellek durumu ve disk alanı gibi sistem kaynaklarını izler ve raporlar.\n// src/controllers/healthController.ts import { Request, Response } from \u0026#39;express\u0026#39;; import { HealthStatus } from \u0026#39;../types/health\u0026#39;; import { getCpuUsage, getMemoryUsage, getDiskUsage } from \u0026#39;../utils/systemMonitor\u0026#39;; import logger from \u0026#39;../utils/logger\u0026#39;; export const getHealth = async (req: Request, res: Response) =\u0026gt; { try { // Get system metrics const [cpuUsage, memoryUsage, diskUsage] = await Promise.all([ getCpuUsage(), getMemoryUsage(), getDiskUsage(), ]); // Determine overall status let status: \u0026#39;up\u0026#39; | \u0026#39;down\u0026#39; | \u0026#39;degraded\u0026#39; = \u0026#39;up\u0026#39;; // If CPU usage is high, mark as degraded if (cpuUsage \u0026gt; 80) { status = \u0026#39;degraded\u0026#39;; } // If memory is low, mark as degraded if (memoryUsage.free / memoryUsage.total \u0026lt; 0.1) { status = \u0026#39;degraded\u0026#39;; } // If disk space is low, mark as degraded if (diskUsage.free / diskUsage.total \u0026lt; 0.1) { status = \u0026#39;degraded\u0026#39;; } // Create health status response const healthStatus: HealthStatus = { status, uptime: process.uptime(), timestamp: new Date(), services: { database: { status: \u0026#39;up\u0026#39;, // Placeholder - in a real app you\u0026#39;d check DB connection }, storage: { status: \u0026#39;up\u0026#39;, // Placeholder - in a real app you\u0026#39;d check storage service }, }, resources: { cpu: { usage: cpuUsage, }, memory: { total: memoryUsage.total, free: memoryUsage.free, used: memoryUsage.used, }, disk: { total: diskUsage.total, free: diskUsage.free, used: diskUsage.used, }, }, }; // Log health check logger.debug(\u0026#39;Health check performed\u0026#39;, { status, requestId: req.headers[\u0026#39;x-request-id\u0026#39;], }); // Return health status res.status(200).json(healthStatus); } catch (error) { logger.error(\u0026#39;Error getting health status\u0026#39;, { error: error instanceof Error ? error.message : \u0026#39;Unknown error\u0026#39;, requestId: req.headers[\u0026#39;x-request-id\u0026#39;], }); res.status(500).json({ status: \u0026#39;down\u0026#39;, error: \u0026#39;Error getting health status\u0026#39;, requestId: req.headers[\u0026#39;x-request-id\u0026#39;], }); } }; Sistem kaynaklarını izlemek için kullandığımız yardımcı fonksiyonlar:\n// src/utils/systemMonitor.ts import os from \u0026#39;os\u0026#39;; import { promises as fs } from \u0026#39;fs\u0026#39;; export async function getCpuUsage(): Promise\u0026lt;number\u0026gt; { return new Promise((resolve) =\u0026gt; { const startMeasure = os.cpus().map(cpu =\u0026gt; { return { idle: cpu.times.idle, total: Object.values(cpu.times).reduce((acc, time) =\u0026gt; acc + time, 0), }; }); // Measure after 100ms setTimeout(() =\u0026gt; { const endMeasure = os.cpus().map(cpu =\u0026gt; { return { idle: cpu.times.idle, total: Object.values(cpu.times).reduce((acc, time) =\u0026gt; acc + time, 0), }; }); // Calculate CPU usage const cpuUsage = startMeasure.map((start, i) =\u0026gt; { const end = endMeasure[i]; const idleDiff = end.idle - start.idle; const totalDiff = end.total - start.total; return 100 - (100 * idleDiff / totalDiff); }); // Return average CPU usage resolve(cpuUsage.reduce((acc, usage) =\u0026gt; acc + usage, 0) / cpuUsage.length); }, 100); }); } export async function getMemoryUsage(): Promise\u0026lt;{ total: number; free: number; used: number; }\u0026gt; { const totalMem = os.totalmem(); const freeMem = os.freemem(); return { total: totalMem, free: freeMem, used: totalMem - freeMem, }; } export async function getDiskUsage(): Promise\u0026lt;{ total: number; free: number; used: number; }\u0026gt; { try { // This is a simplified version that works on Linux // For a production app, you might want to use a cross-platform library const df = await fs.readFile(\u0026#39;/proc/mounts\u0026#39;, \u0026#39;utf8\u0026#39;); const rootFs = df.split(\u0026#39;\\n\u0026#39;) .find(line =\u0026gt; line.includes(\u0026#39; / \u0026#39;)) ?.split(\u0026#39; \u0026#39;)[0]; if (!rootFs) { throw new Error(\u0026#39;Could not determine root filesystem\u0026#39;); } const stats = await fs.stat(\u0026#39;/\u0026#39;); // This is a placeholder - in a real app you\u0026#39;d use a library like diskusage return { total: stats.blocks * 512, free: stats.blocks * 512 * 0.2, // Placeholder used: stats.blocks * 512 * 0.8, // Placeholder }; } catch (error) { // Fallback to dummy values if we can\u0026#39;t get disk usage return { total: 1000000000, free: 200000000, used: 800000000, }; } } API Rotaları API rotalarını tanımlayan dosyamız:\n// src/routes/index.ts import { Router } from \u0026#39;express\u0026#39;; import { uploadFile, getFileStatus } from \u0026#39;../controllers/fileController\u0026#39;; import { getHealth } from \u0026#39;../controllers/healthController\u0026#39;; import { basicAuth } from \u0026#39;../middlewares/authMiddleware\u0026#39;; import { apiLimiter, concurrentLimiter } from \u0026#39;../middlewares/rateLimitMiddleware\u0026#39;; const router = Router(); // Apply authentication middleware to all routes router.use(basicAuth); // Health check endpoint router.get(\u0026#39;/health\u0026#39;, getHealth); // File upload endpoint with rate limiting router.post(\u0026#39;/files\u0026#39;, apiLimiter, concurrentLimiter, uploadFile); // File status endpoint router.get(\u0026#39;/files/:id\u0026#39;, getFileStatus); export default router; Loglama Sistemi Yapılandırılmış loglama için Winston kullanıyoruz:\n// src/utils/logger.ts import winston from \u0026#39;winston\u0026#39;; import path from \u0026#39;path\u0026#39;; import config from \u0026#39;../config/config\u0026#39;; // Create logs directory if it doesn\u0026#39;t exist const { createLogger, format, transports } = winston; const { combine, timestamp, printf, colorize, json } = format; // Custom format for console logs const consoleFormat = printf(({ level, message, timestamp, ...metadata }) =\u0026gt; { let metaStr = \u0026#39;\u0026#39;; if (Object.keys(metadata).length \u0026gt; 0) { metaStr = JSON.stringify(metadata); } return `${timestamp} [${level}]: ${message} ${metaStr}`; }); // Create logger const logger = createLogger({ level: config.logging.level, format: combine( timestamp(), json() ), defaultMeta: { service: \u0026#39;bff-file-handler\u0026#39; }, transports: [ // Console transport new transports.Console({ format: combine( colorize(), timestamp(), consoleFormat ), }), // File transport for errors new transports.File({ filename: path.join(config.logging.directory, \u0026#39;error.log\u0026#39;), level: \u0026#39;error\u0026#39;, }), // File transport for all logs new transports.File({ filename: path.join(config.logging.directory, \u0026#39;combined.log\u0026#39;), }), ], }); // Create logs directory (async () =\u0026gt; { try { const fs = await import(\u0026#39;fs/promises\u0026#39;); await fs.mkdir(config.logging.directory, { recursive: true }); } catch (error) { console.error(\u0026#39;Error creating logs directory:\u0026#39;, error); } })(); export default logger; Testler Projemizde Jest kullanarak birim ve entegrasyon testleri yazıyoruz. İşte bir örnek test dosyası:\n// tests/controllers/fileController.test.ts import request from \u0026#39;supertest\u0026#39;; import app from \u0026#39;../../src/app\u0026#39;; import fileUploadService from \u0026#39;../../src/services/fileUploadService\u0026#39;; import { v4 as uuidv4 } from \u0026#39;uuid\u0026#39;; import { FileProcessingStatus } from \u0026#39;../../src/types/file\u0026#39;; // Mock file upload service jest.mock(\u0026#39;../../src/services/fileUploadService\u0026#39;); describe(\u0026#39;File Controller\u0026#39;, () =\u0026gt; { beforeEach(() =\u0026gt; { jest.clearAllMocks(); }); describe(\u0026#39;POST /api/files\u0026#39;, () =\u0026gt; { it(\u0026#39;should upload a file successfully\u0026#39;, async () =\u0026gt; { // Mock the saveFile method const mockFileId = uuidv4(); (fileUploadService.saveFile as jest.Mock).mockResolvedValue(undefined); // Create a test CSV file const testCsvContent = \u0026#39;id,name,email\\n1,John Doe,john@example.com\u0026#39;; // Make the request const response = await request(app) .post(\u0026#39;/api/files\u0026#39;) .auth(\u0026#39;admin\u0026#39;, \u0026#39;password\u0026#39;) .attach(\u0026#39;file\u0026#39;, Buffer.from(testCsvContent), { filename: \u0026#39;test.csv\u0026#39;, contentType: \u0026#39;text/csv\u0026#39;, }); // Check the response expect(response.status).toBe(201); expect(response.body).toHaveProperty(\u0026#39;fileId\u0026#39;); expect(response.body).toHaveProperty(\u0026#39;message\u0026#39;, \u0026#39;File uploaded successfully\u0026#39;); // Check that the service was called expect(fileUploadService.saveFile).toHaveBeenCalled(); }); it(\u0026#39;should return 400 if no file is uploaded\u0026#39;, async () =\u0026gt; { // Make the request without a file const response = await request(app) .post(\u0026#39;/api/files\u0026#39;) .auth(\u0026#39;admin\u0026#39;, \u0026#39;password\u0026#39;); // Check the response expect(response.status).toBe(400); expect(response.body).toHaveProperty(\u0026#39;error\u0026#39;, \u0026#39;No file uploaded\u0026#39;); }); it(\u0026#39;should return 400 if file type is not allowed\u0026#39;, async () =\u0026gt; { // Make the request with a non-CSV file const response = await request(app) .post(\u0026#39;/api/files\u0026#39;) .auth(\u0026#39;admin\u0026#39;, \u0026#39;password\u0026#39;) .attach(\u0026#39;file\u0026#39;, Buffer.from(\u0026#39;test content\u0026#39;), { filename: \u0026#39;test.txt\u0026#39;, contentType: \u0026#39;text/plain\u0026#39;, }); // Check the response expect(response.status).toBe(400); expect(response.body.error).toContain(\u0026#39;File type not allowed\u0026#39;); }); }); describe(\u0026#39;GET /api/files/:id\u0026#39;, () =\u0026gt; { it(\u0026#39;should return file status\u0026#39;, async () =\u0026gt; { // Mock the getFileInfo method const mockFileId = uuidv4(); (fileUploadService.getFileInfo as jest.Mock).mockResolvedValue({ id: mockFileId, metadata: { originalName: \u0026#39;test.csv\u0026#39;, size: 100, mimeType: \u0026#39;text/csv\u0026#39;, uploadDate: new Date(), processingStatus: FileProcessingStatus.COMPLETED, path: \u0026#39;/path/to/file\u0026#39;, requestId: \u0026#39;test-request-id\u0026#39;, }, }); // Make the request const response = await request(app) .get(`/api/files/${mockFileId}`) .auth(\u0026#39;admin\u0026#39;, \u0026#39;password\u0026#39;); // Check the response expect(response.status).toBe(200); expect(response.body).toHaveProperty(\u0026#39;fileId\u0026#39;, mockFileId); expect(response.body).toHaveProperty(\u0026#39;status\u0026#39;, FileProcessingStatus.COMPLETED); }); it(\u0026#39;should return 404 if file is not found\u0026#39;, async () =\u0026gt; { // Mock the getFileInfo method to return null (fileUploadService.getFileInfo as jest.Mock).mockResolvedValue(null); // Make the request const response = await request(app) .get(`/api/files/${uuidv4()}`) .auth(\u0026#39;admin\u0026#39;, \u0026#39;password\u0026#39;); // Check the response expect(response.status).toBe(404); expect(response.body).toHaveProperty(\u0026#39;error\u0026#39;, \u0026#39;File not found\u0026#39;); }); }); }); Projenin Güçlü Yanları Bu BFF File Handler projesi, TypeScript\u0026rsquo;in güçlü tip sistemini kullanarak birçok avantaj sağlıyor:\nTip Güvenliği: TypeScript\u0026rsquo;in statik tip sistemi sayesinde, kodumuzun farklı bölümleri arasında veri alışverişi güvenli bir şekilde gerçekleşiyor. Bu, çalışma zamanı hatalarını azaltıyor.\nKod Organizasyonu: Sorumluluk ayrımı prensibi (SRP) ile tasarlanmış modüler yapı, kodun bakımını ve genişletilmesini kolaylaştırıyor.\nGüvenlik Önlemleri: Helmet, rate limiting, kimlik doğrulama gibi güvenlik önlemleri, servisi dış tehditlere karşı koruyor.\nÖlçeklenebilirlik: Dinamik hız sınırlaması ve eşzamanlı işlem kontrolü, sistemin yüksek yük altında bile stabil kalmasını sağlıyor.\nİzlenebilirlik: Yapılandırılmış loglama ve istek ID\u0026rsquo;leri, sorun giderme ve performans izleme süreçlerini kolaylaştırıyor.\nDayanıklılık: Graceful shutdown ve hata yönetimi mekanizmaları, sistemin beklenmedik durumlarda bile düzgün çalışmasını sağlıyor.\nSonuç Bu projede, TypeScript ve Node.js kullanarak güvenli, ölçeklenebilir ve dayanıklı bir dosya işleme servisi geliştirdik. TypeScript\u0026rsquo;in sunduğu avantajlar, bu tür karmaşık sistemlerin geliştirilmesinde büyük fayda sağlamaktadır.\nBu tür bir servis, büyük dosyaların güvenli bir şekilde işlenmesi gereken finans, sağlık, e-ticaret gibi alanlarda kritik öneme sahiptir. TypeScript\u0026rsquo;in sunduğu avantajlar, bu tür karmaşık sistemlerin geliştirilmesinde büyük fayda sağlamaktadır.\nTypeScript serimizin bir sonraki bölümünde görüşmek üzere!\n",
    "tags": ["typescript","nodejs","microservices"],
    "categories": ["TypeScript","Node.js","Backend"],
    "lang": "tr"
} 