{
    "title": "TypeScript'i Anlamak - Bölüm 2: Fonksiyonlar",
    "permalink": "/tr/blog/typescript-serisi/typescripti-anlamak-bolum2/",
    "summary": "Bu makalede, TypeScript fonksiyonlarını detaylı bir şekilde inceleyeceğiz. Parametre tipleri, dönüş tipleri ve TypeScript\u0026rsquo;i benzersiz ve güçlü kılan özel fonksiyon tiplerini ele alacağız.",
    "content": "Merhaba! Önceki yazımızda TypeScript\u0026rsquo;teki temel tipleri incelemiştik. Bugün, fonksiyonları ve TypeScript\u0026rsquo;in onları nasıl daha güçlü ve güvenli hale getirdiğini öğreneceğiz. Basit örneklerle başlayıp, adım adım daha ileri konulara geçeceğiz.\nFonksiyon Parametre Tipleri TypeScript\u0026rsquo;te fonksiyon parametrelerinin tipini belirleyebiliriz. Bu özellik, yanlış tip bir değer gönderildiğinde daha kod çalıştırılmadan hata almamızı sağlar. Basit bir örnekle başlayalım:\n// Tipli parametrelerle fonksiyon oluşturma const ogrenciyiCesaretle = (isim: string) =\u0026gt; { return `Hey, ${isim}, harika gidiyorsun!`; }; // Bu çalışır ogrenciyiCesaretle(\u0026#39;sen\u0026#39;); // Çıktı: \u0026#34;Hey, sen, harika gidiyorsun!\u0026#34; // Bu TypeScript hatası verir ogrenciyiCesaretle(85); // Hata: \u0026#39;number\u0026#39; tipi \u0026#39;string\u0026#39; tipine atanamaz Her parametreden sonra yazdığımız tip açıklaması (örneğin : string), TypeScript\u0026rsquo;e bu fonksiyonun hangi tipte değerler bekleyeceğini söyler. Bu sayede hataları daha kod yazarken yakalayabiliriz.\nÇoklu Parametreler Fonksiyonlar birden fazla parametre alabilir ve her parametrenin kendi tipini belirleyebiliriz:\nfunction kullaniciOlustur(isim: string, yas: number, aktifMi: boolean) { return { isim, yas, aktifMi, }; } // Doğru kullanım kullaniciOlustur(\u0026#39;Ahmet\u0026#39;, 25, true); // TypeScript bu hataları yakalar kullaniciOlustur(\u0026#39;Ahmet\u0026#39;, \u0026#39;25\u0026#39;, true); // Hata: yaş number olmalı kullaniciOlustur(\u0026#39;Ahmet\u0026#39;); // Hata: eksik parametreler kullaniciOlustur(\u0026#39;Ahmet\u0026#39;, 25, \u0026#39;evet\u0026#39;); // Hata: aktifMi boolean olmalı Bu örnekte kullaniciOlustur fonksiyonu üç farklı tipte parametre alıyor. TypeScript, bu parametrelerin doğru tipte ve eksiksiz gönderildiğinden emin olmamızı sağlıyor.\nFonksiyon Dönüş Tipleri TypeScript ile bir fonksiyonun hangi tipte değer döndüreceğini de belirtebiliriz. TypeScript çoğu zaman dönüş tipini otomatik olarak anlayabilse de (buna type inference denir), açıkça belirtmek kodunuzu daha okunabilir ve bakımı kolay hale getirir:\nconst sayilariTopla = (x: number, y: number): number =\u0026gt; { return x + y; }; sayilariTopla(5, 5); // Dönüş: 10 const metinBirlestir = (a: string, b: string): string =\u0026gt; { return a + \u0026#39; \u0026#39; + b; }; metinBirlestir(\u0026#39;Merhaba\u0026#39;, \u0026#39;Dünya\u0026#39;); // Dönüş: \u0026#34;Merhaba Dünya\u0026#34; Bu örneklerde parametre listesinden sonra gelen : number ve : string ifadeleri, fonksiyonların hangi tipte değer döndüreceğini belirtir. Bu sayede:\nFonksiyonun ne döndüreceği konusunda dokümentasyon sağlamış oluruz Yanlış tipte bir değer döndürmeye çalıştığımızda hemen hata alırız Fonksiyonu kullanan diğer geliştiriciler, ne bekleyeceklerini önceden bilirler void Dönüş Tipi Bazen fonksiyonlarımız herhangi bir değer döndürmez, sadece bir işlem yaparlar. TypeScript\u0026rsquo;te bunu belirtmek için void tipini kullanırız:\nconst kullaniciyiUyar = (mesaj: string): void =\u0026gt; { alert(mesaj); // Hiçbir şey döndürmüyoruz }; const logla = (data: any): void =\u0026gt; { console.log(data); // return yazmadık bile }; void dönüş tipi, fonksiyonun bir değer döndürmeyeceğini söyler. Bu özellikle önemlidir çünkü:\nKodunuzu okuyan diğer geliştiriciler fonksiyondan bir değer beklememeleri gerektiğini bilirler Yanlışlıkla bir değer döndürmeye çalışırsanız TypeScript hata verir API\u0026rsquo;lerinizi daha net ve anlaşılır hale getirir Opsiyonel Parametreler ve Varsayılan Değerler TypeScript\u0026rsquo;te parametreleri iki şekilde esnek hale getirebiliriz: opsiyonel parametreler ve varsayılan değerler.\nOpsiyonel Parametreler Bir parametrenin sonuna ? işareti koyarak o parametrenin opsiyonel olduğunu belirtiriz:\nfunction kisiSelam(isim: string, unvan?: string) { if (unvan) { return `Merhaba ${unvan} ${isim}`; } return `Merhaba ${isim}`; } kisiSelam(\u0026#39;Ahmet\u0026#39;); // Çıktı: \u0026#34;Merhaba Ahmet\u0026#34; kisiSelam(\u0026#39;Ahmet\u0026#39;, \u0026#39;Dr.\u0026#39;); // Çıktı: \u0026#34;Merhaba Dr. Ahmet\u0026#34; Varsayılan Değerler Parametrelere varsayılan değerler atayarak, değer gönderilmediğinde ne kullanılacağını belirleyebiliriz:\nfunction kahveSiparis(kahveTuru: string = \u0026#39;Americano\u0026#39;, boyut: string = \u0026#39;orta\u0026#39;, sut: boolean = false) { let siparis = `${boyut} boy ${kahveTuru}`; if (sut) siparis += \u0026#39; sütlü\u0026#39;; return siparis; } kahveSiparis(); // \u0026#34;orta boy Americano\u0026#34; kahveSiparis(\u0026#39;Latte\u0026#39;); // \u0026#34;orta boy Latte\u0026#34; kahveSiparis(\u0026#39;Espresso\u0026#39;, \u0026#39;küçük\u0026#39;); // \u0026#34;küçük boy Espresso\u0026#34; kahveSiparis(\u0026#39;Mocha\u0026#39;, \u0026#39;büyük\u0026#39;, true); // \u0026#34;büyük boy Mocha sütlü\u0026#34; Opsiyonel parametreler ve varsayılan değerler arasındaki farklar:\nOpsiyonel Parametreler (?)\nParametre gönderilmezse undefined olur Fonksiyon içinde kontrol etmeniz gerekir Daha esnek ama daha fazla kontrol gerektirir Varsayılan Değerler (= değer)\nParametre gönderilmezse belirlediğiniz değer kullanılır Ekstra kontrol gerektirmez Daha az esnek ama kullanımı daha kolay Önemli Nokta: Parametre Sırası Hem opsiyonel hem zorunlu parametreler kullanırken, zorunlu parametreler her zaman önce gelmelidir:\n// DOĞRU function dogru(zorunlu: string, opsiyonel?: string) {} // YANLIŞ - TypeScript hata verir function yanlis(opsiyonel?: string, zorunlu: string) {} // Hata! Bu kural varsayılan değerler için de geçerlidir:\n// DOĞRU function dogru2(zorunlu: string, varsayilan: string = \u0026#39;default\u0026#39;) {} // YANLIŞ function yanlis2(varsayilan: string = \u0026#39;default\u0026#39;, zorunlu: string) {} // Hata! Bu kurala uymak, kodunuzun daha mantıklı ve anlaşılır olmasını sağlar. Ayrıca JavaScript\u0026rsquo;in fonksiyon çağrılarını nasıl işlediğiyle de uyumludur.\nAnonim Fonksiyonlar ve Tip Çıkarımı TypeScript\u0026rsquo;in en güçlü özelliklerinden biri, tipleri otomatik olarak çıkarabilme yeteneğidir. Bu özellikle anonim fonksiyonlarda çok kullanışlıdır:\nconst sayilar = [1, 2, 3, 4, 5]; // TypeScript otomatik olarak \u0026#39;sayi\u0026#39; parametresinin number olduğunu anlar sayilar.forEach((sayi) =\u0026gt; { console.log(sayi.toFixed(2)); // TypeScript bunu güvenli buluyor }); // Dizi metotlarında da tip çıkarımı çalışır const kareler = sayilar.map((sayi) =\u0026gt; sayi * sayi); // kareler dizisinin tipi number[] olarak çıkarılır Tip çıkarımı kod yazarken işimizi kolaylaştırır, ancak her zaman tip belirtmemek kodunuzu daha az okunabilir hale getirebilir. Bu yüzden dengeyi iyi kurmak önemlidir.\nnever Tipi never tipi, TypeScript\u0026rsquo;te özel bir tiptir ve asla gerçekleşmeyecek durumları temsil eder. İki ana kullanım senaryosu vardır:\nSonsuz Döngüler: Asla tamamlanmayan fonksiyonlar function sonsuzdDongu(): never { while (true) { console.log(\u0026#39;Bu fonksiyon asla bitmeyecek!\u0026#39;); } } function sonsuzOzyineleme(): never { return sonsuzOzyineleme(); } Her Zaman Hata Fırlatan Fonksiyonlar: function hataFirlat(mesaj: string): never { throw new Error(mesaj); } function hataKontrol(deger: string | number) { if (typeof deger === \u0026#39;string\u0026#39;) { console.log(\u0026#39;Bu bir string:\u0026#39;, deger); } else if (typeof deger === \u0026#39;number\u0026#39;) { console.log(\u0026#39;Bu bir number:\u0026#39;, deger); } else { // Bu noktada deger tipi \u0026#39;never\u0026#39; olur // Çünkü buraya ulaşmak imkansızdır hataFirlat(\u0026#39;Bu asla olmamalı!\u0026#39;); } } never ile void arasındaki farkı anlamak önemlidir:\nvoid: Fonksiyon bir değer döndürmez never: Fonksiyon asla tamamlanmaz veya her zaman bir hata fırlatır Fonksiyon Aşırı Yüklemesi (Function Overloads) TypeScript\u0026rsquo;te bir fonksiyonu farklı parametre tipleriyle kullanmak istediğimizde fonksiyon aşırı yüklemesini kullanabiliriz:\n// Aşırı yükleme imzaları function birlestir(a: string, b: string): string; function birlestir(a: number, b: number): number; // Gerçek implementasyon function birlestir(a: string | number, b: string | number): string | number { if (typeof a === \u0026#39;string\u0026#39; \u0026amp;\u0026amp; typeof b === \u0026#39;string\u0026#39;) { return a.concat(b); } if (typeof a === \u0026#39;number\u0026#39; \u0026amp;\u0026amp; typeof b === \u0026#39;number\u0026#39;) { return a + b; } throw new Error(\u0026#39;Parametreler aynı tipte olmalıdır!\u0026#39;); } console.log(birlestir(\u0026#39;Merhaba, \u0026#39;, \u0026#39;Dünya\u0026#39;)); // \u0026#34;Merhaba, Dünya\u0026#34; console.log(birlestir(5, 10)); // 15 // birlestir(\u0026#34;5\u0026#34;, 10); // Hata! Bu kombinasyon tanımlı değil Fonksiyon aşırı yüklemesi sayesinde:\nAynı fonksiyonu farklı parametre tipleriyle kullanabiliriz Her kombinasyon için doğru dönüş tipini belirleyebiliriz TypeScript hangi kombinasyonların geçerli olduğunu kontrol eder En İyi Uygulamalar TypeScript fonksiyonları yazarken izlemeniz gereken bazı önemli pratikler vardır. İşte bu pratikler ve nedenleri:\nHer Zaman Parametre Tiplerini Belirtin\n// KÖTÜ function kotu(isim) { return `Merhaba ${isim}`; } // İYİ function iyi(isim: string): string { return `Merhaba ${isim}`; } Tip belirtmek kodunuzu daha okunabilir yapar ve hataları önler.\nDönüş Tiplerini Düşünün\n// Otomatik çıkarım bazen yeterlidir const topla = (a: number, b: number) =\u0026gt; a + b; // Ama karmaşık fonksiyonlarda dönüş tipini belirtmek daha iyidir function veriIsle(data: any[]): ProcessedData { // Karmaşık işlemler... return islenmisSonuc; } Opsiyonel Parametreleri Sona Koyun\n// KÖTÜ function kotu(opsiyonel?: string, zorunlu: string) {} // İYİ function iyi(zorunlu: string, opsiyonel?: string) {} any Tipinden Kaçının\n// KÖTÜ function herhangiVeri(data: any) { return data.birsey(); // Tehlikeli! } // İYİ function tipliVeri\u0026lt;T\u0026gt;(data: T) { // Tip güvenli işlemler } Fonksiyon Dokümantasyonu Yazın\n/** * Verilen sayıları toplar ve sonucu döndürür * @param sayilar - Toplanacak sayı dizisi * @returns Toplam değer */ function topla(...sayilar: number[]): number { return sayilar.reduce((a, b) =\u0026gt; a + b, 0); } Hızlı Başvuru İşte TypeScript\u0026rsquo;te en sık kullanılan fonksiyon yapılarının hızlı bir özeti:\n1. Temel Fonksiyon Tanımlamaları // Normal fonksiyon function selamla(isim: string): string { return `Merhaba ${isim}`; } // Ok fonksiyonu const selamla2 = (isim: string): string =\u0026gt; `Merhaba ${isim}`; 2. Parametre Çeşitleri // Opsiyonel parametre function log(mesaj: string, seviye?: string) {} // Varsayılan değerli parametre function baglan(url: string = \u0026#39;localhost\u0026#39;) {} // Rest parametresi function toplam(...sayilar: number[]): number { return sayilar.reduce((a, b) =\u0026gt; a + b, 0); } 3. Dönüş Tipleri // Değer döndüren function topla(a: number, b: number): number { return a + b; } // Void dönüş function logla(mesaj: string): void { console.log(mesaj); } // Never dönüş function hataFirlat(mesaj: string): never { throw new Error(mesaj); } 4. Fonksiyon Tipleri // Fonksiyon tipi tanımlama type MatematikIslemi = (a: number, b: number) =\u0026gt; number; // Fonksiyon tipi kullanma const toplama: MatematikIslemi = (a, b) =\u0026gt; a + b; const cikarma: MatematikIslemi = (a, b) =\u0026gt; a - b; Sonuç TypeScript\u0026rsquo;in fonksiyonlar için sunduğu tip sistemi, JavaScript geliştirmede çok değerli bir araçtır. Tip güvenliği sayesinde:\nHataları erken yakalarsınız Kodunuz daha okunabilir olur IDE desteği daha iyi çalışır Refactoring yapmak kolaylaşır Bu özelliklerin hepsi bir araya geldiğinde, daha güvenilir ve bakımı kolay uygulamalar geliştirmenize yardımcı olur.\n",
    "tags": ["typescript","javascript","fonksiyonlar"],
    "categories": ["TypeScript"],
    "lang": "tr"
} 