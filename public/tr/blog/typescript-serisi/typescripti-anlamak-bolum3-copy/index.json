{
    "title": "TypeScript'i Anlamak - Bölüm 3: Obje Tipleri",
    "permalink": "/tr/blog/typescript-serisi/typescripti-anlamak-bolum3-copy/",
    "summary": "Bu makalede, TypeScript\u0026rsquo;teki obje tiplerini detaylı bir şekilde inceleyeceğiz. Obje tanımlamaları, tip takma adları ve iç içe objelerle çalışmayı öğreneceğiz.",
    "content": "Merhaba! TypeScript serimizin bu bölümünde, object types konusunu detaylı bir şekilde inceleyeceğiz. Özellikle fonksiyonlarda obje tiplerinin nasıl kullanıldığına ve type alias\u0026rsquo;ların neden önemli olduğuna odaklanacağız.\nObject Annotations ile Çalışmak TypeScript\u0026rsquo;te fonksiyonlarda obje parametreleri tanımlarken iki farklı yaklaşım kullanabiliriz. İlk olarak, doğrudan fonksiyon parametresi içinde obje tipini tanımlayabiliriz:\n// Parametre içinde doğrudan obje tipi tanımlama const printName = (name: { first: string; last: string }) =\u0026gt; { return `Name: ${name.first} ${name.last}`; }; // Kullanımı printName({ first: \u0026#39;Will\u0026#39;, last: \u0026#39;Ferrell\u0026#39; }); Bu yaklaşım basit objeler için kullanışlı olsa da, karmaşık obje yapılarında okunabilirliği azaltabilir ve kod tekrarına yol açabilir. Özellikle aynı obje tipini birden fazla yerde kullanacaksanız, bu yaklaşım yerine type alias kullanmanız önerilir.\nSüslü Parantezlerin Kullanımı Fonksiyon parametrelerinde obje tiplerini tanımlarken süslü parantezlerin kullanımı bazen kafa karıştırıcı olabilir:\n// Kafa karıştırıcı olabilecek syntax const printPerson = (person: { name: string; age: number }): { info: string } =\u0026gt; { return { info: `${person.name} is ${person.age} years old` }; }; // Daha okunaklı versiyonu - Type Alias kullanarak type Person = { name: string; age: number; }; type PersonInfo = { info: string; }; const printPerson2 = (person: Person): PersonInfo =\u0026gt; { return { info: `${person.name} is ${person.age} years old` }; }; İkinci yaklaşım daha okunaklıdır çünkü:\nTip tanımlamaları fonksiyon tanımından ayrılmıştır Tipler yeniden kullanılabilir Kod daha düzenli ve bakımı daha kolaydır Type Alias Kullanımı Type alias\u0026rsquo;lar, obje tiplerini ayrı olarak tanımlamamıza ve bu tipleri kodumuzda tekrar tekrar kullanmamıza olanak sağlar:\n// Type alias tanımlama type Person = { name: string; age: number; }; // Fonksiyonda kullanma const sayHappyBirthday = (person: Person) =\u0026gt; { return `Hey ${person.name}, congrats on turning ${person.age}!`; }; // Değişkende kullanma const jerry: Person = { name: \u0026#39;Jerry\u0026#39;, age: 42, }; sayHappyBirthday(jerry); Type alias kullanmanın avantajları:\nKod tekrarını önler Tip tanımlarını merkezi bir yerde tutar Değişiklikleri tek bir yerden yönetmeyi sağlar Kodun okunabilirliğini artırır Nested Objects (İç İçe Objeler) TypeScript\u0026rsquo;te iç içe obje yapıları tanımlamak oldukça yaygındır. İşte bir örnek:\nconst describePerson = (person: { name: string; age: number; parentNames: { mom: string; dad: string; }; }) =\u0026gt; { return `Person: ${name}, Age: ${age}, Parents: ${parentNames.mom}, ${parentNames.dad}`; }; // Kullanımı describePerson({ name: \u0026#39;Jimmy\u0026#39;, age: 10, parentNames: { mom: \u0026#39;Kim\u0026#39;, dad: \u0026#39;Steve\u0026#39;, }, }); Bu yapıyı type alias kullanarak daha düzenli hale getirebiliriz:\ntype ParentNames = { mom: string; dad: string; }; type PersonWithParents = { name: string; age: number; parentNames: ParentNames; }; const describePerson2 = (person: PersonWithParents) =\u0026gt; { const { name, age, parentNames } = person; return `Person: ${name}, Age: ${age}, Parents: ${parentNames.mom}, ${parentNames.dad}`; }; Excess Properties (Fazla Özellikler) TypeScript, bir obje tipinde tanımlanmamış özellikleri kullanmaya çalıştığınızda sizi uyarır:\ntype BasicPerson = { name: string; age: number; }; // Hata verecek const person: BasicPerson = { name: \u0026#39;John\u0026#39;, age: 30, location: \u0026#39;New York\u0026#39;, // Fazla özellik hatası }; // Doğru kullanım const personData = { name: \u0026#39;John\u0026#39;, age: 30, location: \u0026#39;New York\u0026#39;, }; const person2: BasicPerson = personData; // Bu çalışır Optional Properties Bazen obje tipindeki bazı özelliklerin opsiyonel olmasını isteyebiliriz:\ntype OptionalPerson = { name: string; age: number; phone?: string; // Opsiyonel özellik email?: string; // Opsiyonel özellik }; // Her iki kullanım da geçerli const person1: OptionalPerson = { name: \u0026#39;Alice\u0026#39;, age: 25, }; const person2: OptionalPerson = { name: \u0026#39;Bob\u0026#39;, age: 30, phone: \u0026#39;555-0123\u0026#39;, email: \u0026#39;bob@email.com\u0026#39;, }; Readonly Modifier TypeScript\u0026rsquo;te readonly modifier, bir nesnenin özelliklerinin değiştirilmesini engellemek için kullanılır. Bu, veri bütünlüğünü korumak ve istenmeyen değişiklikleri önlemek için oldukça kullanışlıdır:\ntype Person = { readonly name: string; readonly age: number; }; const john: Person = { name: \u0026#39;John\u0026#39;, age: 30, }; // Aşağıdaki satırlar derleme zamanında hata verecektir // john.name = \u0026#34;Johnny\u0026#34;; // Hata: Cannot assign to \u0026#39;name\u0026#39; because it is a read-only property // john.age = 31; // Hata: Cannot assign to \u0026#39;age\u0026#39; because it is a read-only property readonly modifier, nesnenin ilk oluşturulması sırasında değer atamasına izin verir, ancak daha sonra bu özelliklerin değiştirilmesini engeller.\nReadonly Array Diziler için de readonly modifier kullanılabilir. Bu, dizinin içeriğinin değiştirilmesini engeller:\nconst numbers: readonly number[] = [1, 2, 3, 4, 5]; // Aşağıdaki metodlar artık kullanılamaz // numbers.push(6); // Hata // numbers.pop(); // Hata // numbers[2] = 10; // Hata Intersection Types Intersection types, birden fazla tipi birleştirerek yeni bir tip oluşturmamıza olanak sağlar:\ntype Employee = { employeeId: number; department: string; }; type Person = { name: string; age: number; }; // İki tipi birleştiren yeni bir tip type EmployeePerson = Employee \u0026amp; Person; const worker: EmployeePerson = { employeeId: 1234, department: \u0026#39;Engineering\u0026#39;, name: \u0026#39;Alice\u0026#39;, age: 30, }; Intersection types, karmaşık nesne yapıları oluştururken oldukça kullanışlıdır. Birden fazla tipin özelliklerini tek bir tipte birleştirebilirsiniz.\nIntersection Type Örneği Intersection type\u0026rsquo;ların nasıl kullanılabileceğini gösteren basit bir örneğe bakalım:\n// Adres bilgilerini içeren tip type Address = { street: string; city: string; country: string; }; // İletişim bilgilerini içeren tip type Contact = { email: string; phone: string; }; // İki tipi birleştirerek tam bir kullanıcı profili oluşturma type UserProfile = Person \u0026amp; Address \u0026amp; Contact; // Kullanım örneği: const user: UserProfile = { name: \u0026#39;Ahmet\u0026#39;, age: 30, street: \u0026#39;Atatürk Caddesi\u0026#39;, city: \u0026#39;İstanbul\u0026#39;, country: \u0026#39;Türkiye\u0026#39;, email: \u0026#39;ahmet@email.com\u0026#39;, phone: \u0026#39;555-0123\u0026#39; }; // Fonksiyonda kullanım örneği function displayUserInfo(user: UserProfile) { console.log(` Kullanıcı: ${user.name} Yaş: ${user.age} Adres: ${user.street}, ${user.city}, ${user.country} İletişim: ${user.email}, ${user.phone} `); } displayUserInfo(user); Bu örnek, intersection type\u0026rsquo;ların nasıl farklı özellikleri birleştirmek için kullanılabileceğini gösteriyor:\nTip Kompozisyonu: Farklı amaçlar için ayrı tipler tanımlıyoruz (Person, Address, Contact) Intersection Types: Bu tipleri \u0026amp; operatörü ile birleştirerek daha kapsamlı bir tip oluşturuyoruz Modülerlik: Her tip kendi sorumluluğuna sahip ve ayrı ayrı yönetilebilir Yeniden Kullanılabilirlik: Bu tipleri başka yerlerde de kullanabiliriz Bu desen özellikle şunları yapmak istediğinizde kullanışlıdır:\nFarklı veri gruplarını mantıksal olarak ayırmak Kodunuzu daha modüler hale getirmek Tip tanımlarını yeniden kullanmak Karmaşık veri yapılarını organize etmek Array Types TypeScript\u0026rsquo;te dizi tipleri birkaç farklı şekilde tanımlanabilir:\n// Birinci yöntem: Köşeli parantez kullanarak const numbers: number[] = [1, 2, 3, 4, 5]; // İkinci yöntem: Generic Array tipi kullanarak const strings: Array\u0026lt;string\u0026gt; = [\u0026#39;hello\u0026#39;, \u0026#39;world\u0026#39;]; // Karışık tip dizisi const mixed: (number | string)[] = [1, \u0026#39;two\u0026#39;, 3, \u0026#39;four\u0026#39;]; // Tuple (Sabit uzunlukta, farklı tiplerde dizi) const employee: [number, string] = [1, \u0026#39;John Doe\u0026#39;]; // Readonly dizi const readonlyNumbers: readonly number[] = [1, 2, 3]; Dizi Metodları ve Tip Çıkarımı TypeScript, dizi metodlarında akıllı tip çıkarımı yapar:\nconst numbers = [1, 2, 3, 4, 5]; const doubled = numbers.map((x) =\u0026gt; x * 2); // doubled tipi number[] const names = [\u0026#39;Alice\u0026#39;, \u0026#39;Bob\u0026#39;, \u0026#39;Charlie\u0026#39;]; const upperNames = names.map((name) =\u0026gt; name.toUpperCase()); // upperNames tipi string[] Çok Boyutlu Diziler (Multi-Dimensional Arrays) TypeScript\u0026rsquo;te çok boyutlu diziler, iç içe diziler veya matris benzeri veri yapıları oluşturmak için kullanılır:\n// 2 Boyutlu sayı dizisi const matrix: number[][] = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ]; // 3 Boyutlu dizi örneği const threeDimensionalArray: number[][][] = [ [ [1, 2], [3, 4], ], [ [5, 6], [7, 8], ], [ [9, 10], [11, 12], ], ]; // Karışık tipli 2 boyutlu dizi const mixedMatrix: (number | string)[][] = [ [1, \u0026#39;two\u0026#39;, 3], [\u0026#39;four\u0026#39;, 5, \u0026#39;six\u0026#39;], ]; // Çok boyutlu dizi üzerinde işlemler const sumMatrix = (matrix: number[][]): number =\u0026gt; { return matrix.flat().reduce((sum, num) =\u0026gt; sum + num, 0); }; console.log(sumMatrix(matrix)); // Tüm elemanların toplamını verir // Dizi boyutunu kontrol etme const printMatrixInfo = (matrix: number[][]) =\u0026gt; { console.log(`Matris boyutu: ${matrix.length} x ${matrix[0].length}`); }; printMatrixInfo(matrix); // \u0026#34;Matris boyutu: 3 x 3\u0026#34; çıktısı verir Çok boyutlu diziler, özellikle görüntü işleme, oyun geliştirme, bilimsel hesaplamalar gibi alanlarda sıkça kullanılır. TypeScript, bu tür karmaşık dizi yapılarında güçlü tip kontrolü sağlar.\nSonuç TypeScript\u0026rsquo;in object types özellikleri, kodunuzun tip güvenliğini artırır ve daha net, hata ayıklaması kolay kod yazmanıza yardımcı olur. readonly modifier, intersection types, esnek dizi tipleri ve çok boyutlu diziler, TypeScript\u0026rsquo;in güçlü tip sisteminin önemli parçalarıdır.\nBir sonraki yazımızda görüşmek üzere!\n",
    "tags": ["typescript","javascript","object-types"],
    "categories": ["TypeScript"],
    "lang": "tr"
} 