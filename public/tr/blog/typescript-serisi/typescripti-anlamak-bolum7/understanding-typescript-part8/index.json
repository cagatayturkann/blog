{
    "title": "TypeScript'i Anlamak - Bölüm 8: Type Narrowing",
    "permalink": "/tr/blog/typescript-serisi/typescripti-anlamak-bolum7/understanding-typescript-part8/",
    "summary": "Bu makalede, TypeScript\u0026rsquo;te type narrowing (tip daraltma) tekniklerini inceleyeceğiz. typeof, instanceof, type predicates gibi tip kontrol yöntemlerini ve discriminated unions yapısını ele alacağız.",
    "content": "Merhaba! TypeScript serimizin bu bölümünde, tip sisteminin en güçlü özelliklerinden biri olan type narrowing (tip daraltma) konusunu inceleyeceğiz. Type narrowing, bir değişkenin tipini daha spesifik bir tipe daraltmamızı sağlayan tekniklerin genel adıdır. Bu teknikler sayesinde, union type\u0026rsquo;lar ve karmaşık tip yapıları ile daha güvenli bir şekilde çalışabiliriz.\nType Narrowing Nedir? Type narrowing, TypeScript\u0026rsquo;in bir değişkenin tipini bağlam içinde daha spesifik bir tipe daraltma yeteneğidir. Bu özellik, özellikle union type\u0026rsquo;lar ile çalışırken çok kullanışlıdır. Örneğin, bir değişken string veya number olabilir, ancak belirli bir kod bloğunda bu değişkenin kesinlikle string olduğunu biliyorsak, TypeScript bu bilgiyi kullanarak tip güvenliğini artırır.\ntypeof Type Guards typeof operatörü, TypeScript\u0026rsquo;te en temel type narrowing yöntemlerinden biridir:\nconst isTeenager = (age: number | string) =\u0026gt; { if (typeof age === \u0026#39;string\u0026#39;) { // Bu blokta age kesinlikle string return age.charAt(0) === \u0026#39;1\u0026#39;; } else { // Bu blokta age kesinlikle number return age \u0026gt; 12 \u0026amp;\u0026amp; age \u0026lt; 20; } }; isTeenager(\u0026#39;20\u0026#39;); // false isTeenager(13); // true typeof type guard kullanmanın avantajları:\nTip güvenliği sağlar IDE desteği ve kod tamamlama özelliklerini iyileştirir Runtime hataları önler Kodun okunabilirliğini artırır Truthiness Type Guards JavaScript\u0026rsquo;in truthiness özelliğini kullanarak da type narrowing yapabiliriz:\nconst printLetters = (word: string | null) =\u0026gt; { if (!word) { console.log(\u0026#39;No word was provided.\u0026#39;); return; } // Bu noktada word kesinlikle string word.split(\u0026#39;\u0026#39;).forEach((letter) =\u0026gt; console.log(letter)); }; printLetters(\u0026#39;Hello\u0026#39;); // H, e, l, l, o printLetters(null); // No word was provided. Truthiness kontrolü şu değerleri false olarak değerlendirir:\nfalse 0 \u0026quot;\u0026quot; null undefined NaN Equality Type Narrowing Eşitlik karşılaştırmaları da TypeScript\u0026rsquo;te type narrowing için kullanılır:\nconst someFunc = (x: string | boolean, y: string | number) =\u0026gt; { if (x === y) { // Bu blokta x ve y kesinlikle string console.log(x.toUpperCase()); console.log(y.toLowerCase()); } else { // x: string | boolean // y: string | number console.log(x); console.log(y); } }; in Operator Type Guards JavaScript\u0026rsquo;in in operatörü, bir özelliğin bir objede var olup olmadığını kontrol eder. TypeScript bu kontrolü type narrowing için kullanır:\ntype Cat = { meow: () =\u0026gt; void }; type Dog = { bark: () =\u0026gt; void }; const talk = (creature: Cat | Dog) =\u0026gt; { if (\u0026#39;meow\u0026#39; in creature) { // Bu blokta creature kesinlikle Cat creature.meow(); } else { // Bu blokta creature kesinlikle Dog creature.bark(); } }; const kitty: Cat = { meow: () =\u0026gt; console.log(\u0026#39;MEOWWW\u0026#39;) }; talk(kitty); // MEOWWW instanceof Narrowing instanceof operatörü, bir değişkenin belirli bir sınıfın örneği olup olmadığını kontrol eder:\nconst printFullDate = (date: Date | string) =\u0026gt; { if (date instanceof Date) { // Bu blokta date kesinlikle Date return date.toUTCString(); } else { // Bu blokta date kesinlikle string return new Date(date).toUTCString(); } }; console.log(printFullDate(new Date())); console.log(printFullDate(\u0026#39;2025-02-21\u0026#39;)); Type Predicates TypeScript\u0026rsquo;te özel type guard fonksiyonları yazabilirsiniz. Bu fonksiyonlar, parameterName is Type formatında bir dönüş tipine sahiptir:\ninterface Cat { meow: () =\u0026gt; void; } interface Dog { bark: () =\u0026gt; void; } // Type predicate function function isCat(pet: Cat | Dog): pet is Cat { return (pet as Cat).meow !== undefined; } let pet = getAnimal(); if (isCat(pet)) { // Bu blokta pet kesinlikle Cat pet.meow(); } else { // Bu blokta pet kesinlikle Dog pet.bark(); } Type predicate\u0026rsquo;lerin avantajları:\nÖzel type guard mantığı yazabilirsiniz Kod tekrarını önler Tip kontrollerini merkezileştirir Okunabilirliği artırır Discriminated Unions Discriminated unions, ortak bir literal özellik kullanarak birbiriyle ilişkili tipleri ayırt etme tekniğidir:\ninterface Circle { kind: \u0026#39;circle\u0026#39;; radius: number; } interface Square { kind: \u0026#39;square\u0026#39;; sideLength: number; } type Shape = Circle | Square; function getArea(shape: Shape) { switch (shape.kind) { case \u0026#39;circle\u0026#39;: // Bu blokta shape kesinlikle Circle return Math.PI * shape.radius ** 2; case \u0026#39;square\u0026#39;: // Bu blokta shape kesinlikle Square return shape.sideLength ** 2; } } Discriminated unions\u0026rsquo;ın avantajları:\nTip güvenliği sağlar Switch case ile kullanımı kolaydır IDE desteği mükemmeldir Yeni tip eklemek kolaydır Eksik case\u0026rsquo;leri derleme zamanında yakalar Best Practices Doğru Type Guard Seçimi\n// Basit tipler için typeof function processValue(value: string | number) { if (typeof value === \u0026#39;string\u0026#39;) { return value.toUpperCase(); } return value.toFixed(2); } // Sınıflar için instanceof function processDate(date: Date | string) { if (date instanceof Date) { return date.toISOString(); } return new Date(date).toISOString(); } Type Predicate\u0026rsquo;leri Etkili Kullanma\ninterface User { id: number; name: string; } interface Admin extends User { role: \u0026#39;admin\u0026#39;; permissions: string[]; } function isAdmin(user: User): user is Admin { return \u0026#39;role\u0026#39; in user \u0026amp;\u0026amp; user.role === \u0026#39;admin\u0026#39;; } Discriminated Unions\u0026rsquo;ı Düzgün Yapılandırma\ninterface ApiSuccess { status: \u0026#39;success\u0026#39;; data: any; } interface ApiError { status: \u0026#39;error\u0026#39;; error: string; } type ApiResponse = ApiSuccess | ApiError; function handleResponse(response: ApiResponse) { if (response.status === \u0026#39;success\u0026#39;) { processData(response.data); } else { handleError(response.error); } } Sonuç Type narrowing, TypeScript\u0026rsquo;in en güçlü özelliklerinden biridir. Bu teknikler sayesinde:\nDaha güvenli kod yazabilirsiniz Runtime hatalarını azaltabilirsiniz IDE desteğinden maksimum fayda sağlayabilirsiniz Karmaşık tip yapılarını daha kolay yönetebilirsiniz Bir sonraki yazımızda TypeScript\u0026rsquo;in diğer ileri seviye özelliklerini incelemeye devam edeceğiz. Görüşmek üzere!\n",
    "tags": ["typescript","type-narrowing","type-guards"],
    "categories": ["TypeScript"],
    "lang": "tr"
} 